# File GENERATED by scripts/generate_sources.py - DO NOT EDIT.
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import pyarrow
import pyarrow._compute
from pyarrow._compute import Expression


def _handle_options(name, options_class, options, args, **kwargs):
    if options is not None:
        if isinstance(options, dict):
            return options_class(**options)
        elif isinstance(options, options_class):
            return options
        raise TypeError(
            "Function {!r} expected a {} parameter, got {}"
            .format(name, options_class, type(options)))

    if args or kwargs:
        # Note: This check is no longer permissable
        # Generating function code with real signatures means that
        # All of the keyword arguments have default values, and so
        # this would always be true. As the default for the options object
        # is always false, the options object takes precedence if provided.
        #
        # if options is not None:
        #    raise TypeError(
        #        "Function {!r} called with both an 'options' argument "
        #        "and additional arguments"
        #        .format(name))

        return options_class(*args, **kwargs)

    return None


def abs(x, /, *, memory_pool=None):
    """Calculate the absolute value of the argument element-wise.

    Results will wrap around on integer overflow.
    Use function "abs_checked" if you want overflow
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `abs` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('abs')

    if isinstance(x, Expression):
        return Expression._call(
            'abs',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def abs_checked(x, /, *, memory_pool=None):
    """Calculate the absolute value of the argument element-wise.

    This function returns an error on overflow.  For a variant that
    doesn't fail on overflow, use function "abs".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `abs_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('abs_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'abs_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def acos(x, /, *, memory_pool=None):
    """Compute the inverse cosine.

    NaN is returned for invalid input values;
    to raise an error instead, see "acos_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `acos` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('acos')

    if isinstance(x, Expression):
        return Expression._call(
            'acos',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def acos_checked(x, /, *, memory_pool=None):
    """Compute the inverse cosine.

    Invalid input values raise an error;
    to return NaN instead, see "acos".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `acos_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('acos_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'acos_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def add(x, y, /, *, memory_pool=None):
    """Add the arguments element-wise.

    Results will wrap around on integer overflow.
    Use function "add_checked" if you want overflow
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `add` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('add')

    if isinstance(x, Expression):
        return Expression._call(
            'add',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def add_checked(x, y, /, *, memory_pool=None):
    """Add the arguments element-wise.

    This function returns an error on overflow.  For a variant that
    doesn't fail on overflow, use function "add".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `add_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('add_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'add_checked',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def all(array, /, *, skip_nulls=True, min_count=1, options=None,
        memory_pool=None):
    """Test whether all elements in a boolean array evaluate to true.

    Null values are ignored by default.
    If the `skip_nulls` option is set to false, then Kleene logic is used.
    See "kleene_and" for more details on Kleene logic.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `all` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([True, True, None, False, True])
    >>> pc.all(arr)
    <pyarrow.BooleanScalar: False>
    >>> arr = pa.array([True, True, None, True, None, None])
    >>> pc.all(arr)
    <pyarrow.BooleanScalar: True>
    >>> pc.all(arr, skip_nulls = False)
    <pyarrow.BooleanScalar: None>
    >>> pc.all(arr, min_count = 4)
    <pyarrow.BooleanScalar: None>
    >>> pc.all(arr, min_count = 10)
    <pyarrow.BooleanScalar: None>
    >>> pc.all(arr, min_count = 2)
    <pyarrow.BooleanScalar: True>
    """

    _computed_options = _handle_options(
        'all',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('all')

    if isinstance(array, Expression):
        return Expression._call(
            'all',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def and_(x, y, /, *, memory_pool=None):
    """Logical 'and' boolean values.

    When a null is encountered in either input, a null is output.
    For a different null behavior, see function "and_kleene".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `and` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('and')

    if isinstance(x, Expression):
        return Expression._call(
            'and_',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def and_kleene(x, y, /, *, memory_pool=None):
    """Logical 'and' boolean values (Kleene logic).

    This function behaves as follows with nulls:

    - true and null = null
    - null and true = null
    - false and null = false
    - null and false = false
    - null and null = null

    In other words, in this context a null value really means "unknown",
    and an unknown value 'and' false is always false.
    For a different null behavior, see function "and".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `and_kleene` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('and_kleene')

    if isinstance(x, Expression):
        return Expression._call(
            'and_kleene',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def and_not(x, y, /, *, memory_pool=None):
    """Logical 'and not' boolean values.

    When a null is encountered in either input, a null is output.
    For a different null behavior, see function "and_not_kleene".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `and_not` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('and_not')

    if isinstance(x, Expression):
        return Expression._call(
            'and_not',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def and_not_kleene(x, y, /, *, memory_pool=None):
    """Logical 'and not' boolean values (Kleene logic).

    This function behaves as follows with nulls:

    - true and null = null
    - null and false = null
    - false and null = false
    - null and true = false
    - null and null = null

    In other words, in this context a null value really means "unknown",
    and an unknown value 'and not' true is always false, as is false
    'and not' an unknown value.
    For a different null behavior, see function "and_not".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `and_not_kleene` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('and_not_kleene')

    if isinstance(x, Expression):
        return Expression._call(
            'and_not_kleene',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def any(array, /, *, skip_nulls=True, min_count=1, options=None,
        memory_pool=None):
    """Test whether any element in a boolean array evaluates to true.

    Null values are ignored by default.
    If the `skip_nulls` option is set to false, then Kleene logic is used.
    See "kleene_or" for more details on Kleene logic.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `any` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([True, True, None, False, True])
    >>> pc.any(arr)
    <pyarrow.BooleanScalar: True>
    >>> pc.any(arr, min_count = 4)
    <pyarrow.BooleanScalar: True>
    >>> pc.any(arr, min_count = len(arr))
    <pyarrow.BooleanScalar: None>
    >>> arr = pa.array([False, False, None, False, True])
    >>> pc.any(arr)
    <pyarrow.BooleanScalar: True>
    >>> pc.any(arr, min_count = 2)
    <pyarrow.BooleanScalar: True>
    >>> pc.any(arr, min_count = len(arr))
    <pyarrow.BooleanScalar: None>
    >>> pc.any(arr, skip_nulls = False)
    <pyarrow.BooleanScalar: True>
    >>> pc.any([False,None], skip_nulls = False)
    <pyarrow.BooleanScalar: None>
    >>> pc.any([False,None], skip_nulls = True)
    <pyarrow.BooleanScalar: False>
    """

    _computed_options = _handle_options(
        'any',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('any')

    if isinstance(array, Expression):
        return Expression._call(
            'any',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def approximate_median(array, /, *, skip_nulls=True, min_count=1, options=None,
                       memory_pool=None):
    """Approximate median of a numeric array with T-Digest algorithm.

    Nulls and NaNs are ignored.
    A null scalar is returned if there is no valid data point.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `approximate_median` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'approximate_median',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('approximate_median')

    if isinstance(array, Expression):
        return Expression._call(
            'approximate_median',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def array_filter(array, selection_filter, /, null_selection_behavior='drop', *,
                 options=None, memory_pool=None):
    """Filter with a boolean selection filter.

    The output is populated with values from the input `array` at positions
    where the selection filter is non-zero.  Nulls in the selection filter
    are handled based on FilterOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    selection_filter : Array-like
        Argument to compute function.
    null_selection_behavior : str, default "drop"
        How to handle nulls in the selection filter.
        Accepted values are "drop", "emit_null".
    options : pyarrow.compute.FilterOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `array_filter` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'array_filter',
        pyarrow._compute.FilterOptions,
        options,
        (),
        null_selection_behavior=null_selection_behavior
    )
    func = pyarrow._compute.get_function('array_filter')

    if isinstance(array, Expression):
        return Expression._call(
            'array_filter',
            [array, selection_filter],
            _computed_options
        )

    return(
        func.call([array, selection_filter], _computed_options, memory_pool)
    )


def array_sort_indices(array, /, order='ascending', *, null_placement='at_end',
                       options=None, memory_pool=None):
    """Return the indices that would sort an array.

    This function computes an array of indices that define a stable sort
    of the input array.  By default, Null values are considered greater
    than any other value and are therefore sorted at the end of the array.
    For floating-point types, NaNs are considered greater than any
    other non-null value, but smaller than null values.

    The handling of nulls and NaNs can be changed in ArraySortOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    order : str, default "ascending"
        Which order to sort values in.
        Accepted values are "ascending", "descending".
    null_placement : str, default "at_end"
        Where nulls in the input should be sorted.
        Accepted values are "at_start", "at_end".
    options : pyarrow.compute.ArraySortOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `array_sort_indices` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'array_sort_indices',
        pyarrow._compute.ArraySortOptions,
        options,
        (),
        order=order,
        null_placement=null_placement
    )
    func = pyarrow._compute.get_function('array_sort_indices')

    if isinstance(array, Expression):
        return Expression._call(
            'array_sort_indices',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def array_take(array, indices, /, *, boundscheck=True, options=None,
               memory_pool=None):
    """Select values from an array based on indices from another array.

    The output is populated with values from the input array at positions
    given by `indices`.  Nulls in `indices` emit null in the output.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    indices : Array-like
        Argument to compute function.
    boundscheck : boolean, default True
        Whether to check indices are within bounds. If False and an
        index is out of boundes, behavior is undefined (the process
        may crash).
    options : pyarrow.compute.TakeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `array_take` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'array_take',
        pyarrow._compute.TakeOptions,
        options,
        (),
        boundscheck=boundscheck
    )
    func = pyarrow._compute.get_function('array_take')

    if isinstance(array, Expression):
        return Expression._call(
            'array_take',
            [array, indices],
            _computed_options
        )

    return(
        func.call([array, indices], _computed_options, memory_pool)
    )


def ascii_capitalize(strings, /, *, memory_pool=None):
    """Capitalize the first character of ASCII input.

    For each string in `strings`, return a capitalized version.

    This function assumes the input is fully ASCII.  If it may contain
    non-ASCII characters, use "utf8_capitalize" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_capitalize` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_capitalize')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_capitalize',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_center(strings, /, width=None, padding=' ', *, options=None,
                 memory_pool=None):
    """Center strings by padding with a given character.

    For each string in `strings`, emit a centered string by padding both
        sides
    with the given ASCII character.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_center` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_center',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('ascii_center')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_center',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_is_alnum(strings, /, *, memory_pool=None):
    """Classify strings as ASCII alphanumeric.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of alphanumeric ASCII characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_alnum` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_alnum')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_alnum',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_alpha(strings, /, *, memory_pool=None):
    """Classify strings as ASCII alphabetic.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of alphabetic ASCII characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_alpha` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_alpha')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_alpha',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_decimal(strings, /, *, memory_pool=None):
    """Classify strings as ASCII decimal.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of decimal ASCII characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_decimal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_decimal')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_decimal',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_lower(strings, /, *, memory_pool=None):
    """Classify strings as ASCII lowercase.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of lowercase ASCII characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_lower` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_lower')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_lower',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_printable(strings, /, *, memory_pool=None):
    """Classify strings as ASCII printable.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of printable ASCII characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_printable` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_printable')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_printable',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_space(strings, /, *, memory_pool=None):
    """Classify strings as ASCII whitespace.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of whitespace ASCII characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_space` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_space')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_space',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_title(strings, /, *, memory_pool=None):
    """Classify strings as ASCII titlecase.

    For each string in `strings`, emit true iff the string is title-cased,
    i.e. it has at least one cased character, each uppercase character
    follows an uncased character, and each lowercase character follows
    an uppercase character.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_title` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_title')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_title',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_is_upper(strings, /, *, memory_pool=None):
    """Classify strings as ASCII uppercase.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of uppercase ASCII characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_is_upper` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_is_upper')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_is_upper',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_lower(strings, /, *, memory_pool=None):
    """Transform ASCII input to lowercase.

    For each string in `strings`, return a lowercase version.

    This function assumes the input is fully ASCII.  If it may contain
    non-ASCII characters, use "utf8_lower" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_lower` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_lower')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_lower',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_lpad(strings, /, width=None, padding=' ', *, options=None,
               memory_pool=None):
    """Right-align strings by padding with a given character.

    For each string in `strings`, emit a right-aligned string by prepending
    the given ASCII character.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_lpad` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_lpad',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('ascii_lpad')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_lpad',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_ltrim(strings, /, characters=None, *, options=None,
                memory_pool=None):
    """Trim leading characters.

    For each string in `strings`, remove any leading characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.
    Both the `strings` and the `characters` are interpreted as
    ASCII; to trim non-ASCII characters, use `utf8_ltrim`.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_ltrim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_ltrim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('ascii_ltrim')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_ltrim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_ltrim_whitespace(strings, /, *, memory_pool=None):
    """Trim leading ASCII whitespace characters.

    For each string in `strings`, emit a string with leading ASCII whitespace
    characters removed.  Use `utf8_ltrim_whitespace` to trim leading Unicode
    whitespace characters. Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_ltrim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_ltrim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_ltrim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_reverse(strings, /, *, memory_pool=None):
    """Reverse ASCII input.

    For each ASCII string in `strings`, return a reversed version.

    This function assumes the input is fully ASCII.  If it may contain
    non-ASCII characters, use "utf8_reverse" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_reverse` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_reverse')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_reverse',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_rpad(strings, /, width=None, padding=' ', *, options=None,
               memory_pool=None):
    """Left-align strings by padding with a given character.

    For each string in `strings`, emit a left-aligned string by appending
    the given ASCII character.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_rpad` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_rpad',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('ascii_rpad')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_rpad',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_rtrim(strings, /, characters=None, *, options=None,
                memory_pool=None):
    """Trim trailing characters.

    For each string in `strings`, remove any trailing characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.
    Both the `strings` and the `characters` are interpreted as
    ASCII; to trim non-ASCII characters, use `utf8_rtrim`.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_rtrim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_rtrim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('ascii_rtrim')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_rtrim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_rtrim_whitespace(strings, /, *, memory_pool=None):
    """Trim trailing ASCII whitespace characters.

    For each string in `strings`, emit a string with trailing ASCII
        whitespace
    characters removed. Use `utf8_rtrim_whitespace` to trim trailing Unicode
    whitespace characters. Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_rtrim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_rtrim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_rtrim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_split_whitespace(strings, /, *, max_splits=None, reverse=False,
                           options=None,
                           memory_pool=None):
    """Split string according to any ASCII whitespace.

    Split each string according any non-zero length sequence of ASCII
    whitespace characters.  The output for each string input is a list
    of strings.

    The maximum number of splits and direction of splitting
    (forward, reverse) can optionally be defined in SplitOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    max_splits : int or None, default None
        Maximum number of splits for each input value (unlimited if None).
    reverse : bool, default False
        Whether to start splitting from the end of each input value.
        This only has an effect if `max_splits` is not None.
    options : pyarrow.compute.SplitOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_split_whitespace` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_split_whitespace',
        pyarrow._compute.SplitOptions,
        options,
        (),
        max_splits=max_splits,
        reverse=reverse
    )
    func = pyarrow._compute.get_function('ascii_split_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_split_whitespace',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_swapcase(strings, /, *, memory_pool=None):
    """Transform ASCII input by inverting casing.

    For each string in `strings`, return a string with opposite casing.

    This function assumes the input is fully ASCII.  If it may contain
    non-ASCII characters, use "utf8_swapcase" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_swapcase` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_swapcase')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_swapcase',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_title(strings, /, *, memory_pool=None):
    """Titlecase each word of ASCII input.

    For each string in `strings`, return a titlecased version.
    Each word in the output will start with an uppercase character and its
    remaining characters will be lowercase.

    This function assumes the input is fully ASCII.  If it may contain
    non-ASCII characters, use "utf8_title" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_title` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_title')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_title',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_trim(strings, /, characters=None, *, options=None, memory_pool=None):
    """Trim leading and trailing characters.

    For each string in `strings`, remove any leading or trailing characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.
    Both the `strings` and the `characters` are interpreted as
    ASCII; to trim non-ASCII characters, use `utf8_trim`.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_trim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ascii_trim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('ascii_trim')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_trim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def ascii_trim_whitespace(strings, /, *, memory_pool=None):
    """Trim leading and trailing ASCII whitespace characters.

    For each string in `strings`, emit a string with leading and trailing
        ASCII
    whitespace characters removed. Use `utf8_trim_whitespace` to trim Unicode
    whitespace characters. Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_trim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_trim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_trim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def ascii_upper(strings, /, *, memory_pool=None):
    """Transform ASCII input to uppercase.

    For each string in `strings`, return an uppercase version.

    This function assumes the input is fully ASCII.  It it may contain
    non-ASCII characters, use "utf8_upper" instead.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ascii_upper` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ascii_upper')

    if isinstance(strings, Expression):
        return Expression._call(
            'ascii_upper',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def asin(x, /, *, memory_pool=None):
    """Compute the inverse sine.

    NaN is returned for invalid input values;
    to raise an error instead, see "asin_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `asin` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('asin')

    if isinstance(x, Expression):
        return Expression._call(
            'asin',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def asin_checked(x, /, *, memory_pool=None):
    """Compute the inverse sine.

    Invalid input values raise an error;
    to return NaN instead, see "asin".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `asin_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('asin_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'asin_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def assume_timezone(timestamps, /, timezone=None, *, ambiguous='raise',
                    nonexistent='raise', options=None,
                    memory_pool=None):
    """Convert naive timestamp to timezone-aware timestamp.

    Input timestamps are assumed to be relative to the timezone given in the
    `timezone` option. They are converted to UTC-relative timestamps and
    the output type has its timezone set to the value of the `timezone`
    option. Null values emit null.
    This function is meant to be used when an external system produces
    "timezone-naive" timestamps which need to be converted to
    "timezone-aware" timestamps. An error is returned if the timestamps
    already have a defined timezone.

    Parameters
    ----------
    timestamps : Array-like or scalar-like
        Argument to compute function.
    timezone : str
        Timezone to assume for the input.
    ambiguous : str, default "raise"
        How to handle timestamps that are ambiguous in the assumed timezone.
        Accepted values are "raise", "earliest", "latest".
    nonexistent : str, default "raise"
        How to handle timestamps that don't exist in the assumed timezone.
        Accepted values are "raise", "earliest", "latest".
    options : pyarrow.compute.AssumeTimezoneOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `assume_timezone` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'assume_timezone',
        pyarrow._compute.AssumeTimezoneOptions,
        options,
        (),
        timezone=timezone,
        ambiguous=ambiguous,
        nonexistent=nonexistent
    )
    func = pyarrow._compute.get_function('assume_timezone')

    if isinstance(timestamps, Expression):
        return Expression._call(
            'assume_timezone',
            [timestamps],
            _computed_options
        )

    return(
        func.call([timestamps], _computed_options, memory_pool)
    )


def atan(x, /, *, memory_pool=None):
    """Compute the inverse tangent of x.

    The return value is in the range [-pi/2, pi/2];
    for a full return range [-pi, pi], see "atan2".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `atan` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('atan')

    if isinstance(x, Expression):
        return Expression._call(
            'atan',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def atan2(y, x, /, *, memory_pool=None):
    """Compute the inverse tangent of y/x.

    The return value is in the range [-pi, pi].

    Parameters
    ----------
    y : Array-like or scalar-like
        Argument to compute function.
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `atan2` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('atan2')

    if isinstance(y, Expression):
        return Expression._call(
            'atan2',
            [y, x]
        )

    return(
        func.call([y, x], memory_pool=memory_pool)
    )


def binary_join(strings, separator, /, *, memory_pool=None):
    """Join a list of strings together with a separator.

    Concatenate the strings in `list`. The `separator` is inserted
    between each given string.
    Any null input and any null `list` element emits a null output.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    separator : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_join` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('binary_join')

    if isinstance(strings, Expression):
        return Expression._call(
            'binary_join',
            [strings, separator]
        )

    return(
        func.call([strings, separator], memory_pool=memory_pool)
    )


def binary_join_element_wise(*strings, null_handling='emit_null',
                             null_replacement='',
                             options=None,
                             memory_pool=None):
    """Join string arguments together, with the last argument as separator.

    Concatenate the `strings` except for the last one. The last argument
    in `strings` is inserted between each given string.
    Any null separator element emits a null output. Null elements either
    emit a null (the default), are skipped, or replaced with a given string.

    Parameters
    ----------
    *strings : Array-like or scalar-like
        Argument to compute function.
    null_handling : str, default "emit_null"
        How to handle null values in the inputs.
        Accepted values are "emit_null", "skip", "replace".
    null_replacement : str, default ""
        Replacement string to emit for null inputs if `null_handling`
        is "replace".
    options : pyarrow.compute.JoinOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_join_element_wise` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'binary_join_element_wise',
        pyarrow._compute.JoinOptions,
        options,
        (),
        null_handling=null_handling,
        null_replacement=null_replacement
    )
    func = pyarrow._compute.get_function('binary_join_element_wise')
    return(
        func.call([*strings], _computed_options, memory_pool)
    )


def binary_length(strings, /, *, memory_pool=None):
    """Compute string lengths.

    For each string in `strings`, emit its length of bytes.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_length` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('binary_length')

    if isinstance(strings, Expression):
        return Expression._call(
            'binary_length',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def binary_repeat(strings, num_repeats, /, *, memory_pool=None):
    """Repeat a binary string.

    For each binary string in `strings`, return a replicated version.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    num_repeats : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_repeat` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('binary_repeat')

    if isinstance(strings, Expression):
        return Expression._call(
            'binary_repeat',
            [strings, num_repeats]
        )

    return(
        func.call([strings, num_repeats], memory_pool=memory_pool)
    )


def binary_replace_slice(strings, /, start=None, stop=None, replacement=None,
                         *, options=None,
                         memory_pool=None):
    """Replace a slice of a binary string.

    For each string in `strings`, replace a slice of the string defined by
        `start`
    and `stop` indices with the given `replacement`. `start` is inclusive
    and `stop` is exclusive, and both are measured in bytes.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    start : int
        Index to start slicing at (inclusive).
    stop : int
        Index to stop slicing at (exclusive).
    replacement : str
        What to replace the slice with.
    options : pyarrow.compute.ReplaceSliceOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_replace_slice` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'binary_replace_slice',
        pyarrow._compute.ReplaceSliceOptions,
        options,
        (),
        start=start,
        stop=stop,
        replacement=replacement
    )
    func = pyarrow._compute.get_function('binary_replace_slice')

    if isinstance(strings, Expression):
        return Expression._call(
            'binary_replace_slice',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def binary_reverse(strings, /, *, memory_pool=None):
    """Reverse binary input.

    For each binary string in `strings`, return a reversed version.

    This function reverses the binary data at a byte-level.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `binary_reverse` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('binary_reverse')

    if isinstance(strings, Expression):
        return Expression._call(
            'binary_reverse',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def bit_wise_and(x, y, /, *, memory_pool=None):
    """Bit-wise AND the arguments element-wise.

    Null values return null.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `bit_wise_and` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('bit_wise_and')

    if isinstance(x, Expression):
        return Expression._call(
            'bit_wise_and',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def bit_wise_not(x, /, *, memory_pool=None):
    """Bit-wise negate the arguments element-wise.

    Null values return null.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `bit_wise_not` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('bit_wise_not')

    if isinstance(x, Expression):
        return Expression._call(
            'bit_wise_not',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def bit_wise_or(x, y, /, *, memory_pool=None):
    """Bit-wise OR the arguments element-wise.

    Null values return null.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `bit_wise_or` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('bit_wise_or')

    if isinstance(x, Expression):
        return Expression._call(
            'bit_wise_or',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def bit_wise_xor(x, y, /, *, memory_pool=None):
    """Bit-wise XOR the arguments element-wise.

    Null values return null.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `bit_wise_xor` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('bit_wise_xor')

    if isinstance(x, Expression):
        return Expression._call(
            'bit_wise_xor',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def case_when(cond, /, *cases, memory_pool=None):
    """Choose values based on multiple conditions.

    `cond` must be a struct of Boolean values. `cases` can be a mix
    of scalar and array arguments (of any type, but all must be the
    same type or castable to a common type), with either exactly one
    datum per child of `cond`, or one more `cases` than children of
    `cond` (in which case we have an "else" value).

    Each row of the output will be the corresponding value of the
    first datum in `cases` for which the corresponding child of `cond`
    is true, or otherwise the "else" value (if given), or null.

    Essentially, this implements a switch-case or if-else, if-else...
        statement.

    Parameters
    ----------
    cond : Array-like or scalar-like
        Argument to compute function.
    *cases : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `case_when` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('case_when')
    return(
        func.call([cond, *cases], memory_pool=memory_pool)
    )


def cast(input, /, target_type=None, *, allow_int_overflow=None,
         allow_time_truncate=None, allow_time_overflow=None,
         allow_decimal_truncate=None, allow_float_truncate=None,
         allow_invalid_utf8=None, options=None, memory_pool=None):
    """Cast values to another data type.

    Behavior when values wouldn't fit in the target type
    can be controlled through CastOptions.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    target_type : DataType, optional
        The PyArrow type to cast to.
    allow_int_overflow : bool, default False
        Whether integer overflow is allowed when casting.
    allow_time_truncate : bool, default False
        Whether time precision truncation is allowed when casting.
    allow_time_overflow : bool, default False
        Whether date/time range overflow is allowed when casting.
    allow_decimal_truncate : bool, default False
        Whether decimal precision truncation is allowed when casting.
    allow_float_truncate : bool, default False
        Whether floating-point precision truncation is allowed when casting.
    allow_invalid_utf8 : bool, default False
        Whether producing invalid utf8 data is allowed when casting.
    options : pyarrow.compute.CastOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `cast` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'cast',
        pyarrow._compute.CastOptions,
        options,
        (),
        target_type=target_type,
        allow_int_overflow=allow_int_overflow,
        allow_time_truncate=allow_time_truncate,
        allow_time_overflow=allow_time_overflow,
        allow_decimal_truncate=allow_decimal_truncate,
        allow_float_truncate=allow_float_truncate,
        allow_invalid_utf8=allow_invalid_utf8
    )
    func = pyarrow._compute.get_function('cast')

    if isinstance(input, Expression):
        return Expression._call(
            'cast',
            [input],
            _computed_options
        )

    return(
        func.call([input], _computed_options, memory_pool)
    )


def ceil(x, /, *, memory_pool=None):
    """Round up to the nearest integer.

    Compute the smallest integer value not less in magnitude than `x`.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ceil` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ceil')

    if isinstance(x, Expression):
        return Expression._call(
            'ceil',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def ceil_temporal(timestamps, /, multiple=1, unit='day', *,
                  week_starts_monday=True,
                  ceil_is_strictly_greater=False,
                  calendar_based_origin=False, options=None,
                  memory_pool=None):
    """Round temporal values up to nearest multiple of specified time unit.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    timestamps : Array-like or scalar-like
        Argument to compute function.
    multiple : int, default 1
        Number of units to round to.
    unit : str, default "day"
        The unit in which `multiple` is expressed.
        Accepted values are "year", "quarter", "month", "week", "day",
        "hour", "minute", "second", "millisecond", "microsecond",
        "nanosecond".
    week_starts_monday : bool, default True
        If True, weeks start on Monday; if False, on Sunday.
    ceil_is_strictly_greater : bool, default False
        If True, ceil returns a rounded value that is strictly greater than
        the
        input. For example: ceiling 1970-01-01T00:00:00 to 3 hours would
        yield 1970-01-01T03:00:00 if set to True and 1970-01-01T00:00:00
        if set to False.
        This applies to the ceil_temporal function only.
    calendar_based_origin : bool, default False
        By default, the origin is 1970-01-01T00:00:00. By setting this to
        True,
        rounding origin will be beginning of one less precise calendar unit.
        E.g.: rounding to hours will use beginning of day as origin.

        By default time is rounded to a multiple of units since
        1970-01-01T00:00:00. By setting calendar_based_origin to true,
        time will be rounded to number of units since the last greater
        calendar unit.
        For example: rounding to multiple of days since the beginning of the
        month or to hours since the beginning of the day.
        Exceptions: week and quarter are not used as greater units,
        therefore days will be rounded to the beginning of the month not
        week. Greater unit of week is a year.
        Note that ceiling and rounding might change sorting order of an array
        near greater unit change. For example rounding YYYY-mm-dd 23:00:00 to
        5 hours will ceil and round to YYYY-mm-dd+1 01:00:00 and floor to
        YYYY-mm-dd 20:00:00. On the other hand YYYY-mm-dd+1 00:00:00 will
        ceil, round and floor to YYYY-mm-dd+1 00:00:00. This can break the
        order of an already ordered array.
    options : pyarrow.compute.RoundTemporalOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ceil_temporal` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ceil_temporal',
        pyarrow._compute.RoundTemporalOptions,
        options,
        (),
        multiple=multiple,
        unit=unit,
        week_starts_monday=week_starts_monday,
        ceil_is_strictly_greater=ceil_is_strictly_greater,
        calendar_based_origin=calendar_based_origin
    )
    func = pyarrow._compute.get_function('ceil_temporal')

    if isinstance(timestamps, Expression):
        return Expression._call(
            'ceil_temporal',
            [timestamps],
            _computed_options
        )

    return(
        func.call([timestamps], _computed_options, memory_pool)
    )


def choose(indices, /, *values, memory_pool=None):
    """Choose values from several arrays.

    For each row, the value of the first argument is used as a 0-based index
    into the list of `values` arrays (i.e. index 0 selects the first of the
    `values` arrays). The output value is the corresponding value of the
    selected argument.

    If an index is null, the output will be null.

    Parameters
    ----------
    indices : Array-like or scalar-like
        Argument to compute function.
    *values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `choose` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('choose')
    return(
        func.call([indices, *values], memory_pool=memory_pool)
    )


def coalesce(*values, memory_pool=None):
    """Select the first non-null value.

    Each row of the output will be the value from the first corresponding
        input
    for which the value is not null. If all inputs are null in a row, the
        output
    will be null.

    Parameters
    ----------
    *values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `coalesce` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('coalesce')
    return(
        func.call([*values], memory_pool=memory_pool)
    )


def cos(x, /, *, memory_pool=None):
    """Compute the cosine.

    NaN is returned for invalid input values;
    to raise an error instead, see "cos_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `cos` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('cos')

    if isinstance(x, Expression):
        return Expression._call(
            'cos',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def cos_checked(x, /, *, memory_pool=None):
    """Compute the cosine.

    Infinite values raise an error;
    to return NaN instead, see "cos".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `cos_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('cos_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'cos_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def count(array, /, mode='only_valid', *, options=None, memory_pool=None):
    """Count the number of null / non-null values.

    By default, only non-null values are counted.
    This can be changed through CountOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    mode : str, default "only_valid"
        Which values to count in the input.
        Accepted values are "only_valid", "only_null", "all".
    options : pyarrow.compute.CountOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `count` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([True, True, None, False, True])
    >>> pc.count(arr)
    <pyarrow.Int64Scalar: 4>
    >>> pc.count(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count(arr, mode = "all")
    <pyarrow.Int64Scalar: 5>
    >>> arr = pa.array([0, 1, -1, None])
    >>> pc.count(arr)
    <pyarrow.Int64Scalar: 3>
    >>> pc.count(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count(arr, mode = "all")
    <pyarrow.Int64Scalar: 4>
    >>> arr = pa.array(["string", "", None, " "])
    >>> pc.count(arr)
    <pyarrow.Int64Scalar: 3>
    >>> pc.count(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count(arr, mode = "all")
    <pyarrow.Int64Scalar: 4>
    """

    _computed_options = _handle_options(
        'count',
        pyarrow._compute.CountOptions,
        options,
        (),
        mode=mode
    )
    func = pyarrow._compute.get_function('count')

    if isinstance(array, Expression):
        return Expression._call(
            'count',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def count_distinct(array, /, mode='only_valid', *, options=None,
                   memory_pool=None):
    """Count the number of unique values.

    By default, only non-null values are counted.
    This can be changed through CountOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    mode : str, default "only_valid"
        Which values to count in the input.
        Accepted values are "only_valid", "only_null", "all".
    options : pyarrow.compute.CountOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `count_distinct` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([True, True, None, False, True, None])
    >>> pc.count_distinct(arr)
    <pyarrow.Int64Scalar: 2>
    >>> pc.count_distinct(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count_distinct(arr, mode = "all")
    <pyarrow.Int64Scalar: 3>
    >>> arr = pa.array([0, 1, -1, 0, 1, None, None])
    >>> pc.count_distinct(arr)
    <pyarrow.Int64Scalar: 3>
    >>> pc.count_distinct(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count_distinct(arr, mode = "all")
    <pyarrow.Int64Scalar: 4>
    >>> arr = pa.array(["string", "", None, None, " ", ""])
    >>> pc.count_distinct(arr)
    <pyarrow.Int64Scalar: 3>
    >>> pc.count_distinct(arr, mode = "only_null")
    <pyarrow.Int64Scalar: 1>
    >>> pc.count_distinct(arr, mode = "all")
    <pyarrow.Int64Scalar: 4>
    """

    _computed_options = _handle_options(
        'count_distinct',
        pyarrow._compute.CountOptions,
        options,
        (),
        mode=mode
    )
    func = pyarrow._compute.get_function('count_distinct')

    if isinstance(array, Expression):
        return Expression._call(
            'count_distinct',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def count_substring(strings, /, pattern=None, *, ignore_case=False,
                    options=None, memory_pool=None):
    """Count occurrences of substring.

    For each string in `strings`, emit the number of occurrences of the given
    literal pattern.
    Null inputs emit null. The pattern must be given in
        MatchSubstringOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `count_substring` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'count_substring',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('count_substring')

    if isinstance(strings, Expression):
        return Expression._call(
            'count_substring',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def count_substring_regex(strings, /, pattern=None, *, ignore_case=False,
                          options=None,
                          memory_pool=None):
    """Count occurrences of substring.

    For each string in `strings`, emit the number of occurrences of the given
    regular expression pattern.
    Null inputs emit null. The pattern must be given in
        MatchSubstringOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `count_substring_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'count_substring_regex',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('count_substring_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'count_substring_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def cumulative_sum(values, /, start=0.0, *, skip_nulls=False, options=None,
                   memory_pool=None):
    """Compute the cumulative sum over a numeric input.

    `values` must be numeric. Return an array/chunked array which is the
    cumulative sum computed over `values`. Results will wrap around on
    integer overflow. Use function "cumulative_sum_checked" if you want
    overflow to return an error.

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    start : Scalar, default 0.0
        Starting value for sum computation
    skip_nulls : bool, default False
        When false, the first encountered null is propagated.
    options : pyarrow.compute.CumulativeSumOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `cumulative_sum` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'cumulative_sum',
        pyarrow._compute.CumulativeSumOptions,
        options,
        (),
        start=start,
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('cumulative_sum')

    if isinstance(values, Expression):
        return Expression._call(
            'cumulative_sum',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def cumulative_sum_checked(values, /, start=0.0, *, skip_nulls=False,
                           options=None,
                           memory_pool=None):
    """Compute the cumulative sum over a numeric input.

    `values` must be numeric. Return an array/chunked array which is the
    cumulative sum computed over `values`. This function returns an error
    on overflow. For a variant that doesn't fail on overflow, use
    function "cumulative_sum".

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    start : Scalar, default 0.0
        Starting value for sum computation
    skip_nulls : bool, default False
        When false, the first encountered null is propagated.
    options : pyarrow.compute.CumulativeSumOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `cumulative_sum_checked` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'cumulative_sum_checked',
        pyarrow._compute.CumulativeSumOptions,
        options,
        (),
        start=start,
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('cumulative_sum_checked')

    if isinstance(values, Expression):
        return Expression._call(
            'cumulative_sum_checked',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def day(values, /, *, memory_pool=None):
    """Extract day number.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `day` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('day')

    if isinstance(values, Expression):
        return Expression._call(
            'day',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def day_of_week(values, /, *, count_from_zero=True, week_start=1, options=None,
                memory_pool=None):
    """Extract day of the week number.

    By default, the week starts on Monday represented by 0 and ends on Sunday
    represented by 6.
    `DayOfWeekOptions.week_start` can be used to set another starting day
        using
    the ISO numbering convention (1=start week on Monday, 7=start week on
        Sunday).
    Day numbers can start at 0 or 1 based on
        `DayOfWeekOptions.count_from_zero`.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    count_from_zero : bool, default True
        If True, number days from 0, otherwise from 1.
    week_start : int, default 1
        Which day does the week start with (Monday=1, Sunday=7).
        How this value is numbered is unaffected by `count_from_zero`.
    options : pyarrow.compute.DayOfWeekOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `day_of_week` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'day_of_week',
        pyarrow._compute.DayOfWeekOptions,
        options,
        (),
        count_from_zero=count_from_zero,
        week_start=week_start
    )
    func = pyarrow._compute.get_function('day_of_week')

    if isinstance(values, Expression):
        return Expression._call(
            'day_of_week',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def day_of_year(values, /, *, memory_pool=None):
    """Extract day of year number.

    January 1st maps to day number 1, February 1st to 32, etc.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `day_of_year` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('day_of_year')

    if isinstance(values, Expression):
        return Expression._call(
            'day_of_year',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def day_time_interval_between(start, end, /, *, memory_pool=None):
    """Compute the number of days and milliseconds between two timestamps.

    Returns the number of days and milliseconds from `start` to `end`.
    That is, first the difference in days is computed as if both
    timestamps were truncated to the day, then the difference between time
        times
    of the two timestamps is computed as if both times were truncated to the
    millisecond.
    Null values return null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `day_time_interval_between` compute function in the Arrow C++
        library.
    """

    func = pyarrow._compute.get_function('day_time_interval_between')

    if isinstance(start, Expression):
        return Expression._call(
            'day_time_interval_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def days_between(start, end, /, *, memory_pool=None):
    """Compute the number of days between two timestamps.

    Returns the number of day boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the day.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `days_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('days_between')

    if isinstance(start, Expression):
        return Expression._call(
            'days_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def dictionary_encode(array, /, null_encoding='mask', *, options=None,
                      memory_pool=None):
    """Dictionary-encode array.

    Return a dictionary-encoded version of the input array.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    null_encoding : str, default "mask"
        How to encode nulls in the input.
        Accepted values are "mask" (null inputs emit a null in the indices
        array), "encode" (null inputs emit a non-null index pointing to
        a null value in the dictionary array).
    options : pyarrow.compute.DictionaryEncodeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `dictionary_encode` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'dictionary_encode',
        pyarrow._compute.DictionaryEncodeOptions,
        options,
        (),
        null_encoding=null_encoding
    )
    func = pyarrow._compute.get_function('dictionary_encode')

    if isinstance(array, Expression):
        return Expression._call(
            'dictionary_encode',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def divide(dividend, divisor, /, *, memory_pool=None):
    """Divide the arguments element-wise.

    Integer division by zero returns an error. However, integer overflow
    wraps around, and floating-point division by zero returns an infinite.
    Use function "divide_checked" if you want to get an error
    in all the aforementioned cases.

    Parameters
    ----------
    dividend : Array-like or scalar-like
        Argument to compute function.
    divisor : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `divide` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('divide')

    if isinstance(dividend, Expression):
        return Expression._call(
            'divide',
            [dividend, divisor]
        )

    return(
        func.call([dividend, divisor], memory_pool=memory_pool)
    )


def divide_checked(dividend, divisor, /, *, memory_pool=None):
    """Divide the arguments element-wise.

    An error is returned when trying to divide by zero, or when
    integer overflow is encountered.

    Parameters
    ----------
    dividend : Array-like or scalar-like
        Argument to compute function.
    divisor : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `divide_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('divide_checked')

    if isinstance(dividend, Expression):
        return Expression._call(
            'divide_checked',
            [dividend, divisor]
        )

    return(
        func.call([dividend, divisor], memory_pool=memory_pool)
    )


def drop_null(input, /, *, memory_pool=None):
    """Drop nulls from the input.

    The output is populated with values from the input (Array, ChunkedArray,
    RecordBatch, or Table) without the null values.
    For the RecordBatch and Table cases, `drop_null` drops the full row if
    there is any null.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `drop_null` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('drop_null')

    if isinstance(input, Expression):
        return Expression._call(
            'drop_null',
            [input]
        )

    return(
        func.call([input], memory_pool=memory_pool)
    )


def ends_with(strings, /, pattern=None, *, ignore_case=False, options=None,
              memory_pool=None):
    """Check if strings end with a literal pattern.

    For each string in `strings`, emit true iff it ends with a given pattern.
    The pattern must be given in MatchSubstringOptions.
    If ignore_case is set, only simple case folding is performed.

    Null inputs emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ends_with` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'ends_with',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('ends_with')

    if isinstance(strings, Expression):
        return Expression._call(
            'ends_with',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def equal(x, y, /, *, memory_pool=None):
    """Compare values for equality (x == y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `equal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('equal')

    if isinstance(x, Expression):
        return Expression._call(
            'equal',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def extract_regex(strings, /, pattern=None, *, options=None, memory_pool=None):
    """Extract substrings captured by a regex pattern.

    For each string in `strings`, match the regular expression and, if
    successful, emit a struct with field names and values coming from the
    regular expression's named capture groups. If the input is null or the
    regular expression fails matching, a null output value is emitted.

    Regular expression matching is done using the Google RE2 library.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Regular expression with named capture fields.
    options : pyarrow.compute.ExtractRegexOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `extract_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'extract_regex',
        pyarrow._compute.ExtractRegexOptions,
        options,
        (),
        pattern=pattern
    )
    func = pyarrow._compute.get_function('extract_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'extract_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def fill_null_backward(values, /, *, memory_pool=None):
    """Carry non-null values backward to fill null slots.

    Given an array, propagate next valid observation backward to previous
        valid
    or nothing if all next values are null.

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `fill_null_backward` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('fill_null_backward')

    if isinstance(values, Expression):
        return Expression._call(
            'fill_null_backward',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def fill_null_forward(values, /, *, memory_pool=None):
    """Carry non-null values forward to fill null slots.

    Given an array, propagate last valid observation forward to next valid
    or nothing if all previous values are null.

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `fill_null_forward` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('fill_null_forward')

    if isinstance(values, Expression):
        return Expression._call(
            'fill_null_forward',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def filter(input, selection_filter, /, null_selection_behavior='drop', *,
           options=None, memory_pool=None):
    """Filter with a boolean selection filter.

    The output is populated with values from the input at positions
    where the selection filter is non-zero.  Nulls in the selection filter
    are handled based on FilterOptions.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    selection_filter : Array-like or scalar-like
        Argument to compute function.
    null_selection_behavior : str, default "drop"
        How to handle nulls in the selection filter.
        Accepted values are "drop", "emit_null".
    options : pyarrow.compute.FilterOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `filter` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> arr = pa.array(["a", "b", "c", None, "e"])
    >>> mask = pa.array([True, False, None, False, True])
    >>> print(arr.filter(mask))
    [
      "a",
      "e"
    ]
    >>> print(arr.filter(mask, null_selection_behavior='emit_null'))
    [
      "a",
      null,
      "e"
    ]
    """

    _computed_options = _handle_options(
        'filter',
        pyarrow._compute.FilterOptions,
        options,
        (),
        null_selection_behavior=null_selection_behavior
    )
    func = pyarrow._compute.get_function('filter')

    if isinstance(input, Expression):
        return Expression._call(
            'filter',
            [input, selection_filter],
            _computed_options
        )

    return(
        func.call([input, selection_filter], _computed_options, memory_pool)
    )


def find_substring(strings, /, pattern=None, *, ignore_case=False,
                   options=None, memory_pool=None):
    """Find first occurrence of substring.

    For each string in `strings`, emit the index in bytes of the first
        occurrence
    of the given literal pattern, or -1 if not found.
    Null inputs emit null. The pattern must be given in
        MatchSubstringOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `find_substring` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'find_substring',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('find_substring')

    if isinstance(strings, Expression):
        return Expression._call(
            'find_substring',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def find_substring_regex(strings, /, pattern=None, *, ignore_case=False,
                         options=None,
                         memory_pool=None):
    """Find location of first match of regex pattern.

    For each string in `strings`, emit the index in bytes of the first
        occurrence
    of the given literal pattern, or -1 if not found.
    Null inputs emit null. The pattern must be given in
        MatchSubstringOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `find_substring_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'find_substring_regex',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('find_substring_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'find_substring_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def floor(x, /, *, memory_pool=None):
    """Round down to the nearest integer.

    Compute the largest integer value not greater in magnitude than `x`.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `floor` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('floor')

    if isinstance(x, Expression):
        return Expression._call(
            'floor',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def floor_temporal(timestamps, /, multiple=1, unit='day', *,
                   week_starts_monday=True,
                   ceil_is_strictly_greater=False,
                   calendar_based_origin=False, options=None,
                   memory_pool=None):
    """Round temporal values down to nearest multiple of specified time unit.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    timestamps : Array-like or scalar-like
        Argument to compute function.
    multiple : int, default 1
        Number of units to round to.
    unit : str, default "day"
        The unit in which `multiple` is expressed.
        Accepted values are "year", "quarter", "month", "week", "day",
        "hour", "minute", "second", "millisecond", "microsecond",
        "nanosecond".
    week_starts_monday : bool, default True
        If True, weeks start on Monday; if False, on Sunday.
    ceil_is_strictly_greater : bool, default False
        If True, ceil returns a rounded value that is strictly greater than
        the
        input. For example: ceiling 1970-01-01T00:00:00 to 3 hours would
        yield 1970-01-01T03:00:00 if set to True and 1970-01-01T00:00:00
        if set to False.
        This applies to the ceil_temporal function only.
    calendar_based_origin : bool, default False
        By default, the origin is 1970-01-01T00:00:00. By setting this to
        True,
        rounding origin will be beginning of one less precise calendar unit.
        E.g.: rounding to hours will use beginning of day as origin.

        By default time is rounded to a multiple of units since
        1970-01-01T00:00:00. By setting calendar_based_origin to true,
        time will be rounded to number of units since the last greater
        calendar unit.
        For example: rounding to multiple of days since the beginning of the
        month or to hours since the beginning of the day.
        Exceptions: week and quarter are not used as greater units,
        therefore days will be rounded to the beginning of the month not
        week. Greater unit of week is a year.
        Note that ceiling and rounding might change sorting order of an array
        near greater unit change. For example rounding YYYY-mm-dd 23:00:00 to
        5 hours will ceil and round to YYYY-mm-dd+1 01:00:00 and floor to
        YYYY-mm-dd 20:00:00. On the other hand YYYY-mm-dd+1 00:00:00 will
        ceil, round and floor to YYYY-mm-dd+1 00:00:00. This can break the
        order of an already ordered array.
    options : pyarrow.compute.RoundTemporalOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `floor_temporal` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'floor_temporal',
        pyarrow._compute.RoundTemporalOptions,
        options,
        (),
        multiple=multiple,
        unit=unit,
        week_starts_monday=week_starts_monday,
        ceil_is_strictly_greater=ceil_is_strictly_greater,
        calendar_based_origin=calendar_based_origin
    )
    func = pyarrow._compute.get_function('floor_temporal')

    if isinstance(timestamps, Expression):
        return Expression._call(
            'floor_temporal',
            [timestamps],
            _computed_options
        )

    return(
        func.call([timestamps], _computed_options, memory_pool)
    )


def greater(x, y, /, *, memory_pool=None):
    """Compare values for ordered inequality (x > y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `greater` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('greater')

    if isinstance(x, Expression):
        return Expression._call(
            'greater',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def greater_equal(x, y, /, *, memory_pool=None):
    """Compare values for ordered inequality (x >= y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `greater_equal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('greater_equal')

    if isinstance(x, Expression):
        return Expression._call(
            'greater_equal',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def hour(values, /, *, memory_pool=None):
    """Extract hour value.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `hour` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('hour')

    if isinstance(values, Expression):
        return Expression._call(
            'hour',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def hours_between(start, end, /, *, memory_pool=None):
    """Compute the number of hours between two timestamps.

    Returns the number of hour boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the hour.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `hours_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('hours_between')

    if isinstance(start, Expression):
        return Expression._call(
            'hours_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def if_else(cond, left, right, /, *, memory_pool=None):
    """Choose values based on a condition.

    `cond` must be a Boolean scalar/ array.
    `left` or `right` must be of the same type scalar/ array.
    `null` values in `cond` will be promoted to the output.

    Parameters
    ----------
    cond : Array-like or scalar-like
        Argument to compute function.
    left : Array-like or scalar-like
        Argument to compute function.
    right : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `if_else` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('if_else')

    if isinstance(cond, Expression):
        return Expression._call(
            'if_else',
            [cond, left, right]
        )

    return(
        func.call([cond, left, right], memory_pool=memory_pool)
    )


def index(array, /, value=None, *, options=None, memory_pool=None):
    """Find the index of the first occurrence of a given value.

    -1 is returned if the value is not found in the array.
    The search value is specified in IndexOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    value : Scalar
        The value to search for.
    options : pyarrow.compute.IndexOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `index` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([30, 50, None, 12, 30, 50, 60, 39])
    >>> pc.index(arr, 30)
    <pyarrow.Int64Scalar: 0>
    >>> pc.index(arr, None)
    <pyarrow.Int64Scalar: -1>
    >>> pc.index(arr, 30, start = 2)
    <pyarrow.Int64Scalar: 4>
    >>> pc.index(arr, 30, start = 2, end = 4)
    <pyarrow.Int64Scalar: -1>
    >>> pc.index(arr, 12, start = 4)
    <pyarrow.Int64Scalar: -1>
    >>> pc.index(arr, 30, start = 4)
    <pyarrow.Int64Scalar: 4>
    """

    _computed_options = _handle_options(
        'index',
        pyarrow._compute.IndexOptions,
        options,
        (),
        value=value
    )
    func = pyarrow._compute.get_function('index')

    if isinstance(array, Expression):
        return Expression._call(
            'index',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def index_in(values, /, value_set=None, *, skip_nulls=False, options=None,
             memory_pool=None):
    """Return index of each element in a set of values.

    For each element in `values`, return its index in a given set of
    values, or null if it is not found there.
    The set of values to look for must be given in SetLookupOptions.
    By default, nulls are matched against the value set, this can be
    changed in SetLookupOptions.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    value_set : Array
        Set of values to look for in the input.
    skip_nulls : bool, default False
        If False, nulls in the input are matched in the value_set just
        like regular values.
        If True, nulls in the input always fail matching.
    options : pyarrow.compute.SetLookupOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `index_in` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'index_in',
        pyarrow._compute.SetLookupOptions,
        options,
        (),
        value_set=value_set,
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('index_in')

    if isinstance(values, Expression):
        return Expression._call(
            'index_in',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def index_in_meta_binary(values, value_set, /, *, memory_pool=None):
    """Return index of each element in a set of values.

    For each element in `values`, return its index in the `value_set`,
    or null if it is not found there.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    value_set : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `index_in_meta_binary` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('index_in_meta_binary')

    if isinstance(values, Expression):
        return Expression._call(
            'index_in_meta_binary',
            [values, value_set]
        )

    return(
        func.call([values, value_set], memory_pool=memory_pool)
    )


def indices_nonzero(values, /, *, memory_pool=None):
    """Return the indices of the values in the array that are non-zero.

    For each input value, check if it's zero, false or null. Emit the index
    of the value in the array if it's none of the those.

    Note that indices_nonzero does not work with string arrays.

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `indices_nonzero` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> intarr = pa.array([-2, -1, 1, 0, None, 3, 5, 22, -9999, 9999])
    >>> okay_indices = pc.indices_nonzero(intarr)
    >>> okay_indices.tolist()
    [0, 1, 2, 5, 6, 7, 8, 9]

    >>> boolarr = pa.array([True, False, None, True, False])
    >>> okay_indices = pc.indices_nonzero(boolarr)
    >>> okay_indices.tolist()
    [0, 3]
    """

    func = pyarrow._compute.get_function('indices_nonzero')

    if isinstance(values, Expression):
        return Expression._call(
            'indices_nonzero',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def invert(values, /, *, memory_pool=None):
    """Invert boolean values.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `invert` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('invert')

    if isinstance(values, Expression):
        return Expression._call(
            'invert',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_dst(values, /, *, memory_pool=None):
    """Extracts if currently observing daylight savings.

    IsDaylightSavings returns true if a timestamp has a daylight saving
    offset in the given timezone.
    Null values emit null.
    An error is returned if the values do not have a defined timezone.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_dst` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_dst')

    if isinstance(values, Expression):
        return Expression._call(
            'is_dst',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_finite(values, /, *, memory_pool=None):
    """Return true if value is finite.

    For each input value, emit true iff the value is finite
    (i.e. neither NaN, inf, nor -inf).

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_finite` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_finite')

    if isinstance(values, Expression):
        return Expression._call(
            'is_finite',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_in(values, /, value_set=None, *, skip_nulls=False, options=None,
          memory_pool=None):
    """Find each element in a set of values.

    For each element in `values`, return true if it is found in a given
    set of values, false otherwise.
    The set of values to look for must be given in SetLookupOptions.
    By default, nulls are matched against the value set, this can be
    changed in SetLookupOptions.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    value_set : Array
        Set of values to look for in the input.
    skip_nulls : bool, default False
        If False, nulls in the input are matched in the value_set just
        like regular values.
        If True, nulls in the input always fail matching.
    options : pyarrow.compute.SetLookupOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_in` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'is_in',
        pyarrow._compute.SetLookupOptions,
        options,
        (),
        value_set=value_set,
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('is_in')

    if isinstance(values, Expression):
        return Expression._call(
            'is_in',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def is_in_meta_binary(values, value_set, /, *, memory_pool=None):
    """Find each element in a set of values.

    For each element in `values`, return true if it is found in `value_set`,
    false otherwise.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    value_set : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_in_meta_binary` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_in_meta_binary')

    if isinstance(values, Expression):
        return Expression._call(
            'is_in_meta_binary',
            [values, value_set]
        )

    return(
        func.call([values, value_set], memory_pool=memory_pool)
    )


def is_inf(values, /, *, memory_pool=None):
    """Return true if infinity.

    For each input value, emit true iff the value is infinite (inf or -inf).

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_inf` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_inf')

    if isinstance(values, Expression):
        return Expression._call(
            'is_inf',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_leap_year(values, /, *, memory_pool=None):
    """Extract if year is a leap year.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_leap_year` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_leap_year')

    if isinstance(values, Expression):
        return Expression._call(
            'is_leap_year',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_nan(values, /, *, memory_pool=None):
    """Return true if NaN.

    For each input value, emit true iff the value is NaN.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_nan` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_nan')

    if isinstance(values, Expression):
        return Expression._call(
            'is_nan',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def is_null(values, /, *, nan_is_null=False, options=None, memory_pool=None):
    """Return true if null (and optionally NaN).

    For each input value, emit true iff the value is null.
    True may also be emitted for NaN values by setting the `nan_is_null`
        flag.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    nan_is_null : bool, default False
        Whether floating-point NaN values are considered null.
    options : pyarrow.compute.NullOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_null` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'is_null',
        pyarrow._compute.NullOptions,
        options,
        (),
        nan_is_null=nan_is_null
    )
    func = pyarrow._compute.get_function('is_null')

    if isinstance(values, Expression):
        return Expression._call(
            'is_null',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def is_valid(values, /, *, memory_pool=None):
    """Return true if non-null.

    For each input value, emit true iff the value is valid (i.e. non-null).

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `is_valid` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('is_valid')

    if isinstance(values, Expression):
        return Expression._call(
            'is_valid',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def iso_calendar(values, /, *, memory_pool=None):
    """Extract (ISO year, ISO week, ISO day of week) struct.

    ISO week starts on Monday denoted by 1 and ends on Sunday denoted by 7.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `iso_calendar` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('iso_calendar')

    if isinstance(values, Expression):
        return Expression._call(
            'iso_calendar',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def iso_week(values, /, *, memory_pool=None):
    """Extract ISO week of year number.

    First ISO week has the majority (4 or more) of its days in January.
    ISO week starts on Monday. The week number starts with 1 and can run
    up to 53.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `iso_week` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('iso_week')

    if isinstance(values, Expression):
        return Expression._call(
            'iso_week',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def iso_year(values, /, *, memory_pool=None):
    """Extract ISO year number.

    First week of an ISO year has the majority (4 or more) of its days in
        January.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `iso_year` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('iso_year')

    if isinstance(values, Expression):
        return Expression._call(
            'iso_year',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def less(x, y, /, *, memory_pool=None):
    """Compare values for ordered inequality (x < y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `less` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('less')

    if isinstance(x, Expression):
        return Expression._call(
            'less',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def less_equal(x, y, /, *, memory_pool=None):
    """Compare values for ordered inequality (x <= y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `less_equal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('less_equal')

    if isinstance(x, Expression):
        return Expression._call(
            'less_equal',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def list_element(lists, index, /, *, memory_pool=None):
    """Compute elements using of nested list values using an index.

    `lists` must have a list-like type.
    For each value in each list of `lists`, the element at `index`
    is emitted. Null values emit a null in the output.

    Parameters
    ----------
    lists : Array-like or scalar-like
        Argument to compute function.
    index : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `list_element` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('list_element')

    if isinstance(lists, Expression):
        return Expression._call(
            'list_element',
            [lists, index]
        )

    return(
        func.call([lists, index], memory_pool=memory_pool)
    )


def list_flatten(lists, /, *, memory_pool=None):
    """Flatten list values.

    `lists` must have a list-like type.
    Return an array with the top list level flattened.
    Top-level null values in `lists` do not emit anything in the input.

    Parameters
    ----------
    lists : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `list_flatten` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('list_flatten')

    if isinstance(lists, Expression):
        return Expression._call(
            'list_flatten',
            [lists]
        )

    return(
        func.call([lists], memory_pool=memory_pool)
    )


def list_parent_indices(lists, /, *, memory_pool=None):
    """Compute parent indices of nested list values.

    `lists` must have a list-like type.
    For each value in each list of `lists`, the top-level list index
    is emitted.

    Parameters
    ----------
    lists : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `list_parent_indices` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('list_parent_indices')

    if isinstance(lists, Expression):
        return Expression._call(
            'list_parent_indices',
            [lists]
        )

    return(
        func.call([lists], memory_pool=memory_pool)
    )


def list_value_length(lists, /, *, memory_pool=None):
    """Compute list lengths.

    `lists` must have a list-like type.
    For each non-null value in `lists`, its length is emitted.
    Null values emit a null in the output.

    Parameters
    ----------
    lists : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `list_value_length` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('list_value_length')

    if isinstance(lists, Expression):
        return Expression._call(
            'list_value_length',
            [lists]
        )

    return(
        func.call([lists], memory_pool=memory_pool)
    )


def ln(x, /, *, memory_pool=None):
    """Compute natural logarithm.

    Non-positive values return -inf or NaN. Null values return null.
    Use function "ln_checked" if you want non-positive values to raise an
        error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ln` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ln')

    if isinstance(x, Expression):
        return Expression._call(
            'ln',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def ln_checked(x, /, *, memory_pool=None):
    """Compute natural logarithm.

    Non-positive values raise an error. Null values return null.
    Use function "ln" if you want non-positive values to return -inf or NaN.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `ln_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('ln_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'ln_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log10(x, /, *, memory_pool=None):
    """Compute base 10 logarithm.

    Non-positive values return -inf or NaN. Null values return null.
    Use function "log10_checked" if you want non-positive values
    to raise an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log10` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log10')

    if isinstance(x, Expression):
        return Expression._call(
            'log10',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log10_checked(x, /, *, memory_pool=None):
    """Compute base 10 logarithm.

    Non-positive values raise an error. Null values return null.
    Use function "log10" if you want non-positive values
    to return -inf or NaN.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log10_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log10_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'log10_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log1p(x, /, *, memory_pool=None):
    """Compute natural log of (1+x).

    Values <= -1 return -inf or NaN. Null values return null.
    This function may be more precise than log(1 + x) for x close to zero.
    Use function "log1p_checked" if you want invalid values to raise an
        error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log1p` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log1p')

    if isinstance(x, Expression):
        return Expression._call(
            'log1p',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log1p_checked(x, /, *, memory_pool=None):
    """Compute natural log of (1+x).

    Values <= -1 return -inf or NaN. Null values return null.
    This function may be more precise than log(1 + x) for x close to zero.
    Use function "log1p" if you want invalid values to return -inf or NaN.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log1p_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log1p_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'log1p_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log2(x, /, *, memory_pool=None):
    """Compute base 2 logarithm.

    Non-positive values return -inf or NaN. Null values return null.
    Use function "log2_checked" if you want non-positive values
    to raise an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log2` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log2')

    if isinstance(x, Expression):
        return Expression._call(
            'log2',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def log2_checked(x, /, *, memory_pool=None):
    """Compute base 2 logarithm.

    Non-positive values raise an error. Null values return null.
    Use function "log2" if you want non-positive values
    to return -inf or NaN.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `log2_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('log2_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'log2_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def logb(x, b, /, *, memory_pool=None):
    """Compute base `b` logarithm.

    Values <= 0 return -inf or NaN. Null values return null.
    Use function "logb_checked" if you want non-positive values to raise an
        error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    b : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `logb` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('logb')

    if isinstance(x, Expression):
        return Expression._call(
            'logb',
            [x, b]
        )

    return(
        func.call([x, b], memory_pool=memory_pool)
    )


def logb_checked(x, b, /, *, memory_pool=None):
    """Compute base `b` logarithm.

    Values <= 0 return -inf or NaN. Null values return null.
    Use function "logb" if you want non-positive values to return -inf or
        NaN.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    b : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `logb_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('logb_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'logb_checked',
            [x, b]
        )

    return(
        func.call([x, b], memory_pool=memory_pool)
    )


def make_struct(*args, field_names=(), field_nullability=None,
                field_metadata=None, options=None,
                memory_pool=None):
    """Wrap Arrays into a StructArray.

    Names of the StructArray's fields are
    specified through MakeStructOptions.

    Parameters
    ----------
    *args : Array-like or scalar-like
        Argument to compute function.
    field_names : sequence of str
        Names of the struct fields to create.
    field_nullability : sequence of bool, optional
        Nullability information for each struct field.
        If omitted, all fields are nullable.
    field_metadata : sequence of KeyValueMetadata, optional
        Metadata for each struct field.
    options : pyarrow.compute.MakeStructOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `make_struct` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'make_struct',
        pyarrow._compute.MakeStructOptions,
        options,
        (),
        field_names=field_names,
        field_nullability=field_nullability,
        field_metadata=field_metadata
    )
    func = pyarrow._compute.get_function('make_struct')
    return(
        func.call([*args], _computed_options, memory_pool)
    )


def map_lookup(container, /, query_key=None, occurrence=None, *, options=None,
               memory_pool=None):
    """Find the items corresponding to a given key in a Map.

    For a given query key (passed via MapLookupOptions), extract
    either the FIRST, LAST or ALL items from a Map that have
    matching keys.

    Parameters
    ----------
    container : Array-like or scalar-like
        Argument to compute function.
    query_key : Scalar
        The key to search for.
    occurrence : str
        The occurrence(s) to return from the Map
        Accepted values are "first", "last", or "all".
    options : pyarrow.compute.MapLookupOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `map_lookup` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'map_lookup',
        pyarrow._compute.MapLookupOptions,
        options,
        (),
        query_key=query_key,
        occurrence=occurrence
    )
    func = pyarrow._compute.get_function('map_lookup')

    if isinstance(container, Expression):
        return Expression._call(
            'map_lookup',
            [container],
            _computed_options
        )

    return(
        func.call([container], _computed_options, memory_pool)
    )


def match_like(strings, /, pattern=None, *, ignore_case=False, options=None,
               memory_pool=None):
    """Match strings against SQL-style LIKE pattern.

    For each string in `strings`, emit true iff it matches a given pattern
    at any position. '%' will match any number of characters, '_' will
    match exactly one character, and any other character matches itself.
    To match a literal '%', '_', or '\', precede the character with a
        backslash.
    Null inputs emit null.  The pattern must be given in
        MatchSubstringOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `match_like` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'match_like',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('match_like')

    if isinstance(strings, Expression):
        return Expression._call(
            'match_like',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def match_substring(strings, /, pattern=None, *, ignore_case=False,
                    options=None, memory_pool=None):
    """Match strings against literal pattern.

    For each string in `strings`, emit true iff it contains a given pattern.
    Null inputs emit null.
    The pattern must be given in MatchSubstringOptions.
    If ignore_case is set, only simple case folding is performed.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `match_substring` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'match_substring',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('match_substring')

    if isinstance(strings, Expression):
        return Expression._call(
            'match_substring',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def match_substring_regex(strings, /, pattern=None, *, ignore_case=False,
                          options=None,
                          memory_pool=None):
    """Match strings against regex pattern.

    For each string in `strings`, emit true iff it matches a given pattern
    at any position. The pattern must be given in MatchSubstringOptions.
    If ignore_case is set, only simple case folding is performed.

    Null inputs emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `match_substring_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'match_substring_regex',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('match_substring_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'match_substring_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def max(array, /, *, skip_nulls=True, min_count=1, options=None,
        memory_pool=None):
    """Compute the minimum or maximum values of a numeric array.

    Null values are ignored by default.
    This can be changed through ScalarAggregateOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `max` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'max',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('max')

    if isinstance(array, Expression):
        return Expression._call(
            'max',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def max_element_wise(*args, skip_nulls=True, options=None, memory_pool=None):
    """Find the element-wise maximum value.

    Nulls are ignored (by default) or propagated.
    NaN is preferred over null, but not over any valid value.

    Parameters
    ----------
    *args : Array-like or scalar-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    options : pyarrow.compute.ElementWiseAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `max_element_wise` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'max_element_wise',
        pyarrow._compute.ElementWiseAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('max_element_wise')
    return(
        func.call([*args], _computed_options, memory_pool)
    )


def mean(array, /, *, skip_nulls=True, min_count=1, options=None,
         memory_pool=None):
    """Compute the mean of a numeric array.

    Null values are ignored by default. Minimum count of non-null
    values can be set and null is returned if too few are present.
    This can be changed through ScalarAggregateOptions.
    The result is a double for integer and floating point arguments,
    and a decimal with the same bit-width/precision/scale for decimal
        arguments.
    For integers and floats, NaN is returned if min_count = 0 and
    there are no values. For decimals, null is returned instead.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `mean` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'mean',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('mean')

    if isinstance(array, Expression):
        return Expression._call(
            'mean',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def microsecond(values, /, *, memory_pool=None):
    """Extract microsecond values.

    Millisecond returns number of microseconds since the last full
        millisecond.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `microsecond` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('microsecond')

    if isinstance(values, Expression):
        return Expression._call(
            'microsecond',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def microseconds_between(start, end, /, *, memory_pool=None):
    """Compute the number of microseconds between two timestamps.

    Returns the number of microsecond boundaries crossed from `start` to
        `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the microsecond.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `microseconds_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('microseconds_between')

    if isinstance(start, Expression):
        return Expression._call(
            'microseconds_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def millisecond(values, /, *, memory_pool=None):
    """Extract millisecond values.

    Millisecond returns number of milliseconds since the last full second.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `millisecond` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('millisecond')

    if isinstance(values, Expression):
        return Expression._call(
            'millisecond',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def milliseconds_between(start, end, /, *, memory_pool=None):
    """Compute the number of millisecond boundaries between two timestamps.

    Returns the number of millisecond boundaries crossed from `start` to
        `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the millisecond.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `milliseconds_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('milliseconds_between')

    if isinstance(start, Expression):
        return Expression._call(
            'milliseconds_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def min(array, /, *, skip_nulls=True, min_count=1, options=None,
        memory_pool=None):
    """Compute the minimum or maximum values of a numeric array.

    Null values are ignored by default.
    This can be changed through ScalarAggregateOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `min` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'min',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('min')

    if isinstance(array, Expression):
        return Expression._call(
            'min',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def min_element_wise(*args, skip_nulls=True, options=None, memory_pool=None):
    """Find the element-wise minimum value.

    Nulls are ignored (by default) or propagated.
    NaN is preferred over null, but not over any valid value.

    Parameters
    ----------
    *args : Array-like or scalar-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    options : pyarrow.compute.ElementWiseAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `min_element_wise` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'min_element_wise',
        pyarrow._compute.ElementWiseAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls
    )
    func = pyarrow._compute.get_function('min_element_wise')
    return(
        func.call([*args], _computed_options, memory_pool)
    )


def min_max(array, /, *, skip_nulls=True, min_count=1, options=None,
            memory_pool=None):
    """Compute the minimum and maximum values of a numeric array.

    Null values are ignored by default.
    This can be changed through ScalarAggregateOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `min_max` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'min_max',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('min_max')

    if isinstance(array, Expression):
        return Expression._call(
            'min_max',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def minute(values, /, *, memory_pool=None):
    """Extract minute values.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `minute` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('minute')

    if isinstance(values, Expression):
        return Expression._call(
            'minute',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def minutes_between(start, end, /, *, memory_pool=None):
    """Compute the number of minute boundaries between two timestamps.

    Returns the number of minute boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the minute.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `minutes_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('minutes_between')

    if isinstance(start, Expression):
        return Expression._call(
            'minutes_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def mode(array, /, n=1, *, skip_nulls=True, min_count=0, options=None,
         memory_pool=None):
    """Compute the modal (most common) values of a numeric array.

    Compute the n most common values and their respective occurrence counts.
    The output has type `struct<mode: T, count: int64>`, where T is the
    input type.
    The results are ordered by descending `count` first, and ascending `mode`
    when breaking ties.
    Nulls are ignored.  If there are no non-null values in the array,
    an empty array is returned.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    n : int, default 1
        Number of distinct most-common values to return.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 0
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ModeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `mode` compute function in the Arrow C++ library.

    Examples
    --------
    >>> import pyarrow as pa
    >>> import pyarrow.compute as pc
    >>> arr = pa.array([1, 1, 2, 2, 3, 2, 2, 2])
    >>> modes = pc.mode(arr, 2)
    >>> modes[0]
    <pyarrow.StructScalar: [('mode', 2), ('count', 5)]>
    >>> modes[1]
    <pyarrow.StructScalar: [('mode', 1), ('count', 2)]>
    """

    _computed_options = _handle_options(
        'mode',
        pyarrow._compute.ModeOptions,
        options,
        (),
        n=n,
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('mode')

    if isinstance(array, Expression):
        return Expression._call(
            'mode',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def month(values, /, *, memory_pool=None):
    """Extract month number.

    Month is encoded as January=1, December=12.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `month` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('month')

    if isinstance(values, Expression):
        return Expression._call(
            'month',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def month_day_nano_interval_between(start, end, /, *, memory_pool=None):
    """Compute the number of months, days and nanoseconds between two
        timestamps.

    Returns the number of months, days, and nanoseconds from `start` to
        `end`.
    That is, first the difference in months is computed as if both timestamps
    were truncated to the months, then the difference between the days
    is computed, and finally the difference between the times of the two
    timestamps is computed as if both times were truncated to the nanosecond.
    Null values return null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `month_day_nano_interval_between` compute function in the Arrow C++
        library.
    """

    func = pyarrow._compute.get_function('month_day_nano_interval_between')

    if isinstance(start, Expression):
        return Expression._call(
            'month_day_nano_interval_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def month_interval_between(start, end, /, *, memory_pool=None):
    """Compute the number of months between two timestamps.

    Returns the number of month boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the month.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `month_interval_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('month_interval_between')

    if isinstance(start, Expression):
        return Expression._call(
            'month_interval_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def multiply(x, y, /, *, memory_pool=None):
    """Multiply the arguments element-wise.

    Results will wrap around on integer overflow.
    Use function "multiply_checked" if you want overflow
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `multiply` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('multiply')

    if isinstance(x, Expression):
        return Expression._call(
            'multiply',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def multiply_checked(x, y, /, *, memory_pool=None):
    """Multiply the arguments element-wise.

    This function returns an error on overflow.  For a variant that
    doesn't fail on overflow, use function "multiply".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `multiply_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('multiply_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'multiply_checked',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def nanosecond(values, /, *, memory_pool=None):
    """Extract nanosecond values.

    Nanosecond returns number of nanoseconds since the last full microsecond.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `nanosecond` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('nanosecond')

    if isinstance(values, Expression):
        return Expression._call(
            'nanosecond',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def nanoseconds_between(start, end, /, *, memory_pool=None):
    """Compute the number of nanoseconds between two timestamps.

    Returns the number of nanosecond boundaries crossed from `start` to
        `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the nanosecond.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `nanoseconds_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('nanoseconds_between')

    if isinstance(start, Expression):
        return Expression._call(
            'nanoseconds_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def negate(x, /, *, memory_pool=None):
    """Negate the argument element-wise.

    Results will wrap around on integer overflow.
    Use function "negate_checked" if you want overflow
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `negate` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('negate')

    if isinstance(x, Expression):
        return Expression._call(
            'negate',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def negate_checked(x, /, *, memory_pool=None):
    """Negate the arguments element-wise.

    This function returns an error on overflow.  For a variant that
    doesn't fail on overflow, use function "negate".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `negate_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('negate_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'negate_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def not_equal(x, y, /, *, memory_pool=None):
    """Compare values for inequality (x != y).

    A null on either side emits a null comparison result.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `not_equal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('not_equal')

    if isinstance(x, Expression):
        return Expression._call(
            'not_equal',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def or_(x, y, /, *, memory_pool=None):
    """Logical 'or' boolean values.

    When a null is encountered in either input, a null is output.
    For a different null behavior, see function "or_kleene".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `or` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('or')

    if isinstance(x, Expression):
        return Expression._call(
            'or_',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def or_kleene(x, y, /, *, memory_pool=None):
    """Logical 'or' boolean values (Kleene logic).

    This function behaves as follows with nulls:

    - true or null = true
    - null and true = true
    - false and null = null
    - null and false = null
    - null and null = null

    In other words, in this context a null value really means "unknown",
    and an unknown value 'or' true is always true.
    For a different null behavior, see function "and".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `or_kleene` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('or_kleene')

    if isinstance(x, Expression):
        return Expression._call(
            'or_kleene',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def partition_nth_indices(array, /, pivot=None, *, null_placement='at_end',
                          options=None,
                          memory_pool=None):
    """Return the indices that would partition an array around a pivot.

    This functions computes an array of indices that define a non-stable
    partial sort of the input array.

    The output is such that the `N`'th index points to the `N`'th element
    of the input in sorted order, and all indices before the `N`'th point
    to elements in the input less or equal to elements at or after the
        `N`'th.

    By default, null values are considered greater than any other value
    and are therefore partitioned towards the end of the array.
    For floating-point types, NaNs are considered greater than any
    other non-null value, but smaller than null values.

    The pivot index `N` must be given in PartitionNthOptions.
    The handling of nulls and NaNs can also be changed in
        PartitionNthOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    pivot : int
        Index into the equivalent sorted array of the pivot element.
    null_placement : str, default "at_end"
        Where nulls in the input should be partitioned.
        Accepted values are "at_start", "at_end".
    options : pyarrow.compute.PartitionNthOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `partition_nth_indices` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'partition_nth_indices',
        pyarrow._compute.PartitionNthOptions,
        options,
        (),
        pivot=pivot,
        null_placement=null_placement
    )
    func = pyarrow._compute.get_function('partition_nth_indices')

    if isinstance(array, Expression):
        return Expression._call(
            'partition_nth_indices',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def power(base, exponent, /, *, memory_pool=None):
    """Raise arguments to power element-wise.

    Integer to negative integer power returns an error. However, integer
        overflow
    wraps around. If either base or exponent is null the result will be null.

    Parameters
    ----------
    base : Array-like or scalar-like
        Argument to compute function.
    exponent : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `power` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('power')

    if isinstance(base, Expression):
        return Expression._call(
            'power',
            [base, exponent]
        )

    return(
        func.call([base, exponent], memory_pool=memory_pool)
    )


def power_checked(base, exponent, /, *, memory_pool=None):
    """Raise arguments to power element-wise.

    An error is returned when integer to negative integer power is
        encountered,
    or integer overflow is encountered.

    Parameters
    ----------
    base : Array-like or scalar-like
        Argument to compute function.
    exponent : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `power_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('power_checked')

    if isinstance(base, Expression):
        return Expression._call(
            'power_checked',
            [base, exponent]
        )

    return(
        func.call([base, exponent], memory_pool=memory_pool)
    )


def product(array, /, *, skip_nulls=True, min_count=1, options=None,
            memory_pool=None):
    """Compute the product of values in a numeric array.

    Null values are ignored by default. Minimum count of non-null
    values can be set and null is returned if too few are present.
    This can be changed through ScalarAggregateOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `product` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'product',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('product')

    if isinstance(array, Expression):
        return Expression._call(
            'product',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def quantile(array, /, q=0.5, *, interpolation='linear', skip_nulls=True,
             min_count=0, options=None, memory_pool=None):
    """Compute an array of quantiles of a numeric array or chunked array.

    By default, 0.5 quantile (median) is returned.
    If quantile lies between two data points, an interpolated value is
    returned based on selected interpolation method.
    Nulls and NaNs are ignored.
    An array of nulls is returned if there is no valid data point.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    q : double or sequence of double, default 0.5
        Quantiles to compute. All values must be in [0, 1].
    interpolation : str, default "linear"
        How to break ties between competing data points for a given quantile.
        Accepted values are:

        - "linear": compute an interpolation
        - "lower": always use the smallest of the two data points
        - "higher": always use the largest of the two data points
        - "nearest": select the data point that is closest to the quantile
        - "midpoint": compute the (unweighted) mean of the two data points
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 0
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.QuantileOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `quantile` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'quantile',
        pyarrow._compute.QuantileOptions,
        options,
        (),
        q=q,
        interpolation=interpolation,
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('quantile')

    if isinstance(array, Expression):
        return Expression._call(
            'quantile',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def quarter(values, /, *, memory_pool=None):
    """Extract quarter of year number.

    First quarter maps to 1 and forth quarter maps to 4.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `quarter` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('quarter')

    if isinstance(values, Expression):
        return Expression._call(
            'quarter',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def quarters_between(start, end, /, *, memory_pool=None):
    """Compute the number of quarters between two timestamps.

    Returns the number of quarter start boundaries crossed from `start` to
        `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the quarter.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `quarters_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('quarters_between')

    if isinstance(start, Expression):
        return Expression._call(
            'quarters_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def random(*, initializer='system', options=None, memory_pool=None):
    """Generate numbers in the range [0, 1).

    Generated values are uniformly-distributed, double-precision in range [0,
        1).
    Algorithm and seed can be changed via RandomOptions.

    Parameters
    ----------
    initializer : int or str
        How to initialize the underlying random generator.
        If an integer is given, it is used as a seed.
        If "system" is given, the random generator is initialized with
        a system-specific source of (hopefully true) randomness.
        Other values are invalid.
    options : pyarrow.compute.RandomOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `random` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'random',
        pyarrow._compute.RandomOptions,
        options,
        (),
        initializer=initializer
    )
    func = pyarrow._compute.get_function('random')
    return(
        func.call([], _computed_options, memory_pool)
    )


def rank(input, /, sort_keys='ascending', *, null_placement='at_end',
         tiebreaker='first', options=None, memory_pool=None):
    """Compute numerical ranks of an array (1-based).

    This function computes a rank of the input array.
    By default, null values are considered greater than any other value and
    are therefore sorted at the end of the input. For floating-point types,
    NaNs are considered greater than any other non-null value, but smaller
    than null values. The default tiebreaker is to assign ranks in order of
    when ties appear in the input.

    The handling of nulls, NaNs and tiebreakers can be changed in
        RankOptions.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    sort_keys : sequence of (name, order) tuples or str, default "ascending"
        Names of field/column keys to sort the input on,
        along with the order each field/column is sorted in.
        Accepted values for `order` are "ascending", "descending".
        Alternatively, one can simply pass "ascending" or "descending" as a
        string
        if the input is array-like.
    null_placement : str, default "at_end"
        Where nulls in input should be sorted.
        Accepted values are "at_start", "at_end".
    tiebreaker : str, default "first"
        Configure how ties between equal values are handled.
        Accepted values are:

        - "min": Ties get the smallest possible rank in sorted order.
        - "max": Ties get the largest possible rank in sorted order.
        - "first": Ranks are assigned in order of when ties appear in the
                   input. This ensures the ranks are a stable permutation
                   of the input.
        - "dense": The ranks span a dense [1, M] interval where M is the
                   number of distinct values in the input.
    options : pyarrow.compute.RankOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `rank` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'rank',
        pyarrow._compute.RankOptions,
        options,
        (),
        sort_keys=sort_keys,
        null_placement=null_placement,
        tiebreaker=tiebreaker
    )
    func = pyarrow._compute.get_function('rank')

    if isinstance(input, Expression):
        return Expression._call(
            'rank',
            [input],
            _computed_options
        )

    return(
        func.call([input], _computed_options, memory_pool)
    )


def replace_substring(strings, /, pattern=None, replacement=None, *,
                      max_replacements=None, options=None,
                      memory_pool=None):
    """Replace matching non-overlapping substrings with replacement.

    For each string in `strings`, replace non-overlapping substrings that
        match
    the given literal `pattern` with the given `replacement`.
    If `max_replacements` is given and not equal to -1, it limits the
    maximum amount replacements per input, counted from the left.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    replacement : str
        What to replace the pattern with.
    max_replacements : int or None, default None
        The maximum number of strings to replace in each
        input value (unlimited if None).
    options : pyarrow.compute.ReplaceSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `replace_substring` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'replace_substring',
        pyarrow._compute.ReplaceSubstringOptions,
        options,
        (),
        pattern=pattern,
        replacement=replacement,
        max_replacements=max_replacements
    )
    func = pyarrow._compute.get_function('replace_substring')

    if isinstance(strings, Expression):
        return Expression._call(
            'replace_substring',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def replace_substring_regex(strings, /, pattern=None, replacement=None, *,
                            max_replacements=None,
                            options=None,
                            memory_pool=None):
    """Replace matching non-overlapping substrings with replacement.

    For each string in `strings`, replace non-overlapping substrings that
        match
    the given regular expression `pattern` with the given `replacement`.
    If `max_replacements` is given and not equal to -1, it limits the
    maximum amount replacements per input, counted from the left.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    replacement : str
        What to replace the pattern with.
    max_replacements : int or None, default None
        The maximum number of strings to replace in each
        input value (unlimited if None).
    options : pyarrow.compute.ReplaceSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `replace_substring_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'replace_substring_regex',
        pyarrow._compute.ReplaceSubstringOptions,
        options,
        (),
        pattern=pattern,
        replacement=replacement,
        max_replacements=max_replacements
    )
    func = pyarrow._compute.get_function('replace_substring_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'replace_substring_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def replace_with_mask(values, mask, replacements, /, *, memory_pool=None):
    """Replace items selected with a mask.

    Given an array and a boolean mask (either scalar or of equal length),
    along with replacement values (either scalar or array),
    each element of the array for which the corresponding mask element is
    true will be replaced by the next value from the replacements,
    or with null if the mask is null.
    Hence, for replacement arrays, len(replacements) == sum(mask == true).

    Parameters
    ----------
    values : Array-like
        Argument to compute function.
    mask : Array-like
        Argument to compute function.
    replacements : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `replace_with_mask` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('replace_with_mask')

    if isinstance(values, Expression):
        return Expression._call(
            'replace_with_mask',
            [values, mask, replacements]
        )

    return(
        func.call([values, mask, replacements], memory_pool=memory_pool)
    )


def round(x, /, ndigits=0, round_mode='half_to_even', *, options=None,
          memory_pool=None):
    """Round to a given precision.

    Options are used to control the number of digits and rounding mode.
    Default behavior is to round to the nearest integer and
    use half-to-even rule to break ties.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    ndigits : int, default 0
        Number of fractional digits to round to.
    round_mode : str, default "half_to_even"
        Rounding and tie-breaking mode.
        Accepted values are "down", "up", "towards_zero", "towards_infinity",
        "half_down", "half_up", "half_towards_zero", "half_towards_infinity",
        "half_to_even", "half_to_odd".
    options : pyarrow.compute.RoundOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `round` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'round',
        pyarrow._compute.RoundOptions,
        options,
        (),
        ndigits=ndigits,
        round_mode=round_mode
    )
    func = pyarrow._compute.get_function('round')

    if isinstance(x, Expression):
        return Expression._call(
            'round',
            [x],
            _computed_options
        )

    return(
        func.call([x], _computed_options, memory_pool)
    )


def round_temporal(timestamps, /, multiple=1, unit='day', *,
                   week_starts_monday=True,
                   ceil_is_strictly_greater=False,
                   calendar_based_origin=False, options=None,
                   memory_pool=None):
    """Round temporal values to the nearest multiple of specified time unit.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    timestamps : Array-like or scalar-like
        Argument to compute function.
    multiple : int, default 1
        Number of units to round to.
    unit : str, default "day"
        The unit in which `multiple` is expressed.
        Accepted values are "year", "quarter", "month", "week", "day",
        "hour", "minute", "second", "millisecond", "microsecond",
        "nanosecond".
    week_starts_monday : bool, default True
        If True, weeks start on Monday; if False, on Sunday.
    ceil_is_strictly_greater : bool, default False
        If True, ceil returns a rounded value that is strictly greater than
        the
        input. For example: ceiling 1970-01-01T00:00:00 to 3 hours would
        yield 1970-01-01T03:00:00 if set to True and 1970-01-01T00:00:00
        if set to False.
        This applies to the ceil_temporal function only.
    calendar_based_origin : bool, default False
        By default, the origin is 1970-01-01T00:00:00. By setting this to
        True,
        rounding origin will be beginning of one less precise calendar unit.
        E.g.: rounding to hours will use beginning of day as origin.

        By default time is rounded to a multiple of units since
        1970-01-01T00:00:00. By setting calendar_based_origin to true,
        time will be rounded to number of units since the last greater
        calendar unit.
        For example: rounding to multiple of days since the beginning of the
        month or to hours since the beginning of the day.
        Exceptions: week and quarter are not used as greater units,
        therefore days will be rounded to the beginning of the month not
        week. Greater unit of week is a year.
        Note that ceiling and rounding might change sorting order of an array
        near greater unit change. For example rounding YYYY-mm-dd 23:00:00 to
        5 hours will ceil and round to YYYY-mm-dd+1 01:00:00 and floor to
        YYYY-mm-dd 20:00:00. On the other hand YYYY-mm-dd+1 00:00:00 will
        ceil, round and floor to YYYY-mm-dd+1 00:00:00. This can break the
        order of an already ordered array.
    options : pyarrow.compute.RoundTemporalOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `round_temporal` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'round_temporal',
        pyarrow._compute.RoundTemporalOptions,
        options,
        (),
        multiple=multiple,
        unit=unit,
        week_starts_monday=week_starts_monday,
        ceil_is_strictly_greater=ceil_is_strictly_greater,
        calendar_based_origin=calendar_based_origin
    )
    func = pyarrow._compute.get_function('round_temporal')

    if isinstance(timestamps, Expression):
        return Expression._call(
            'round_temporal',
            [timestamps],
            _computed_options
        )

    return(
        func.call([timestamps], _computed_options, memory_pool)
    )


def round_to_multiple(x, /, multiple=1.0, round_mode='half_to_even', *,
                      options=None, memory_pool=None):
    """Round to a given multiple.

    Options are used to control the rounding multiple and rounding mode.
    Default behavior is to round to the nearest integer and
    use half-to-even rule to break ties.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    multiple : numeric scalar, default 1.0
        Multiple to round to. Should be a scalar of a type compatible
        with the argument to be rounded.
    round_mode : str, default "half_to_even"
        Rounding and tie-breaking mode.
        Accepted values are "down", "up", "towards_zero", "towards_infinity",
        "half_down", "half_up", "half_towards_zero", "half_towards_infinity",
        "half_to_even", "half_to_odd".
    options : pyarrow.compute.RoundToMultipleOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `round_to_multiple` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'round_to_multiple',
        pyarrow._compute.RoundToMultipleOptions,
        options,
        (),
        multiple=multiple,
        round_mode=round_mode
    )
    func = pyarrow._compute.get_function('round_to_multiple')

    if isinstance(x, Expression):
        return Expression._call(
            'round_to_multiple',
            [x],
            _computed_options
        )

    return(
        func.call([x], _computed_options, memory_pool)
    )


def second(values, /, *, memory_pool=None):
    """Extract second values.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `second` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('second')

    if isinstance(values, Expression):
        return Expression._call(
            'second',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def seconds_between(start, end, /, *, memory_pool=None):
    """Compute the number of seconds between two timestamps.

    Returns the number of second boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the second.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `seconds_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('seconds_between')

    if isinstance(start, Expression):
        return Expression._call(
            'seconds_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )


def select_k_unstable(input, /, k=None, sort_keys=None, *, options=None,
                      memory_pool=None):
    """Select the indices of the first `k` ordered elements from the input.

    This function selects an array of indices of the first `k` ordered
        elements
    from the `input` array, record batch or table specified in the column
        keys
    (`options.sort_keys`). Output is not guaranteed to be stable.
    Null values are considered greater than any other value and are
    therefore ordered at the end. For floating-point types, NaNs are
        considered
    greater than any other non-null value, but smaller than null values.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    k : int
        Number of leading values to select in sorted order
        (i.e. the largest values if sort order is "descending",
        the smallest otherwise).
    sort_keys : sequence of (name, order) tuples
        Names of field/column keys to sort the input on,
        along with the order each field/column is sorted in.
        Accepted values for `order` are "ascending", "descending".
    options : pyarrow.compute.SelectKOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `select_k_unstable` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'select_k_unstable',
        pyarrow._compute.SelectKOptions,
        options,
        (),
        k=k,
        sort_keys=sort_keys
    )
    func = pyarrow._compute.get_function('select_k_unstable')

    if isinstance(input, Expression):
        return Expression._call(
            'select_k_unstable',
            [input],
            _computed_options
        )

    return(
        func.call([input], _computed_options, memory_pool)
    )


def shift_left(x, y, /, *, memory_pool=None):
    """Left shift `x` by `y`.

    The shift operates as if on the two's complement representation of the
        number.
    In other words, this is equivalent to multiplying `x` by 2 to the power
        `y`,
    even if overflow occurs.
    `x` is returned if `y` (the amount to shift by) is (1) negative or
    (2) greater than or equal to the precision of `x`.
    Use function "shift_left_checked" if you want an invalid shift amount
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `shift_left` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('shift_left')

    if isinstance(x, Expression):
        return Expression._call(
            'shift_left',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def shift_left_checked(x, y, /, *, memory_pool=None):
    """Left shift `x` by `y`.

    The shift operates as if on the two's complement representation of the
        number.
    In other words, this is equivalent to multiplying `x` by 2 to the power
        `y`,
    even if overflow occurs.
    An error is raised if `y` (the amount to shift by) is (1) negative or
    (2) greater than or equal to the precision of `x`.
    See "shift_left" for a variant that doesn't fail for an invalid shift
        amount.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `shift_left_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('shift_left_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'shift_left_checked',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def shift_right(x, y, /, *, memory_pool=None):
    """Right shift `x` by `y`.

    This is equivalent to dividing `x` by 2 to the power `y`.
    `x` is returned if `y` (the amount to shift by) is: (1) negative or
    (2) greater than or equal to the precision of `x`.
    Use function "shift_right_checked" if you want an invalid shift amount
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `shift_right` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('shift_right')

    if isinstance(x, Expression):
        return Expression._call(
            'shift_right',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def shift_right_checked(x, y, /, *, memory_pool=None):
    """Right shift `x` by `y`.

    This is equivalent to dividing `x` by 2 to the power `y`.
    An error is raised if `y` (the amount to shift by) is (1) negative or
    (2) greater than or equal to the precision of `x`.
    See "shift_right" for a variant that doesn't fail for an invalid shift
        amount

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `shift_right_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('shift_right_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'shift_right_checked',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def sign(x, /, *, memory_pool=None):
    """Get the signedness of the arguments element-wise.

    Output is any of (-1,1) for nonzero inputs and 0 for zero input.
    NaN values return NaN.  Integral values return signedness as Int8 and
    floating-point values return it with the same type as the input values.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sign` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('sign')

    if isinstance(x, Expression):
        return Expression._call(
            'sign',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def sin(x, /, *, memory_pool=None):
    """Compute the sine.

    NaN is returned for invalid input values;
    to raise an error instead, see "sin_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sin` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('sin')

    if isinstance(x, Expression):
        return Expression._call(
            'sin',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def sin_checked(x, /, *, memory_pool=None):
    """Compute the sine.

    Invalid input values raise an error;
    to return NaN instead, see "sin".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sin_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('sin_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'sin_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def sort_indices(input, /, sort_keys=(), *, null_placement='at_end',
                 options=None, memory_pool=None):
    """Return the indices that would sort an array, record batch or table.

    This function computes an array of indices that define a stable sort
    of the input array, record batch or table.  By default, nNull values are
    considered greater than any other value and are therefore sorted at the
    end of the input. For floating-point types, NaNs are considered greater
    than any other non-null value, but smaller than null values.

    The handling of nulls and NaNs can be changed in SortOptions.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    sort_keys : sequence of (name, order) tuples
        Names of field/column keys to sort the input on,
        along with the order each field/column is sorted in.
        Accepted values for `order` are "ascending", "descending".
    null_placement : str, default "at_end"
        Where nulls in input should be sorted, only applying to
        columns/fields mentioned in `sort_keys`.
        Accepted values are "at_start", "at_end".
    options : pyarrow.compute.SortOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sort_indices` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'sort_indices',
        pyarrow._compute.SortOptions,
        options,
        (),
        sort_keys=sort_keys,
        null_placement=null_placement
    )
    func = pyarrow._compute.get_function('sort_indices')

    if isinstance(input, Expression):
        return Expression._call(
            'sort_indices',
            [input],
            _computed_options
        )

    return(
        func.call([input], _computed_options, memory_pool)
    )


def split_pattern(strings, /, pattern=None, *, max_splits=None, reverse=False,
                  options=None, memory_pool=None):
    """Split string according to separator.

    Split each string according to the exact `pattern` defined in
    SplitPatternOptions.  The output for each string input is a list
    of strings.

    The maximum number of splits and direction of splitting
    (forward, reverse) can optionally be defined in SplitPatternOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        String pattern to split on.
    max_splits : int or None, default None
        Maximum number of splits for each input value (unlimited if None).
    reverse : bool, default False
        Whether to start splitting from the end of each input value.
        This only has an effect if `max_splits` is not None.
    options : pyarrow.compute.SplitPatternOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `split_pattern` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'split_pattern',
        pyarrow._compute.SplitPatternOptions,
        options,
        (),
        pattern=pattern,
        max_splits=max_splits,
        reverse=reverse
    )
    func = pyarrow._compute.get_function('split_pattern')

    if isinstance(strings, Expression):
        return Expression._call(
            'split_pattern',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def split_pattern_regex(strings, /, pattern=None, *, max_splits=None,
                        reverse=False, options=None,
                        memory_pool=None):
    """Split string according to regex pattern.

    Split each string according to the regex `pattern` defined in
    SplitPatternOptions.  The output for each string input is a list
    of strings.

    The maximum number of splits and direction of splitting
    (forward, reverse) can optionally be defined in SplitPatternOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        String pattern to split on.
    max_splits : int or None, default None
        Maximum number of splits for each input value (unlimited if None).
    reverse : bool, default False
        Whether to start splitting from the end of each input value.
        This only has an effect if `max_splits` is not None.
    options : pyarrow.compute.SplitPatternOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `split_pattern_regex` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'split_pattern_regex',
        pyarrow._compute.SplitPatternOptions,
        options,
        (),
        pattern=pattern,
        max_splits=max_splits,
        reverse=reverse
    )
    func = pyarrow._compute.get_function('split_pattern_regex')

    if isinstance(strings, Expression):
        return Expression._call(
            'split_pattern_regex',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def sqrt(x, /, *, memory_pool=None):
    """Takes the square root of arguments element-wise.

    A negative argument returns a NaN.  For a variant that returns an
    error, use function "sqrt_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sqrt` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('sqrt')

    if isinstance(x, Expression):
        return Expression._call(
            'sqrt',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def sqrt_checked(x, /, *, memory_pool=None):
    """Takes the square root of arguments element-wise.

    A negative argument returns an error.  For a variant that returns a
    NaN, use function "sqrt".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sqrt_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('sqrt_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'sqrt_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def starts_with(strings, /, pattern=None, *, ignore_case=False, options=None,
                memory_pool=None):
    """Check if strings start with a literal pattern.

    For each string in `strings`, emit true iff it starts with a given
        pattern.
    The pattern must be given in MatchSubstringOptions.
    If ignore_case is set, only simple case folding is performed.

    Null inputs emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    pattern : str
        Substring pattern to look for inside input values.
    ignore_case : bool, default False
        Whether to perform a case-insensitive match.
    options : pyarrow.compute.MatchSubstringOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `starts_with` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'starts_with',
        pyarrow._compute.MatchSubstringOptions,
        options,
        (),
        pattern=pattern,
        ignore_case=ignore_case
    )
    func = pyarrow._compute.get_function('starts_with')

    if isinstance(strings, Expression):
        return Expression._call(
            'starts_with',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def stddev(array, /, *, ddof=0, skip_nulls=True, min_count=0, options=None,
           memory_pool=None):
    """Calculate the standard deviation of a numeric array.

    The number of degrees of freedom can be controlled using VarianceOptions.
    By default (`ddof` = 0), the population standard deviation is calculated.
    Nulls are ignored.  If there are not enough non-null values in the array
    to satisfy `ddof`, null is returned.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    ddof : int, default 0
        Number of degrees of freedom.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 0
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.VarianceOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `stddev` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'stddev',
        pyarrow._compute.VarianceOptions,
        options,
        (),
        ddof=ddof,
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('stddev')

    if isinstance(array, Expression):
        return Expression._call(
            'stddev',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def strftime(timestamps, /, format='%Y-%m-%dT%H:%M:%S', locale='C', *,
             options=None, memory_pool=None):
    """Format temporal values according to a format string.

    For each input value, emit a formatted string.
    The time format string and locale can be set using StrftimeOptions.
    The output precision of the "%S" (seconds) format code depends on
    the input time precision: it is an integer for timestamps with
    second precision, a real number with the required number of fractional
    digits for higher precisions.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database, or if the specified locale
    does not exist on this system.

    Parameters
    ----------
    timestamps : Array-like or scalar-like
        Argument to compute function.
    format : str, default "%Y-%m-%dT%H:%M:%S"
        Pattern for formatting input values.
    locale : str, default "C"
        Locale to use for locale-specific format specifiers.
    options : pyarrow.compute.StrftimeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `strftime` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'strftime',
        pyarrow._compute.StrftimeOptions,
        options,
        (),
        format=format,
        locale=locale
    )
    func = pyarrow._compute.get_function('strftime')

    if isinstance(timestamps, Expression):
        return Expression._call(
            'strftime',
            [timestamps],
            _computed_options
        )

    return(
        func.call([timestamps], _computed_options, memory_pool)
    )


def string_is_ascii(strings, /, *, memory_pool=None):
    """Classify strings as ASCII.

    For each string in `strings`, emit true iff the string consists only
    of ASCII characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `string_is_ascii` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('string_is_ascii')

    if isinstance(strings, Expression):
        return Expression._call(
            'string_is_ascii',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def strptime(strings, /, format=None, unit=None, error_is_null=False, *,
             options=None, memory_pool=None):
    """Parse timestamps.

    For each string in `strings`, parse it as a timestamp.
    The timestamp unit and the expected string pattern must be given
    in StrptimeOptions. Null inputs emit null. If a non-null string
    fails parsing, an error is returned by default.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    format : str
        Pattern for parsing input strings as timestamps, such as "%Y/%m/%d".
    unit : str
        Timestamp unit of the output.
        Accepted values are "s", "ms", "us", "ns".
    error_is_null : boolean, default False
        Return null on parsing errors if true or raise if false.
    options : pyarrow.compute.StrptimeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `strptime` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'strptime',
        pyarrow._compute.StrptimeOptions,
        options,
        (),
        format=format,
        unit=unit,
        error_is_null=error_is_null
    )
    func = pyarrow._compute.get_function('strptime')

    if isinstance(strings, Expression):
        return Expression._call(
            'strptime',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def struct_field(values, /, indices=None, *, options=None, memory_pool=None):
    """Extract children of a struct or union by index.

    Given a list of indices (passed via StructFieldOptions), extract
    the child array or scalar with the given child index, recursively.

    For union inputs, nulls are emitted for union values that reference
    a different child than specified. Also, the indices are always
    in physical order, not logical type codes - for example, the first
    child is always index 0.

    An empty list of indices returns the argument unchanged.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    indices : sequence of int
        List of indices for chained field lookup, for example `[4, 1]`
        will look up the second nested field in the fifth outer field.
    options : pyarrow.compute.StructFieldOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `struct_field` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'struct_field',
        pyarrow._compute.StructFieldOptions,
        options,
        (),
        indices=indices
    )
    func = pyarrow._compute.get_function('struct_field')

    if isinstance(values, Expression):
        return Expression._call(
            'struct_field',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def subsecond(values, /, *, memory_pool=None):
    """Extract subsecond values.

    Subsecond returns the fraction of a second since the last full second.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `subsecond` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('subsecond')

    if isinstance(values, Expression):
        return Expression._call(
            'subsecond',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def subtract(x, y, /, *, memory_pool=None):
    """Subtract the arguments element-wise.

    Results will wrap around on integer overflow.
    Use function "subtract_checked" if you want overflow
    to return an error.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `subtract` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('subtract')

    if isinstance(x, Expression):
        return Expression._call(
            'subtract',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def subtract_checked(x, y, /, *, memory_pool=None):
    """Subtract the arguments element-wise.

    This function returns an error on overflow.  For a variant that
    doesn't fail on overflow, use function "subtract".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `subtract_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('subtract_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'subtract_checked',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def sum(array, /, *, skip_nulls=True, min_count=1, options=None,
        memory_pool=None):
    """Compute the sum of a numeric array.

    Null values are ignored by default. Minimum count of non-null
    values can be set and null is returned if too few are present.
    This can be changed through ScalarAggregateOptions.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 1
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.ScalarAggregateOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `sum` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'sum',
        pyarrow._compute.ScalarAggregateOptions,
        options,
        (),
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('sum')

    if isinstance(array, Expression):
        return Expression._call(
            'sum',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def take(input, indices, /, *, boundscheck=True, options=None,
         memory_pool=None):
    """Select values from an input based on indices from another array.

    The output is populated with values from the input at positions
    given by `indices`.  Nulls in `indices` emit null in the output.

    Parameters
    ----------
    input : Array-like or scalar-like
        Argument to compute function.
    indices : Array-like or scalar-like
        Argument to compute function.
    boundscheck : boolean, default True
        Whether to check indices are within bounds. If False and an
        index is out of boundes, behavior is undefined (the process
        may crash).
    options : pyarrow.compute.TakeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `take` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'take',
        pyarrow._compute.TakeOptions,
        options,
        (),
        boundscheck=boundscheck
    )
    func = pyarrow._compute.get_function('take')

    if isinstance(input, Expression):
        return Expression._call(
            'take',
            [input, indices],
            _computed_options
        )

    return(
        func.call([input, indices], _computed_options, memory_pool)
    )


def tan(x, /, *, memory_pool=None):
    """Compute the tangent.

    NaN is returned for invalid input values;
    to raise an error instead, see "tan_checked".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `tan` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('tan')

    if isinstance(x, Expression):
        return Expression._call(
            'tan',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def tan_checked(x, /, *, memory_pool=None):
    """Compute the tangent.

    Infinite values raise an error;
    to return NaN instead, see "tan".

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `tan_checked` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('tan_checked')

    if isinstance(x, Expression):
        return Expression._call(
            'tan_checked',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def tdigest(array, /, q=0.5, *, delta=100, buffer_size=500, skip_nulls=True,
            min_count=0, options=None, memory_pool=None):
    """Approximate quantiles of a numeric array with T-Digest algorithm.

    By default, 0.5 quantile (median) is returned.
    Nulls and NaNs are ignored.
    An array of nulls is returned if there is no valid data point.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    q : double or sequence of double, default 0.5
        Quantiles to approximate. All values must be in [0, 1].
    delta : int, default 100
        Compression parameter for the T-digest algorithm.
    buffer_size : int, default 500
        Buffer size for the T-digest algorithm.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 0
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.TDigestOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `tdigest` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'tdigest',
        pyarrow._compute.TDigestOptions,
        options,
        (),
        q=q,
        delta=delta,
        buffer_size=buffer_size,
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('tdigest')

    if isinstance(array, Expression):
        return Expression._call(
            'tdigest',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def true_unless_null(values, /, *, memory_pool=None):
    """Return true if non-null, else return null.

    For each input value, emit true iff the value
    is valid (non-null), otherwise emit null.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `true_unless_null` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('true_unless_null')

    if isinstance(values, Expression):
        return Expression._call(
            'true_unless_null',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def trunc(x, /, *, memory_pool=None):
    """Compute the integral part.

    Compute the nearest integer not greater in magnitude than `x`.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `trunc` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('trunc')

    if isinstance(x, Expression):
        return Expression._call(
            'trunc',
            [x]
        )

    return(
        func.call([x], memory_pool=memory_pool)
    )


def unique(array, /, *, memory_pool=None):
    """Compute unique elements.

    Return an array with distinct values.  Nulls in the input are ignored.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `unique` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('unique')

    if isinstance(array, Expression):
        return Expression._call(
            'unique',
            [array]
        )

    return(
        func.call([array], memory_pool=memory_pool)
    )


def us_week(values, /, *, memory_pool=None):
    """Extract US week of year number.

    First US week has the majority (4 or more) of its days in January.
    US week starts on Monday. The week number starts with 1 and can run
    up to 53.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `us_week` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('us_week')

    if isinstance(values, Expression):
        return Expression._call(
            'us_week',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def us_year(values, /, *, memory_pool=None):
    """Extract US epidemiological year number.

    First week of US epidemiological year has the majority (4 or more) of
    it's days in January. Last week of US epidemiological year has the
    year's last Wednesday in it. US epidemiological week starts on Sunday.
    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `us_year` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('us_year')

    if isinstance(values, Expression):
        return Expression._call(
            'us_year',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def utf8_capitalize(strings, /, *, memory_pool=None):
    """Capitalize the first character of input.

    For each string in `strings`, return a capitalized version,
    with the first character uppercased and the others lowercased.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_capitalize` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_capitalize')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_capitalize',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_center(strings, /, width=None, padding=' ', *, options=None,
                memory_pool=None):
    """Center strings by padding with a given character.

    For each string in `strings`, emit a centered string by padding both
        sides
    with the given UTF8 codeunit.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_center` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_center',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('utf8_center')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_center',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_is_alnum(strings, /, *, memory_pool=None):
    """Classify strings as alphanumeric.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of alphanumeric Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_alnum` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_alnum')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_alnum',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_alpha(strings, /, *, memory_pool=None):
    """Classify strings as alphabetic.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of alphabetic Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_alpha` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_alpha')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_alpha',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_decimal(strings, /, *, memory_pool=None):
    """Classify strings as decimal.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of decimal Unicode characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_decimal` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_decimal')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_decimal',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_digit(strings, /, *, memory_pool=None):
    """Classify strings as digits.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of Unicode digits.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_digit` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_digit')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_digit',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_lower(strings, /, *, memory_pool=None):
    """Classify strings as lowercase.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of lowercase Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_lower` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_lower')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_lower',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_numeric(strings, /, *, memory_pool=None):
    """Classify strings as numeric.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of numeric Unicode characters.  Null strings emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_numeric` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_numeric')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_numeric',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_printable(strings, /, *, memory_pool=None):
    """Classify strings as printable.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of printable Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_printable` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_printable')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_printable',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_space(strings, /, *, memory_pool=None):
    """Classify strings as whitespace.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of whitespace Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_space` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_space')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_space',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_title(strings, /, *, memory_pool=None):
    """Classify strings as titlecase.

    For each string in `strings`, emit true iff the string is title-cased,
    i.e. it has at least one cased character, each uppercase character
    follows an uncased character, and each lowercase character follows
    an uppercase character.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_title` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_title')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_title',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_is_upper(strings, /, *, memory_pool=None):
    """Classify strings as uppercase.

    For each string in `strings`, emit true iff the string is non-empty
    and consists only of uppercase Unicode characters.  Null strings emit
        null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_is_upper` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_is_upper')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_is_upper',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_length(strings, /, *, memory_pool=None):
    """Compute UTF8 string lengths.

    For each string in `strings`, emit its length in UTF8 characters.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_length` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_length')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_length',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_lower(strings, /, *, memory_pool=None):
    """Transform input to lowercase.

    For each string in `strings`, return a lowercase version.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_lower` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_lower')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_lower',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_lpad(strings, /, width=None, padding=' ', *, options=None,
              memory_pool=None):
    """Right-align strings by padding with a given character.

    For each string in `strings`, emit a right-aligned string by prepending
    the given UTF8 codeunit.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_lpad` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_lpad',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('utf8_lpad')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_lpad',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_ltrim(strings, /, characters=None, *, options=None, memory_pool=None):
    """Trim leading characters.

    For each string in `strings`, remove any leading characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_ltrim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_ltrim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('utf8_ltrim')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_ltrim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_ltrim_whitespace(strings, /, *, memory_pool=None):
    """Trim leading whitespace characters.

    For each string in `strings`, emit a string with leading whitespace
    characters removed, where whitespace characters are defined by the
        Unicode
    standard.  Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_ltrim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_ltrim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_ltrim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_normalize(strings, /, form=None, *, options=None, memory_pool=None):
    """Utf8-normalize input.

    For each string in `strings`, return the normal form.

    The normalization form must be given in the options.
    Null inputs emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    form : str
        Unicode normalization form.
        Accepted values are "NFC", "NFKC", "NFD", NFKD".
    options : pyarrow.compute.Utf8NormalizeOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_normalize` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_normalize',
        pyarrow._compute.Utf8NormalizeOptions,
        options,
        (),
        form=form
    )
    func = pyarrow._compute.get_function('utf8_normalize')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_normalize',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_replace_slice(strings, /, start=None, stop=None, replacement=None, *,
                       options=None, memory_pool=None):
    """Replace a slice of a string.

    For each string in `strings`, replace a slice of the string defined by
        `start`
    and `stop` indices with the given `replacement`. `start` is inclusive
    and `stop` is exclusive, and both are measured in UTF8 characters.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    start : int
        Index to start slicing at (inclusive).
    stop : int
        Index to stop slicing at (exclusive).
    replacement : str
        What to replace the slice with.
    options : pyarrow.compute.ReplaceSliceOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_replace_slice` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_replace_slice',
        pyarrow._compute.ReplaceSliceOptions,
        options,
        (),
        start=start,
        stop=stop,
        replacement=replacement
    )
    func = pyarrow._compute.get_function('utf8_replace_slice')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_replace_slice',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_reverse(strings, /, *, memory_pool=None):
    """Reverse input.

    For each string in `strings`, return a reversed version.

    This function operates on Unicode codepoints, not grapheme
    clusters. Hence, it will not correctly reverse grapheme clusters
    composed of multiple codepoints.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_reverse` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_reverse')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_reverse',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_rpad(strings, /, width=None, padding=' ', *, options=None,
              memory_pool=None):
    """Left-align strings by padding with a given character.

    For each string in `strings`, emit a left-aligned string by appending
    the given UTF8 codeunit.
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    width : int
        Desired string length.
    padding : str, default " "
        What to pad the string with. Should be one byte or codepoint.
    options : pyarrow.compute.PadOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_rpad` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_rpad',
        pyarrow._compute.PadOptions,
        options,
        (),
        width=width,
        padding=padding
    )
    func = pyarrow._compute.get_function('utf8_rpad')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_rpad',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_rtrim(strings, /, characters=None, *, options=None, memory_pool=None):
    """Trim trailing characters.

    For each string in `strings`, remove any trailing characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_rtrim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_rtrim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('utf8_rtrim')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_rtrim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_rtrim_whitespace(strings, /, *, memory_pool=None):
    """Trim trailing whitespace characters.

    For each string in `strings`, emit a string with trailing whitespace
    characters removed, where whitespace characters are defined by the
        Unicode
    standard.  Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_rtrim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_rtrim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_rtrim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_slice_codeunits(strings, /, start=None, stop=None, step=1, *,
                         options=None,
                         memory_pool=None):
    """Slice string.

    For each string in `strings`, emit the substring defined by
    (`start`, `stop`, `step`) as given by `SliceOptions` where `start` is
    inclusive and `stop` is exclusive. All three values are measured in
    UTF8 codeunits.
    If `step` is negative, the string will be advanced in reversed order.
    An error is raised if `step` is zero.
    Null inputs emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    start : int
        Index to start slicing at (inclusive).
    stop : int or None, default None
        If given, index to stop slicing at (exclusive).
        If not given, slicing will stop at the end.
    step : int, default 1
        Slice step.
    options : pyarrow.compute.SliceOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_slice_codeunits` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_slice_codeunits',
        pyarrow._compute.SliceOptions,
        options,
        (),
        start=start,
        stop=stop,
        step=step
    )
    func = pyarrow._compute.get_function('utf8_slice_codeunits')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_slice_codeunits',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_split_whitespace(strings, /, *, max_splits=None, reverse=False,
                          options=None,
                          memory_pool=None):
    """Split string according to any Unicode whitespace.

    Split each string according any non-zero length sequence of Unicode
    whitespace characters.  The output for each string input is a list
    of strings.

    The maximum number of splits and direction of splitting
    (forward, reverse) can optionally be defined in SplitOptions.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    max_splits : int or None, default None
        Maximum number of splits for each input value (unlimited if None).
    reverse : bool, default False
        Whether to start splitting from the end of each input value.
        This only has an effect if `max_splits` is not None.
    options : pyarrow.compute.SplitOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_split_whitespace` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_split_whitespace',
        pyarrow._compute.SplitOptions,
        options,
        (),
        max_splits=max_splits,
        reverse=reverse
    )
    func = pyarrow._compute.get_function('utf8_split_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_split_whitespace',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_swapcase(strings, /, *, memory_pool=None):
    """Transform input lowercase characters to uppercase and uppercase
        characters to lowercase.

    For each string in `strings`, return an opposite case version.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_swapcase` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_swapcase')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_swapcase',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_title(strings, /, *, memory_pool=None):
    """Titlecase each word of input.

    For each string in `strings`, return a titlecased version.
    Each word in the output will start with an uppercase character and its
    remaining characters will be lowercase.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_title` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_title')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_title',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_trim(strings, /, characters=None, *, options=None, memory_pool=None):
    """Trim leading and trailing characters.

    For each string in `strings`, remove any leading or trailing characters
    from the `characters` option (as given in TrimOptions).
    Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    characters : str
        Individual characters to be trimmed from the string.
    options : pyarrow.compute.TrimOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_trim` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'utf8_trim',
        pyarrow._compute.TrimOptions,
        options,
        (),
        characters=characters
    )
    func = pyarrow._compute.get_function('utf8_trim')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_trim',
            [strings],
            _computed_options
        )

    return(
        func.call([strings], _computed_options, memory_pool)
    )


def utf8_trim_whitespace(strings, /, *, memory_pool=None):
    """Trim leading and trailing whitespace characters.

    For each string in `strings`, emit a string with leading and trailing
    whitespace characters removed, where whitespace characters are defined
    by the Unicode standard.  Null values emit null.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_trim_whitespace` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_trim_whitespace')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_trim_whitespace',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def utf8_upper(strings, /, *, memory_pool=None):
    """Transform input to uppercase.

    For each string in `strings`, return an uppercase version.

    Parameters
    ----------
    strings : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `utf8_upper` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('utf8_upper')

    if isinstance(strings, Expression):
        return Expression._call(
            'utf8_upper',
            [strings]
        )

    return(
        func.call([strings], memory_pool=memory_pool)
    )


def value_counts(array, /, *, memory_pool=None):
    """Compute counts of unique elements.

    For each distinct value, compute the number of times it occurs in the
        array.
    The result is returned as an array of `struct<input type, int64>`.
    Nulls in the input are ignored.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `value_counts` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('value_counts')

    if isinstance(array, Expression):
        return Expression._call(
            'value_counts',
            [array]
        )

    return(
        func.call([array], memory_pool=memory_pool)
    )


def variance(array, /, *, ddof=0, skip_nulls=True, min_count=0, options=None,
             memory_pool=None):
    """Calculate the variance of a numeric array.

    The number of degrees of freedom can be controlled using VarianceOptions.
    By default (`ddof` = 0), the population variance is calculated.
    Nulls are ignored.  If there are not enough non-null values in the array
    to satisfy `ddof`, null is returned.

    Parameters
    ----------
    array : Array-like
        Argument to compute function.
    ddof : int, default 0
        Number of degrees of freedom.
    skip_nulls : bool, default True
        Whether to skip (ignore) nulls in the input.
        If False, any null in the input forces the output to null.
    min_count : int, default 0
        Minimum number of non-null values in the input.  If the number
        of non-null values is below `min_count`, the output is null.
    options : pyarrow.compute.VarianceOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `variance` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'variance',
        pyarrow._compute.VarianceOptions,
        options,
        (),
        ddof=ddof,
        skip_nulls=skip_nulls,
        min_count=min_count
    )
    func = pyarrow._compute.get_function('variance')

    if isinstance(array, Expression):
        return Expression._call(
            'variance',
            [array],
            _computed_options
        )

    return(
        func.call([array], _computed_options, memory_pool)
    )


def week(values, /, *, week_starts_monday=True, count_from_zero=False,
         first_week_is_fully_in_year=False, options=None,
         memory_pool=None):
    """Extract week of year number.

    First week has the majority (4 or more) of its days in January.
    Year can have 52 or 53 weeks. Week numbering can start with 0 or 1 using
    DayOfWeekOptions.count_from_zero.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    week_starts_monday : bool, default True
        If True, weeks start on Monday; if False, on Sunday.
    count_from_zero : bool, default False
        If True, dates at the start of a year that fall into the last week
        of the previous year emit 0.
        If False, they emit 52 or 53 (the week number of the last week
        of the previous year).
    first_week_is_fully_in_year : bool, default False
        If True, week number 0 is fully in January.
        If False, a week that begins on December 29, 30 or 31 is considered
        to be week number 0 of the following year.
    options : pyarrow.compute.WeekOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `week` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'week',
        pyarrow._compute.WeekOptions,
        options,
        (),
        week_starts_monday=week_starts_monday,
        count_from_zero=count_from_zero,
        first_week_is_fully_in_year=first_week_is_fully_in_year
    )
    func = pyarrow._compute.get_function('week')

    if isinstance(values, Expression):
        return Expression._call(
            'week',
            [values],
            _computed_options
        )

    return(
        func.call([values], _computed_options, memory_pool)
    )


def weeks_between(start, end, /, *, count_from_zero=True, week_start=1,
                  options=None, memory_pool=None):
    """Compute the number of weeks between two timestamps.

    Returns the number of week boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the week.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    count_from_zero : bool, default True
        If True, number days from 0, otherwise from 1.
    week_start : int, default 1
        Which day does the week start with (Monday=1, Sunday=7).
        How this value is numbered is unaffected by `count_from_zero`.
    options : pyarrow.compute.DayOfWeekOptions, optional
        Alternative way of passing options.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `weeks_between` compute function in the Arrow C++ library.
    """

    _computed_options = _handle_options(
        'weeks_between',
        pyarrow._compute.DayOfWeekOptions,
        options,
        (),
        count_from_zero=count_from_zero,
        week_start=week_start
    )
    func = pyarrow._compute.get_function('weeks_between')

    if isinstance(start, Expression):
        return Expression._call(
            'weeks_between',
            [start, end],
            _computed_options
        )

    return(
        func.call([start, end], _computed_options, memory_pool)
    )


def xor(x, y, /, *, memory_pool=None):
    """Logical 'xor' boolean values.

    When a null is encountered in either input, a null is output.

    Parameters
    ----------
    x : Array-like or scalar-like
        Argument to compute function.
    y : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `xor` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('xor')

    if isinstance(x, Expression):
        return Expression._call(
            'xor',
            [x, y]
        )

    return(
        func.call([x, y], memory_pool=memory_pool)
    )


def year(values, /, *, memory_pool=None):
    """Extract year number.

    Null values emit null.
    An error is returned if the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `year` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('year')

    if isinstance(values, Expression):
        return Expression._call(
            'year',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def year_month_day(values, /, *, memory_pool=None):
    """Extract (year, month, day) struct.

    Null values emit null.
    An error is returned in the values have a defined timezone but it
    cannot be found in the timezone database.

    Parameters
    ----------
    values : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `year_month_day` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('year_month_day')

    if isinstance(values, Expression):
        return Expression._call(
            'year_month_day',
            [values]
        )

    return(
        func.call([values], memory_pool=memory_pool)
    )


def years_between(start, end, /, *, memory_pool=None):
    """Compute the number of years between two timestamps.

    Returns the number of year boundaries crossed from `start` to `end`.
    That is, the difference is calculated as if the timestamps were
    truncated to the year.
    Null values emit null.

    Parameters
    ----------
    start : Array-like or scalar-like
        Argument to compute function.
    end : Array-like or scalar-like
        Argument to compute function.
    memory_pool : pyarrow.MemoryPool, optional
        If not passed, will allocate memory from the default memory pool.

    See Also
    --------
    The `years_between` compute function in the Arrow C++ library.
    """

    func = pyarrow._compute.get_function('years_between')

    if isinstance(start, Expression):
        return Expression._call(
            'years_between',
            [start, end]
        )

    return(
        func.call([start, end], memory_pool=memory_pool)
    )
