#!/usr/bin/env sh

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Anticonf (tm) script by Jeroen Ooms, Jim Hester (2017)
# License: MIT
#
# This script will query 'pkg-config' for the required cflags and ldflags.
# If pkg-config is unavailable or does not find the library, try setting
# INCLUDE_DIR and LIB_DIR manually via e.g:
# R CMD INSTALL --configure-vars='INCLUDE_DIR=/.../include LIB_DIR=/.../lib'

# Library settings
PKG_CONFIG_NAME="arrow"
PKG_BREW_NAME="apache-arrow"
PKG_TEST_HEADER="<arrow/api.h>"

# Some env vars that control the build (all logical, case insensitive)
# Development mode, also increases verbosity
ARROW_R_DEV=`echo $ARROW_R_DEV | tr '[:upper:]' '[:lower:]'`
# autobrew is how mac binaries are built on CRAN; FORCE ensures we use it here
FORCE_AUTOBREW=`echo $FORCE_AUTOBREW | tr '[:upper:]' '[:lower:]'`
# The bundled build compiles arrow C++ from source; FORCE ensures we don't pick up
# any other packages that may be found on the system
FORCE_BUNDLED_BUILD=`echo $FORCE_BUNDLED_BUILD | tr '[:upper:]' '[:lower:]'`
# If present, `pkg-config` will be used to find libarrow on the system,
# unless this is set to false
ARROW_USE_PKG_CONFIG=`echo $ARROW_USE_PKG_CONFIG | tr '[:upper:]' '[:lower:]'`
# For a bundled build, we can set this to true to turn off all optional features,
# false to enable all optional features, and unset builds most but not all
LIBARROW_MINIMAL=`echo $LIBARROW_MINIMAL | tr '[:upper:]' '[:lower:]'`
# Just used in testing: whether or not it is ok to download dependencies (in the
# bundled build)
TEST_OFFLINE_BUILD=`echo $TEST_OFFLINE_BUILD | tr '[:upper:]' '[:lower:]'`
# Shorthand to set LIBARROW_BINARY=true; LIBARROW_MINIMAL=false
NOT_CRAN=`echo $NOT_CRAN | tr '[:upper:]' '[:lower:]'`

VERSION=`grep '^Version' DESCRIPTION | sed s/Version:\ //`
UNAME=`uname -s`

S3_LIBS=""
GCS_LIBS=""

# If in development mode, run the codegen script to render arrowExports.*
if [ "$ARROW_R_DEV" = "true" ] && [ -f "data-raw/codegen.R" ]; then
  echo "*** Generating code with data-raw/codegen.R"
  ${R_HOME}/bin/Rscript data-raw/codegen.R
fi

# Arrow requires C++17, so check for it
if [ ! "`${R_HOME}/bin/R CMD config CXX17`" ]; then
  echo "------------------------- NOTE ---------------------------"
  echo "Cannot install arrow: a C++17 compiler is required."
  echo "See https://arrow.apache.org/docs/r/articles/install.html"
  echo "---------------------------------------------------------"
  exit 1
fi

# Setup for local autobrew testing
if [ -f "tools/apache-arrow.rb" ]; then
  # If you want to use a local apache-arrow.rb formula, do
  # $ cp ../dev/tasks/homebrew-formulae/autobrew/apache-arrow.rb tools/apache-arrow.rb
  # before R CMD build or INSTALL (assuming a local checkout of the apache/arrow repository)
  cp tools/autobrew .
  if [ "$FORCE_AUTOBREW" != "false" ]; then
    # It is possible to turn off forced autobrew if the formula is included,
    # but most likely you shouldn't because the included formula will reference
    # the C++ library at the version that matches the R package.
    FORCE_AUTOBREW="true"
  fi
fi

# Test if pkg-config is available to use
pkg-config --version >/dev/null 2>&1
if [ $? -eq 0 ]; then
  PKG_CONFIG_AVAILABLE="true"
else
  PKG_CONFIG_AVAILABLE="false"
  ARROW_USE_PKG_CONFIG="false"
fi

use_arrow_home () {
  echo "*** Using ARROW_HOME as the source of libarrow"
  # Should we test that ARROW_HOME exists?
  PKG_CFLAGS="-I$ARROW_HOME/include $PKG_CFLAGS"
  PKG_LIBS="-larrow"
  LIB_DIR="$ARROW_HOME/lib"
  PKG_DIRS="-L$LIB_DIR"
}

do_bundled_build () {
  # The build logic is in tools/nixlibs.R, but we do a little more configuration first
  if [ "${NOT_CRAN}" = "true" ]; then
    # Set some default values
    if [ "${LIBARROW_BINARY}" = "" ]; then
      export LIBARROW_BINARY=true
    fi
    if [ "${LIBARROW_MINIMAL}" = "" ]; then
      export LIBARROW_MINIMAL=false
    fi
  fi

  # find openssl on macos. macOS ships with libressl. openssl is installable
  # with brew, but it is generally not linked. We can over-ride this and find
  # openssl but setting OPENSSL_ROOT_DIR (which cmake will pick up later in
  # the installation process). FWIW, arrow's cmake process uses this
  # same process to find openssl, but doing it now allows us to catch it in
  # nixlibs.R and throw a nicer error.
  if [ "$UNAME" = "Darwin" ] && [ "${OPENSSL_ROOT_DIR}" = "" ]; then
    brew --prefix openssl >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      export OPENSSL_ROOT_DIR="`brew --prefix openssl`"
      export PKG_CONFIG_PATH="`brew --prefix openssl`/lib/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}"
    fi
  fi

  if [ "${ARROW_DEPENDENCY_SOURCE}" = "" ]; then
    export ARROW_DEPENDENCY_SOURCE=AUTO
  fi
  if [ "${ARROW_DEPENDENCY_SOURCE}" = "AUTO" ] && \
        [ "${PKG_CONFIG_AVAILABLE}" = "false" ]; then
    # Should this also respect ARROW_USE_PKG_CONFIG?
    export ARROW_DEPENDENCY_SOURCE=BUNDLED
    echo "**** pkg-config not installed, setting ARROW_DEPENDENCY_SOURCE=BUNDLED"
  fi

  ${R_HOME}/bin/Rscript tools/nixlibs.R $VERSION

  # Once we've done the source build, we need to inspect it to see what
  # system libraries it may need, and set cflags/dirs/libs accordingly
  LIB_DIR="`pwd`/libarrow/arrow-${VERSION}/lib"
  if [ -d "$LIB_DIR" ]; then
    if [ "${PKG_CONFIG_AVAILABLE}" = "true" ]; then
      # Use pkg-config to do static linking of libarrow's dependencies
      export PKG_CONFIG_PATH="${LIB_DIR}/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}"
      PKG_CONFIG="pkg-config"
      # pkg-config on CentOS 7 doesn't have --define-prefix option.
      if ${PKG_CONFIG} --help | grep -- --define-prefix >/dev/null 2>&1; then
        # --define-prefix is for binary packages. Binary packages
        # uses "/arrow/r/libarrow/dist" as prefix but it doesn't
        # match the extracted path. --define-prefix uses a directory
        # that arrow.pc exists as its prefix instead of
        # "/arrow/r/libarrow/dist".
        PKG_CONFIG="${PKG_CONFIG} --define-prefix"
      else
        # Rewrite prefix= in arrow.pc on CentOS 7.
        sed \
          -i.bak \
          -e "s,prefix=/arrow/r/libarrow/dist,prefix=${LIB_DIR}/..,g" \
          ${LIB_DIR}/pkgconfig/*.pc
        rm -f ${LIB_DIR}/pkgconfig/*.pc.bak
      fi
      PKG_CONFIG="${PKG_CONFIG} --silence-errors"
      PKG_CFLAGS="`${PKG_CONFIG} --cflags ${PKG_CONFIG_NAME}` $PKG_CFLAGS"
      PKG_DIRS="`${PKG_CONFIG} --libs-only-L ${PKG_CONFIG_NAME}`"
      PKG_LIBS="`${PKG_CONFIG} --libs-only-l --libs-only-other ${PKG_CONFIG_NAME}`"
    else
      # This case must be ARROW_DEPENDENCY_SOURCE=BUNDLED.
      PKG_CFLAGS="-I${LIB_DIR}/../include $PKG_CFLAGS"
      if grep -q "_GLIBCXX_USE_CXX11_ABI=0" "${LIB_DIR}/pkgconfig/arrow.pc"; then
        PKG_CFLAGS="${PKG_CFLAGS} -D_GLIBCXX_USE_CXX11_ABI=0"
      fi
      PKG_DIRS="-L${LIB_DIR}"
      if [ "${OPENSSL_ROOT_DIR}" != "" ]; then
        PKG_DIRS="${PKG_DIRS} -L${OPENSSL_ROOT_DIR}/lib"
      fi
      PKG_LIBS="-larrow"
      if [ -n "$(find "$LIB_DIR" -name 'libarrow_bundled_dependencies.*')" ]; then
        PKG_LIBS="$PKG_LIBS -larrow_bundled_dependencies"
      fi
      S3_LIBS="-lcurl -lssl -lcrypto"
      GCS_LIBS="-lcurl -lssl -lcrypto"
    fi
  fi
}

do_autobrew () {
  echo "*** Downloading ${PKG_BREW_NAME}"
  if [ -f "autobrew" ]; then
    echo "**** Using local manifest for ${PKG_BREW_NAME}"
  else
    curl -sfL "https://autobrew.github.io/scripts/$PKG_BREW_NAME" > autobrew
    if [ $? -ne 0 ]; then
      echo "Failed to download manifest for ${PKG_BREW_NAME}"
    fi
  fi
  . autobrew
  if [ $? -ne 0 ]; then
    echo "Failed to retrieve binary for ${PKG_BREW_NAME}"
  fi
  # autobrew sets `PKG_LIBS`, `PKG_DIRS`, and `PKG_CFLAGS`
  # TODO: move PKG_LIBS and PKG_CFLAGS out of autobrew because we handle them below
}

check_versions () {
  R_VERSION="$1"
  CPP_VERSION="$2"

  # 1. Check x.y.z versions. If they do not match, fail
  R_RELEASE=`echo $R_VERSION | sed -E 's/([0-9]+\.[0-9]+\.[0-9]+).*/\1/'`
  CPP_RELEASE=`echo $CPP_VERSION | sed -E -e 's/([0-9]+\.[0-9]+\.[0-9]+).*/\1/'`
  if [ "$R_RELEASE" != "$CPP_RELEASE" ]; then
    echo "**** Found C++ library version $CPP_VERSION but R package is $R_VERSION"
    VERSIONS_OK="false"
  else
    # 2. Check the dev versions
    echo $R_VERSION | grep -e '9000$' >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      R_VERSION_IS_DEV="true"
    fi
    echo $CPP_VERSION | grep -e 'SNAPSHOT$' >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      CPP_VERSION_IS_DEV="true"
      if [ "$R_VERSION_IS_DEV" = "true" ]; then
        # Both are dev, so give a gentle warning that you may need to update if there are probems
        echo "**** Packages are both on development versions ($CPP_VERSION, $R_VERSION)"
        echo "**** If installation fails, rebuild the C++ library to match the R version"
        echo "**** or retry with FORCE_BUNDLED_BUILD=true"
      else
        # C++ is dev but R is not
        echo "**** Found C++ library version $CPP_VERSION but R package is $R_VERSION"
        VERSIONS_OK="false"
      fi
    elif [ "$R_VERSION_IS_DEV" = "true" ]; then
      # R is dev but C++ is not
      echo "**** Found C++ library version $CPP_VERSION but R package is $R_VERSION"
      VERSIONS_OK="false"
    fi
  fi
  # Add ALLOW_VERSION_MISMATCH env var to override? (Could be useful for debugging)
}

########################

#### Now we're ready to find/build libarrow
if [ "$FORCE_BUNDLED_BUILD" = "true" ]; then
  do_bundled_build
elif [ "$FORCE_AUTOBREW" = "true" ]; then
  do_autobrew
elif [ "$ARROW_HOME" ]; then
  # 1. ARROW_HOME is a directory you've built and installed libarrow into.
  #    If the env var is set, we use it
  use_arrow_home
elif [ "$ARROW_USE_PKG_CONFIG" != "false" ] && pkg-config ${PKG_CONFIG_NAME}; then
  # 2. Use pkg-config to find arrow on the system
  PKG_CFLAGS="`pkg-config --cflags --silence-errors ${PKG_CONFIG_NAME}` $PKG_CFLAGS"
  PKG_LIBS=`pkg-config --libs-only-l --libs-only-other --silence-errors ${PKG_CONFIG_NAME}`
  PKG_DIRS=`pkg-config --libs-only-L --silence-errors ${PKG_CONFIG_NAME}`
  LIB_DIR=`echo $PKG_DIRS | sed -e 's/^-L//'`
  echo "*** Arrow C++ libraries found via pkg-config at $FOUND_LIB_DIR"

  # Check for version mismatch
  PC_LIB_VERSION=`pkg-config --modversion arrow`
  check_versions $VERSION $PC_LIB_VERSION
  # TODO(here): move this to after all finding, and if VERSIONS_OK = "false", fall back to bundle
elif [ "$UNAME" = "Darwin" ]; then
  # 3a. On macOS, look for Homebrew apache-arrow
  #     (note that if you have pkg-config, homebrew arrow will have already been found)
  if [ "`command -v brew`" ] && [ "`brew ls --versions ${PKG_BREW_NAME}`" != "" ]; then
    echo "*** Using Homebrew ${PKG_BREW_NAME}"
    BREWDIR=`brew --prefix ${PKG_BREW_NAME}`
    LIB_DIR="$BREWDIR/lib"
    PKG_LIBS="-larrow -larrow_bundled_dependencies"
    PKG_DIRS="-L$LIB_DIR $PKG_DIRS"
    PKG_CFLAGS="-I$BREWDIR/include $PKG_CFLAGS"
  else
    # 3b. Use autobrew
    do_autobrew
  fi
else
  # 4. Do a libarrow build from source (bundled)
  do_bundled_build
fi

# TODO(here): factor out all of the PKG_LIBS/DIRS/CFLAGS setting above, and use two cases:
# pkg-config or not. Set:
# export PKG_CONFIG_PATH="${LIB_DIR}/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}"
# Then do version check

# TODO(here, above here actually): separate the find vs build steps and do version check before building
# If version check fails, proceed to building

# Add a few more flags, and then we can run a test progam

# If on Raspberry Pi, need to manually link against latomic
# See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81358 for similar example
if grep raspbian /etc/os-release >/dev/null 2>&1; then
  PKG_CFLAGS="$PKG_CFLAGS -DARROW_CXXFLAGS=-latomic"
  PKG_LIBS="-latomic $PKG_LIBS"
fi

# Set any user-defined CXXFLAGS
if [ "$ARROW_R_CXXFLAGS" ]; then
  PKG_CFLAGS="$PKG_CFLAGS $ARROW_R_CXXFLAGS"
fi

# Test that we can find libarrow
CXX17="`${R_HOME}/bin/R CMD config CXX17` -E"
CXX17FLAGS=`"${R_HOME}"/bin/R CMD config CXX17FLAGS`
CXX17STD=`"${R_HOME}"/bin/R CMD config CXX17STD`
CPPFLAGS=`"${R_HOME}"/bin/R CMD config CPPFLAGS`
TEST_CMD="${CXX17} ${CPPFLAGS} ${PKG_CFLAGS} ${CXX17FLAGS} ${CXX17STD} -xc++ -"
echo "#include $PKG_TEST_HEADER" | ${TEST_CMD} >/dev/null 2>&1

if [ $? -eq 0 ]; then
  # Great! We have successfully found or built libarrow!
  # Now we need to check what features it was built with and enable
  # the corresponding feature flags in the R bindings (-DARROW_R_WITH_stuff).
  # We do this by inspecting ArrowOptions.cmake, which the libarrow build
  # generates.
  ARROW_OPTS_CMAKE="$LIB_DIR/cmake/Arrow/ArrowOptions.cmake"
  if [ ! -f "${ARROW_OPTS_CMAKE}" ]; then
    echo "*** $ARROW_OPTS_CMAKE not found; some features will not be enabled"
  fi

  arrow_built_with() {
    # Function to check cmake options for features
    grep -i 'set('"$1"' "ON")' $ARROW_OPTS_CMAKE >/dev/null 2>&1
  }

  if arrow_built_with ARROW_PARQUET; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_PARQUET"
    PKG_LIBS="-lparquet $PKG_LIBS"
    # NOTE: parquet is assumed to have the same -L flag as arrow
    # so there is no need to add its location to PKG_DIRS
  fi
  if arrow_built_with ARROW_DATASET; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_DATASET"
    PKG_LIBS="-larrow_dataset $PKG_LIBS"
    # NOTE: arrow-dataset is assumed to have the same -L flag as arrow
    # so there is no need to add its location to PKG_DIRS
  fi
  if arrow_built_with ARROW_ACERO; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_ACERO"
    PKG_LIBS="-larrow_acero $PKG_LIBS"
    # NOTE: arrow-acero is assumed to have the same -L flag as arrow
    # so there is no need to add its location to PKG_DIRS
  fi
  if arrow_built_with ARROW_SUBSTRAIT; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_SUBSTRAIT"
    PKG_LIBS="-larrow_substrait $PKG_LIBS"
    # NOTE: arrow-substrait is assumed to have the same -L flag as arrow
    # so there is no need to add its location to PKG_DIRS
  fi
  if arrow_built_with ARROW_JSON; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_JSON"
  fi
  if arrow_built_with ARROW_S3; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_S3"
    PKG_LIBS="$PKG_LIBS $S3_LIBS"
  fi
  if arrow_built_with ARROW_GCS; then
    PKG_CFLAGS="$PKG_CFLAGS -DARROW_R_WITH_GCS"
    PKG_LIBS="$PKG_LIBS $GCS_LIBS"
  fi

  # prepend PKG_DIRS to PKG_LIBS
  PKG_LIBS="$PKG_DIRS $PKG_LIBS"
  echo "PKG_CFLAGS=$PKG_CFLAGS"
  echo "PKG_LIBS=$PKG_LIBS"
else
  echo "------------------------- NOTE ---------------------------"
  echo "There was an issue preparing the Arrow C++ libraries."
  echo "See https://arrow.apache.org/docs/r/articles/install.html"
  echo "---------------------------------------------------------"
  PKG_LIBS=""
  PKG_CFLAGS=""
  exit 1

fi

# Write to Makevars
sed -e "s|@cflags@|$PKG_CFLAGS|" -e "s|@libs@|$PKG_LIBS|" src/Makevars.in > src/Makevars

# Success
exit 0
