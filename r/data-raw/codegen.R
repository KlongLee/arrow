# pak::pkg_install("romainfrancois/decor")
library(decor)

# pak::pkg_install("romainfrancois/rap")
library(rap)

library(dplyr)
library(stringr)
library(purrr)
library(glue)

decorations <- cpp_decorations() %>%
  filter(decoration == "arrow::export") %>%
  rap(            ~ decor:::parse_cpp_function(context))

glue_collapse_or_empty <- function(...) {
  res <- glue_collapse(...)
  if(length(res)) {
    res
  } else {
    ""
  }
}

sexp_params <- function(args){
  glue_collapse_or_empty(glue_data(args, "SEXP {name}_sexp"), sep = ", ")
}

real_params <- function(args){
  glue_collapse_or_empty(glue_data(args, "{type} {name}"), sep = ", ")
}

input_params <- function(args) {
  glue_collapse_or_empty(
    glue_data(args, "Rcpp::traits::input_parameter<{type}>::type {name}({name}_sexp);"),
    sep = "\n"
  )
}

list_params <- function(args) {
  glue_collapse_or_empty(
    glue_data(args, "{name}"),
    sep = ", "
  )
}

wrap_call <- function(name, return_type, args) {
  call <- glue::glue('{name}( {list_params(args)})')
  if(return_type == "void") {
    glue::glue("{call};\n return R_NilValue;")
  } else {
    glue::glue("Rcpp::Shield<SEXP> rcpp_result_gen(Rcpp::wrap({call}));\n return rcpp_result_gen;")
  }
}

cpp_function_definitions <- function(name, return_type, args) {
  glue::glue(
    '
    #if defined(ARROW_R_WITH_ARROW)
    {return_type} {name}({real_params(args)});
    SEXP _arrow_{name}({sexp_params(args)}){{
      BEGIN_RCPP
      {input_params(args)}{wrap_call(name, return_type, args)}
      END_RCPP
    }}
    #else
    SEXP _arrow_{name}({sexp_params(args)}){{
      BEGIN_RCPP
      Rcpp::stop("arrow C++ library not available");
      END_RCPP
    }}
    #endif

    ',
    sep = "\n"
  )
}

definitions <- wap(decorations,
  character() ~ cpp_function_definitions(name, return_type, args)
) %>%
  glue_collapse(sep  = "\n")

registration <- wap(decorations,
  character() ~ glue('\t\t{{ "_arrow_{name}", (DL_FUNC)& _arrow_{name}, {nrow(args)} }}, ')
) %>%
  glue_collapse(sep  = "\n")


writeLines(glue::glue('
// Generated by using data-raw/codegen.R -> do not edit by hand
#include "./arrow_types.h"
#include <Rcpp.h>

using namespace Rcpp;

{definitions}

extern "C" SEXP _arrow_available() {{
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_ARROW)
  TRUE
#else
  FALSE
#endif
);
}}

static const R_CallMethodDef arrow_CallEntries[] = {{
\t\t{{ "_arrow_available", (DL_FUNC)& _arrow_available, 0 }},
{registration}
\t\t{{NULL, NULL, 0}}
}};

extern "C" void R_init_arrow(DllInfo* dll){{
  R_registerRoutines(dll, NULL, arrow_CallEntries, NULL, NULL);
  R_useDynamicSymbols(dll, FALSE);
}}

'), "src/generated.cpp")


r_function <- function(name, return_type, args) {
  formals <- list_params(args)
  params <- if (nrow(args)) {
    paste0(", ", list_params(args))
  } else {
    ""
  }
  call <- if(return_type == "void") {
    glue::glue('invisible(.Call(`_arrow_{name}` {params} ))')
  } else {
    glue::glue('.Call(`_arrow_{name}` {params} )')
  }

  glue::glue(
    '
    {name} <- function({list_params(args)}) {{
        {call}
    }}

    ',
    sep = "\n"
  )
}

rfunctions <- wap(decorations,
  character() ~ r_function(name, return_type, args)
) %>%
  glue_collapse(sep  = "\n")

writeLines(glue::glue('
# Generated by using data-raw/codegen.R -> do not edit by hand

{rfunctions}

'), "R/generated.R")



