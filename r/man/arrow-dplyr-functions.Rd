% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr-funcs-doc.R
\name{arrow-dplyr-functions}
\alias{arrow-dplyr-functions}
\title{Functions available in Arrow dplyr queries}
\description{
The \code{arrow} package contains methods for 32 \code{dplyr} table functions, many of
which are "verbs" that do transformations to one or more tables.
The package also has mappings of 204 R functions to the corresponding
functions in the Arrow compute library. These allow you to write code inside
of \code{dplyr} methods that call R functions, including many in packages like
\code{stringr} and \code{lubridate}, and they will get translated to Arrow and run
on the Arrow query engine (Acero). This document lists all of the mapped
functions.
}
\section{\code{dplyr} verbs}{
Most verb functions return an \code{arrow_dplyr_query} object, similar in spirit
to a \code{dbplyr::tbl_lazy}. This means that the verbs do not eagerly evaluate
the query on the data. To run the query, call either \code{compute()},
which returns an \code{arrow} \link{Table}, or \code{collect()}, which pulls the resulting
Table into an R \code{data.frame}.
\itemize{
\item \link[dplyr:filter-joins]{anti_join}
\item \link[dplyr:arrange]{arrange}
\item \link[dplyr:compute]{collapse}
\item \link[dplyr:compute]{collect}
\item \link[dplyr:compute]{compute}
\item \link[dplyr:count]{count}
\item \link[dplyr:distinct]{distinct}
\item \link[dplyr:explain]{explain}
\item \link[dplyr:filter]{filter}
\item \link[dplyr:mutate-joins]{full_join}
\item \link[dplyr:glimpse]{glimpse}
\item \link[dplyr:group_by]{group_by}
\item \link[dplyr:group_by_drop_default]{group_by_drop_default}
\item \link[dplyr:group_data]{group_vars}
\item \link[dplyr:group_data]{groups}
\item \link[dplyr:mutate-joins]{inner_join}
\item \link[dplyr:mutate-joins]{left_join}
\item \link[dplyr:mutate]{mutate}
\item \link[dplyr:pull]{pull}
\item \link[dplyr:relocate]{relocate}
\item \link[dplyr:rename]{rename}
\item \link[dplyr:rename]{rename_with}
\item \link[dplyr:mutate-joins]{right_join}
\item \link[dplyr:select]{select}
\item \link[dplyr:filter-joins]{semi_join}
\item \link[dplyr:explain]{show_query}
\item \link[dplyr:summarise]{summarise}
\item \link[dplyr:count]{tally}
\item \link[dplyr:mutate]{transmute}
\item \link[dplyr:group_by]{ungroup}
\item \link[dplyr:reexports]{union}
\item \link[dplyr:setops]{union_all}
}
}

\section{Function mappings}{
In the list below, any differences in behavior or support between Acero and
the R function are listed. If no notes follow the function name, then you
can assume that the function works in Acero just as it does in R.

Functions can be called either as \code{pkg::fun()} or just \code{fun()}, i.e. both
\code{str_sub()} and \code{stringr::str_sub()} work.

In addition to these functions, you can call any of Arrow's 243 compute
functions directly. Arrow has many functions that don't map to an existing R
function. In other cases where there is an R function mapping, you can still
call the Arrow function directly if you don't want the adaptations that the R
mapping has that make Acero behave like R. These functions are listed in the
\href{https://arrow.apache.org/docs/cpp/compute.html}{C++ documentation}, and
in the function registry in R, they are named with an \code{arrow_} prefix, such
as \code{arrow_ascii_is_decimal}.
\subsection{arrow}{
\itemize{
\item \link[=add_filename]{add_filename}
\item \link[=cast]{cast}
}
}

\subsection{base}{
\itemize{
\item \link[=-]{-}
\item \link[=!]{!}
\item \link[=!=]{!=}
\item \link[=*]{*}
\item \link[=/]{/}
\item \link[=&]{&}
\item \link[=\%/\%]{\%/\%}
\item \link[=\%\%]{\%\%}
\item \link[=\%in\%]{\%in\%}
\item \link[=^]{^}
\item \link[=+]{+}
\item \link[=<]{<}
\item \link[=<=]{<=}
\item \link[===]{==}
\item \link[=>]{>}
\item \link[=>=]{>=}
\item \link[=|]{|}
\item \link[base:MathFun]{abs}
\item \link[base:Trig]{acos}
\item \link[base:all]{all}
\item \link[base:any]{any}
\item \link[base:character]{as.character}
\item \link[base:as.Date]{as.Date}
\item \link[base:difftime]{as.difftime}
\item \link[base:double]{as.double}
\item \link[base:integer]{as.integer}
\item \link[base:logical]{as.logical}
\item \link[base:numeric]{as.numeric}
\item \link[base:Trig]{asin}
\item \link[base:Round]{ceiling}
\item \link[base:Trig]{cos}
\item \link[base:data.frame]{data.frame}
\item \link[base:difftime]{difftime}
\item \link[base:startsWith]{endsWith}
\item \link[base:Log]{exp}
\item \link[base:Round]{floor}
\item \link[base:format]{format}
\item \link[base:grep]{grepl}
\item \link[base:grep]{gsub}
\item \link[base:ifelse]{ifelse}
\item \link[base:character]{is.character}
\item \link[base:double]{is.double}
\item \link[base:factor]{is.factor}
\item \link[base:is.finite]{is.finite}
\item \link[base:is.finite]{is.infinite}
\item \link[base:integer]{is.integer}
\item \link[base:list]{is.list}
\item \link[base:logical]{is.logical}
\item \link[base:NA]{is.na}
\item \link[base:is.finite]{is.nan}
\item \link[base:numeric]{is.numeric}
\item \link[base:ISOdatetime]{ISOdate}
\item \link[base:ISOdatetime]{ISOdatetime}
\item \link[base:Log]{log}
\item \link[base:Log]{log10}
\item \link[base:Log]{log1p}
\item \link[base:Log]{log2}
\item \link[base:Log]{logb}
\item \link[base:Extremes]{max}
\item \link[base:mean]{mean}
\item \link[base:Extremes]{min}
\item \link[base:nchar]{nchar}
\item \link[base:paste]{paste}: the \code{collapse} argument is not yet supported
\item \link[base:paste]{paste0}: the \code{collapse} argument is not yet supported
\item \link[base:Extremes]{pmax}
\item \link[base:Extremes]{pmin}
\item \link[base:Round]{round}
\item \link[base:sign]{sign}
\item \link[base:Trig]{sin}
\item \link[base:MathFun]{sqrt}
\item \link[base:startsWith]{startsWith}
\item \link[base:strptime]{strftime}
\item \link[base:strptime]{strptime}
\item \link[base:strrep]{strrep}
\item \link[base:strsplit]{strsplit}
\item \link[base:grep]{sub}
\item \link[base:substr]{substr}
\item \link[base:substr]{substring}
\item \link[base:sum]{sum}
\item \link[base:Trig]{tan}
\item \link[base:chartr]{tolower}
\item \link[base:chartr]{toupper}
\item \link[base:Round]{trunc}
}
}

\subsection{bit64}{
\itemize{
\item \link[bit64:as.integer64.character]{as.integer64}
\item \link[bit64:bit64-package]{is.integer64}
}
}

\subsection{dplyr}{
\itemize{
\item \link[dplyr:across]{across}: only supported inside \code{mutate()}; purrr-style lambda functions not yet supported
\item \link[dplyr:between]{between}
\item \link[dplyr:case_when]{case_when}
\item \link[dplyr:coalesce]{coalesce}
\item \link[dplyr:if_else]{if_else}
\item \link[dplyr:context]{n}
\item \link[dplyr:n_distinct]{n_distinct}
}
}

\subsection{lubridate}{
\itemize{
\item \link[lubridate:am]{am}
\item \link[lubridate:as_date]{as_date}
\item \link[lubridate:as_date]{as_datetime}
\item \link[lubridate:round_date]{ceiling_date}
\item \link[lubridate:date]{date}
\item \link[lubridate:date_decimal]{date_decimal}
\item \link[lubridate:day]{day}
\item \link[lubridate:duration]{ddays}
\item \link[lubridate:decimal_date]{decimal_date}
\item \link[lubridate:duration]{dhours}
\item \link[lubridate:duration]{dmicroseconds}
\item \link[lubridate:duration]{dmilliseconds}
\item \link[lubridate:duration]{dminutes}
\item \link[lubridate:duration]{dmonths}
\item \link[lubridate:ymd]{dmy}
\item \link[lubridate:ymd_hms]{dmy_h}
\item \link[lubridate:ymd_hms]{dmy_hm}
\item \link[lubridate:ymd_hms]{dmy_hms}
\item \link[lubridate:duration]{dnanoseconds}
\item \link[lubridate:duration]{dpicoseconds}
\item \link[lubridate:duration]{dseconds}
\item \link[lubridate:dst]{dst}
\item \link[lubridate:duration]{dweeks}
\item \link[lubridate:duration]{dyears}
\item \link[lubridate:ymd]{dym}
\item \link[lubridate:week]{epiweek}
\item \link[lubridate:year]{epiyear}
\item \link[lubridate:parse_date_time]{fast_strptime}
\item \link[lubridate:round_date]{floor_date}
\item \link[lubridate:format_ISO8601]{format_ISO8601}
\item \link[lubridate:hour]{hour}
\item \link[lubridate:date_utils]{is.Date}
\item \link[lubridate:is.instant]{is.instant}
\item \link[lubridate:posix_utils]{is.POSIXct}
\item \link[lubridate:is.instant]{is.timepoint}
\item \link[lubridate:week]{isoweek}
\item \link[lubridate:year]{isoyear}
\item \link[lubridate:leap_year]{leap_year}
\item \link[lubridate:make_datetime]{make_date}
\item \link[lubridate:make_datetime]{make_datetime}
\item \link[lubridate:make_difftime]{make_difftime}
\item \link[lubridate:day]{mday}
\item \link[lubridate:ymd]{mdy}
\item \link[lubridate:ymd_hms]{mdy_h}
\item \link[lubridate:ymd_hms]{mdy_hm}
\item \link[lubridate:ymd_hms]{mdy_hms}
\item \link[lubridate:minute]{minute}
\item \link[lubridate:month]{month}
\item \link[lubridate:ymd]{my}
\item \link[lubridate:ymd]{myd}
\item \link[lubridate:parse_date_time]{parse_date_time}
\item \link[lubridate:am]{pm}
\item \link[lubridate:day]{qday}
\item \link[lubridate:quarter]{quarter}
\item \link[lubridate:round_date]{round_date}
\item \link[lubridate:second]{second}
\item \link[lubridate:quarter]{semester}
\item \link[lubridate:tz]{tz}
\item \link[lubridate:day]{wday}
\item \link[lubridate:week]{week}
\item \link[lubridate:day]{yday}
\item \link[lubridate:ymd]{ydm}
\item \link[lubridate:ymd_hms]{ydm_h}
\item \link[lubridate:ymd_hms]{ydm_hm}
\item \link[lubridate:ymd_hms]{ydm_hms}
\item \link[lubridate:year]{year}
\item \link[lubridate:ymd]{ym}
\item \link[lubridate:ymd]{ymd}
\item \link[lubridate:ymd_hms]{ymd_h}
\item \link[lubridate:ymd_hms]{ymd_hm}
\item \link[lubridate:ymd_hms]{ymd_hms}
\item \link[lubridate:ymd]{yq}
}
}

\subsection{methods}{
\itemize{
\item \link[methods:is]{is}
}
}

\subsection{rlang}{
\itemize{
\item \link[rlang:type-predicates]{is_character}
\item \link[rlang:type-predicates]{is_double}
\item \link[rlang:type-predicates]{is_integer}
\item \link[rlang:type-predicates]{is_list}
\item \link[rlang:type-predicates]{is_logical}
}
}

\subsection{stats}{
\itemize{
\item \link[stats:median]{median}
\item \link[stats:quantile]{quantile}
\item \link[stats:sd]{sd}
\item \link[stats:cor]{var}
}
}

\subsection{stringi}{
\itemize{
\item \link[stringi:stri_reverse]{stri_reverse}
}
}

\subsection{stringr}{
\itemize{
\item \link[stringr:str_c]{str_c}: the \code{collapse} argument is not yet supported
\item \link[stringr:str_count]{str_count}
\item \link[stringr:str_detect]{str_detect}
\item \link[stringr:str_dup]{str_dup}
\item \link[stringr:str_starts]{str_ends}
\item \link[stringr:str_length]{str_length}
\item \code{str_like}: not yet in a released version of \code{stringr}, but it is supported in \code{arrow}
\item \link[stringr:str_pad]{str_pad}
\item \link[stringr:str_replace]{str_replace}
\item \link[stringr:str_replace]{str_replace_all}
\item \link[stringr:str_split]{str_split}
\item \link[stringr:str_starts]{str_starts}
\item \link[stringr:str_sub]{str_sub}
\item \link[stringr:case]{str_to_lower}
\item \link[stringr:case]{str_to_title}
\item \link[stringr:case]{str_to_upper}
\item \link[stringr:str_trim]{str_trim}
}
}

\subsection{tibble}{
\itemize{
\item \link[tibble:tibble]{tibble}
}
}

\subsection{tidyselect}{
\itemize{
\item \link[tidyselect:all_of]{all_of}
\item \link[tidyselect:starts_with]{contains}
\item \link[tidyselect:starts_with]{ends_with}
\item \link[tidyselect:everything]{everything}
\item \link[tidyselect:everything]{last_col}
\item \link[tidyselect:starts_with]{matches}
\item \link[tidyselect:starts_with]{num_range}
\item \link[tidyselect:one_of]{one_of}
\item \link[tidyselect:starts_with]{starts_with}
}
}
}

