% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.R
\name{register_user_defined_function}
\alias{register_user_defined_function}
\alias{arrow_scalar_function}
\title{Register user-defined functions}
\usage{
register_user_defined_function(scalar_function, name)

arrow_scalar_function(fun, in_type, out_type, auto_convert = FALSE)
}
\arguments{
\item{scalar_function}{An object created with \code{\link[=arrow_scalar_function]{arrow_scalar_function()}}
Scalar functions must be stateless and return output with the same
shape (i.e., the same number of rows) as the input.}

\item{name}{The function name to be used in the dplyr bindings}

\item{fun}{An R function or rlang-style lambda expression. The function
will be called with a first argument \code{context} which is a \code{list()}
with elements \code{batch_size} (the expected length of the output) and
\code{output_type} (the required \link{DataType} of the output). Subsequent
arguments are passed by position as specified by \code{in_types}. If
\code{auto_convert} is \code{TRUE}, subsequent arguments are converted to
R vectors before being passed to \code{fun} and the output is automatically
constructed with the expected output type via \code{\link[=as_arrow_array]{as_arrow_array()}}.}

\item{in_type}{A \link{DataType} of the input type or a \code{\link[=schema]{schema()}}
for functions with more than one argument. This signature will be used
to determine if this function is appropriate for a given set of arguments.
If this function is appropriate for more than one signature, pass a
\code{list()} of the above.}

\item{out_type}{A \link{DataType} of the output type or a function accepting
a single argument (\code{types}), which is a \code{list()} of \link{DataType}s. If a
function it must return a \link{DataType}.}

\item{auto_convert}{Use \code{TRUE} to convert inputs before passing to \code{fun}
and construct an Array of the correct type from the output. Use this
option to write functions of R objects as opposed to functions of
Arrow R6 objects.}
}
\value{
\itemize{
\item \code{register_user_defined_function()}: \code{NULL}, invisibly
\item \code{arrow_scalar_function()}: returns an object of class
"arrow_scalar_function" that can be passed to
\code{register_user_defined_function()}.
}
}
\description{
These functions support calling R code from query engine execution
(i.e., a \code{\link[dplyr:mutate]{dplyr::mutate()}} or \code{\link[dplyr:filter]{dplyr::filter()}} on a \link{Table} or \link{Dataset}).
Use \code{\link[=arrow_scalar_function]{arrow_scalar_function()}} attach input and output types to a vectorized
R function; use \code{\link[=register_user_defined_function]{register_user_defined_function()}} to make it available
for use in the dplyr interface and/or \code{\link[=call_function]{call_function()}}.
}
\examples{
\dontshow{if (arrow_with_dataset()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
fun_wrapper <- arrow_scalar_function(
  function(context, x, y, z) x + y + z,
  schema(x = float64(), y = float64(), z = float64()),
  float64(),
  auto_convert = TRUE
)
register_user_defined_function(fun_wrapper, "example_add3")

call_function(
  "example_add3",
  Scalar$create(1),
  Scalar$create(2),
  Array$create(3)
)
\dontshow{\}) # examplesIf}
}
