% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extension.R
\name{new_extension_type}
\alias{new_extension_type}
\alias{new_extension_array}
\alias{register_extension_type}
\alias{reregister_extension_type}
\alias{unregister_extension_type}
\title{Extension types}
\usage{
new_extension_type(
  storage_type,
  extension_name,
  extension_metadata,
  type_class = ExtensionType
)

new_extension_array(storage_array, extension_type)

register_extension_type(extension_type)

reregister_extension_type(extension_type)

unregister_extension_type(extension_name)
}
\arguments{
\item{storage_type}{The \link[=data-type]{data type} of the underlying storage
array.}

\item{extension_name}{The extension name. This should be namespaced using
"dot" syntax (i.e., "some_package.some_type"). The namespace "arrow"
is reserved for extension types defined by the Apache Arrow libraries.}

\item{extension_metadata}{A \code{\link[=raw]{raw()}} vector containing the serialized
version of the type.}

\item{type_class}{An \link[R6:R6Class]{R6::R6Class} whose \verb{$new()} class method will be
used to construct a new instance of the type.}

\item{storage_array}{An \link{Array} object of the underlying storage.}

\item{extension_type}{An \link{ExtensionType} instance.}
}
\value{
\itemize{
\item \code{new_extension_type()} returns an \link{ExtensionType} instance according
to the \code{type_class} specified.
\item \code{new_extension_array()} returns an \link{ExtensionArray} whose \verb{$type}
corresponds to \code{extension_type}.
\item \code{register_extension_type()} and \code{reregister_extension_type()} return
\code{extension_type}, invisibly.
\item \code{unregister_extension_type()} returns the previously registered
\code{extension_type} (invisibly) or \code{NULL} if no type was previously
registered.
}
}
\description{
Extension arrays are wrappers around regular Arrow \link{Array} objects
that provide some customized behaviour and/or storage. A common use-case
for extension types is to define a customized conversion between an
an Arrow \link{Array} and an R object when the default conversion is slow
or looses metadata important to the interpretation of values in the array.
For most types, the built-in
\link[=vctrs_extension_type]{vctrs extension type} is probably sufficient.
}
\details{
These functions create, register, and unregister \link{ExtensionType}
and \link{ExtensionArray} objects. To use an extension type you will have to:
\itemize{
\item Define an \link[R6:R6Class]{R6::R6Class} that inherits from \link{ExtensionType} and reimplement
one or more methods (e.g., \code{.Deserialize()}).
\item Register a dummy instance of your extension type created using
\code{\link[=new_extension_type]{new_extension_type()}} using \code{\link[=register_extension_type]{register_extension_type()}}.
}

If defining an extension type in an R package, you will probably want to
use \code{\link[=reregister_extension_type]{reregister_extension_type()}} in that package's \code{\link[=.onLoad]{.onLoad()}} hook
since your package will probably get reloaded in the same R session
during its development and \code{\link[=register_extension_type]{register_extension_type()}} will error if
called twice for the same \code{extension_name}.
}
