// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_
#define FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {
namespace computeir {

struct Int8Buffer;
struct Int8BufferBuilder;

struct Int16Buffer;
struct Int16BufferBuilder;

struct Int32Buffer;
struct Int32BufferBuilder;

struct Int64Buffer;
struct Int64BufferBuilder;

struct UInt8Buffer;
struct UInt8BufferBuilder;

struct UInt16Buffer;
struct UInt16BufferBuilder;

struct UInt32Buffer;
struct UInt32BufferBuilder;

struct UInt64Buffer;
struct UInt64BufferBuilder;

struct Float32Buffer;
struct Float32BufferBuilder;

struct Float64Buffer;
struct Float64BufferBuilder;

struct TableBuffer;
struct TableBufferBuilder;

struct InlineBuffer;
struct InlineBufferBuilder;

struct Expression;
struct ExpressionBuilder;

struct Scalar;
struct ScalarBuilder;

struct Array;
struct ArrayBuilder;

struct Literal;
struct LiteralBuilder;

struct FieldRef;
struct FieldRefBuilder;

struct CanonicalFunction;
struct CanonicalFunctionBuilder;

struct NonCanonicalFunction;
struct NonCanonicalFunctionBuilder;

struct Call;
struct CallBuilder;

struct CanonicalOperation;
struct CanonicalOperationBuilder;

struct NonCanonicalOperation;
struct NonCanonicalOperationBuilder;

struct Relation;
struct RelationBuilder;

struct FilterOptions;
struct FilterOptionsBuilder;

struct ProjectOptions;
struct ProjectOptionsBuilder;

struct AggregateOptions;
struct AggregateOptionsBuilder;

struct CanonicalJoinKind;
struct CanonicalJoinKindBuilder;

struct NonCanonicalJoinKind;
struct NonCanonicalJoinKindBuilder;

struct JoinOptions;
struct JoinOptionsBuilder;

struct SortKey;
struct SortKeyBuilder;

struct OrderByOptions;
struct OrderByOptionsBuilder;

struct LimitOptions;
struct LimitOptionsBuilder;

struct CommonOptions;
struct CommonOptionsBuilder;

struct UnionOptions;
struct UnionOptionsBuilder;

struct LiteralOptions;
struct LiteralOptionsBuilder;

struct Plan;
struct PlanBuilder;

enum class InlineBufferImpl : uint8_t {
  NONE = 0,
  Int8Buffer = 1,
  Int16Buffer = 2,
  Int32Buffer = 3,
  Int64Buffer = 4,
  UInt8Buffer = 5,
  UInt16Buffer = 6,
  UInt32Buffer = 7,
  UInt64Buffer = 8,
  Float32Buffer = 9,
  Float64Buffer = 10,
  TableBuffer = 11,
  MIN = NONE,
  MAX = TableBuffer
};

inline const InlineBufferImpl (&EnumValuesInlineBufferImpl())[12] {
  static const InlineBufferImpl values[] = {
    InlineBufferImpl::NONE,
    InlineBufferImpl::Int8Buffer,
    InlineBufferImpl::Int16Buffer,
    InlineBufferImpl::Int32Buffer,
    InlineBufferImpl::Int64Buffer,
    InlineBufferImpl::UInt8Buffer,
    InlineBufferImpl::UInt16Buffer,
    InlineBufferImpl::UInt32Buffer,
    InlineBufferImpl::UInt64Buffer,
    InlineBufferImpl::Float32Buffer,
    InlineBufferImpl::Float64Buffer,
    InlineBufferImpl::TableBuffer
  };
  return values;
}

inline const char * const *EnumNamesInlineBufferImpl() {
  static const char * const names[13] = {
    "NONE",
    "Int8Buffer",
    "Int16Buffer",
    "Int32Buffer",
    "Int64Buffer",
    "UInt8Buffer",
    "UInt16Buffer",
    "UInt32Buffer",
    "UInt64Buffer",
    "Float32Buffer",
    "Float64Buffer",
    "TableBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameInlineBufferImpl(InlineBufferImpl e) {
  if (flatbuffers::IsOutRange(e, InlineBufferImpl::NONE, InlineBufferImpl::TableBuffer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInlineBufferImpl()[index];
}

template<typename T> struct InlineBufferImplTraits {
  static const InlineBufferImpl enum_value = InlineBufferImpl::NONE;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Int8Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int8Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Int16Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int16Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Int32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Int64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::UInt8Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt8Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::UInt16Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt16Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::UInt32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::UInt64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Float32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Float32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::Float64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Float64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::flatbuf::computeir::TableBuffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::TableBuffer;
};

bool VerifyInlineBufferImpl(flatbuffers::Verifier &verifier, const void *obj, InlineBufferImpl type);
bool VerifyInlineBufferImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// An expression is one of
/// - a Literal datum
/// - a reference to a Field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
enum class ExpressionImpl : uint8_t {
  NONE = 0,
  Literal = 1,
  FieldRef = 2,
  Call = 3,
  MIN = NONE,
  MAX = Call
};

inline const ExpressionImpl (&EnumValuesExpressionImpl())[4] {
  static const ExpressionImpl values[] = {
    ExpressionImpl::NONE,
    ExpressionImpl::Literal,
    ExpressionImpl::FieldRef,
    ExpressionImpl::Call
  };
  return values;
}

inline const char * const *EnumNamesExpressionImpl() {
  static const char * const names[5] = {
    "NONE",
    "Literal",
    "FieldRef",
    "Call",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpressionImpl(ExpressionImpl e) {
  if (flatbuffers::IsOutRange(e, ExpressionImpl::NONE, ExpressionImpl::Call)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpressionImpl()[index];
}

template<typename T> struct ExpressionImplTraits {
  static const ExpressionImpl enum_value = ExpressionImpl::NONE;
};

template<> struct ExpressionImplTraits<org::apache::arrow::flatbuf::computeir::Literal> {
  static const ExpressionImpl enum_value = ExpressionImpl::Literal;
};

template<> struct ExpressionImplTraits<org::apache::arrow::flatbuf::computeir::FieldRef> {
  static const ExpressionImpl enum_value = ExpressionImpl::FieldRef;
};

template<> struct ExpressionImplTraits<org::apache::arrow::flatbuf::computeir::Call> {
  static const ExpressionImpl enum_value = ExpressionImpl::Call;
};

bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type);
bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Shape : uint8_t {
  NONE = 0,
  Array = 1,
  Scalar = 2,
  MIN = NONE,
  MAX = Scalar
};

inline const Shape (&EnumValuesShape())[3] {
  static const Shape values[] = {
    Shape::NONE,
    Shape::Array,
    Shape::Scalar
  };
  return values;
}

inline const char * const *EnumNamesShape() {
  static const char * const names[4] = {
    "NONE",
    "Array",
    "Scalar",
    nullptr
  };
  return names;
}

inline const char *EnumNameShape(Shape e) {
  if (flatbuffers::IsOutRange(e, Shape::NONE, Shape::Scalar)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShape()[index];
}

template<typename T> struct ShapeTraits {
  static const Shape enum_value = Shape::NONE;
};

template<> struct ShapeTraits<org::apache::arrow::flatbuf::computeir::Array> {
  static const Shape enum_value = Shape::Array;
};

template<> struct ShapeTraits<org::apache::arrow::flatbuf::computeir::Scalar> {
  static const Shape enum_value = Shape::Scalar;
};

bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type);
bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A canonical (probably SQL equivalent) function
enum class CanonicalFunctionId : uint32_t {
  And = 0,
  Not = 1,
  Or = 2,
  Add = 3,
  Subtract = 4,
  Multiply = 5,
  Divide = 6,
  Power = 7,
  AbsoluteValue = 8,
  Negate = 9,
  Sign = 10,
  Equal = 11,
  NotEqual = 12,
  Greater = 13,
  GreaterOrEqual = 14,
  Less = 15,
  LessOrEqual = 16,
  All = 17,
  Any = 18,
  Count = 19,
  Mean = 20,
  Min = 21,
  Max = 22,
  Mode = 23,
  Product = 24,
  Sum = 25,
  Tdigest = 26,
  Quantile = 27,
  Variance = 28,
  StandardDeviation = 29,
  MIN = And,
  MAX = StandardDeviation
};

inline const CanonicalFunctionId (&EnumValuesCanonicalFunctionId())[30] {
  static const CanonicalFunctionId values[] = {
    CanonicalFunctionId::And,
    CanonicalFunctionId::Not,
    CanonicalFunctionId::Or,
    CanonicalFunctionId::Add,
    CanonicalFunctionId::Subtract,
    CanonicalFunctionId::Multiply,
    CanonicalFunctionId::Divide,
    CanonicalFunctionId::Power,
    CanonicalFunctionId::AbsoluteValue,
    CanonicalFunctionId::Negate,
    CanonicalFunctionId::Sign,
    CanonicalFunctionId::Equal,
    CanonicalFunctionId::NotEqual,
    CanonicalFunctionId::Greater,
    CanonicalFunctionId::GreaterOrEqual,
    CanonicalFunctionId::Less,
    CanonicalFunctionId::LessOrEqual,
    CanonicalFunctionId::All,
    CanonicalFunctionId::Any,
    CanonicalFunctionId::Count,
    CanonicalFunctionId::Mean,
    CanonicalFunctionId::Min,
    CanonicalFunctionId::Max,
    CanonicalFunctionId::Mode,
    CanonicalFunctionId::Product,
    CanonicalFunctionId::Sum,
    CanonicalFunctionId::Tdigest,
    CanonicalFunctionId::Quantile,
    CanonicalFunctionId::Variance,
    CanonicalFunctionId::StandardDeviation
  };
  return values;
}

inline const char * const *EnumNamesCanonicalFunctionId() {
  static const char * const names[31] = {
    "And",
    "Not",
    "Or",
    "Add",
    "Subtract",
    "Multiply",
    "Divide",
    "Power",
    "AbsoluteValue",
    "Negate",
    "Sign",
    "Equal",
    "NotEqual",
    "Greater",
    "GreaterOrEqual",
    "Less",
    "LessOrEqual",
    "All",
    "Any",
    "Count",
    "Mean",
    "Min",
    "Max",
    "Mode",
    "Product",
    "Sum",
    "Tdigest",
    "Quantile",
    "Variance",
    "StandardDeviation",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalFunctionId(CanonicalFunctionId e) {
  if (flatbuffers::IsOutRange(e, CanonicalFunctionId::And, CanonicalFunctionId::StandardDeviation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalFunctionId()[index];
}

enum class Function : uint8_t {
  NONE = 0,
  CanonicalFunction = 1,
  NonCanonicalFunction = 2,
  MIN = NONE,
  MAX = NonCanonicalFunction
};

inline const Function (&EnumValuesFunction())[3] {
  static const Function values[] = {
    Function::NONE,
    Function::CanonicalFunction,
    Function::NonCanonicalFunction
  };
  return values;
}

inline const char * const *EnumNamesFunction() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalFunction",
    "NonCanonicalFunction",
    nullptr
  };
  return names;
}

inline const char *EnumNameFunction(Function e) {
  if (flatbuffers::IsOutRange(e, Function::NONE, Function::NonCanonicalFunction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFunction()[index];
}

template<typename T> struct FunctionTraits {
  static const Function enum_value = Function::NONE;
};

template<> struct FunctionTraits<org::apache::arrow::flatbuf::computeir::CanonicalFunction> {
  static const Function enum_value = Function::CanonicalFunction;
};

template<> struct FunctionTraits<org::apache::arrow::flatbuf::computeir::NonCanonicalFunction> {
  static const Function enum_value = Function::NonCanonicalFunction;
};

bool VerifyFunction(flatbuffers::Verifier &verifier, const void *obj, Function type);
bool VerifyFunctionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class CanonicalOperationId : uint32_t {
  Literal = 0,
  Filter = 1,
  Project = 2,
  Aggregate = 3,
  Join = 4,
  OrderBy = 5,
  Limit = 6,
  Common = 7,
  Union = 8,
  InteractiveOutput = 9,
  MIN = Literal,
  MAX = InteractiveOutput
};

inline const CanonicalOperationId (&EnumValuesCanonicalOperationId())[10] {
  static const CanonicalOperationId values[] = {
    CanonicalOperationId::Literal,
    CanonicalOperationId::Filter,
    CanonicalOperationId::Project,
    CanonicalOperationId::Aggregate,
    CanonicalOperationId::Join,
    CanonicalOperationId::OrderBy,
    CanonicalOperationId::Limit,
    CanonicalOperationId::Common,
    CanonicalOperationId::Union,
    CanonicalOperationId::InteractiveOutput
  };
  return values;
}

inline const char * const *EnumNamesCanonicalOperationId() {
  static const char * const names[11] = {
    "Literal",
    "Filter",
    "Project",
    "Aggregate",
    "Join",
    "OrderBy",
    "Limit",
    "Common",
    "Union",
    "InteractiveOutput",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalOperationId(CanonicalOperationId e) {
  if (flatbuffers::IsOutRange(e, CanonicalOperationId::Literal, CanonicalOperationId::InteractiveOutput)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalOperationId()[index];
}

enum class Operation : uint8_t {
  NONE = 0,
  CanonicalOperation = 1,
  NonCanonicalOperation = 2,
  MIN = NONE,
  MAX = NonCanonicalOperation
};

inline const Operation (&EnumValuesOperation())[3] {
  static const Operation values[] = {
    Operation::NONE,
    Operation::CanonicalOperation,
    Operation::NonCanonicalOperation
  };
  return values;
}

inline const char * const *EnumNamesOperation() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalOperation",
    "NonCanonicalOperation",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperation(Operation e) {
  if (flatbuffers::IsOutRange(e, Operation::NONE, Operation::NonCanonicalOperation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperation()[index];
}

template<typename T> struct OperationTraits {
  static const Operation enum_value = Operation::NONE;
};

template<> struct OperationTraits<org::apache::arrow::flatbuf::computeir::CanonicalOperation> {
  static const Operation enum_value = Operation::CanonicalOperation;
};

template<> struct OperationTraits<org::apache::arrow::flatbuf::computeir::NonCanonicalOperation> {
  static const Operation enum_value = Operation::NonCanonicalOperation;
};

bool VerifyOperation(flatbuffers::Verifier &verifier, const void *obj, Operation type);
bool VerifyOperationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class CanonicalJoinKindId : uint32_t {
  Inner = 0,
  LeftOuter = 1,
  RightOuter = 2,
  FullOuter = 3,
  Cross = 4,
  MIN = Inner,
  MAX = Cross
};

inline const CanonicalJoinKindId (&EnumValuesCanonicalJoinKindId())[5] {
  static const CanonicalJoinKindId values[] = {
    CanonicalJoinKindId::Inner,
    CanonicalJoinKindId::LeftOuter,
    CanonicalJoinKindId::RightOuter,
    CanonicalJoinKindId::FullOuter,
    CanonicalJoinKindId::Cross
  };
  return values;
}

inline const char * const *EnumNamesCanonicalJoinKindId() {
  static const char * const names[6] = {
    "Inner",
    "LeftOuter",
    "RightOuter",
    "FullOuter",
    "Cross",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalJoinKindId(CanonicalJoinKindId e) {
  if (flatbuffers::IsOutRange(e, CanonicalJoinKindId::Inner, CanonicalJoinKindId::Cross)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalJoinKindId()[index];
}

enum class JoinKind : uint8_t {
  NONE = 0,
  CanonicalJoinKind = 1,
  NonCanonicalJoinKind = 2,
  MIN = NONE,
  MAX = NonCanonicalJoinKind
};

inline const JoinKind (&EnumValuesJoinKind())[3] {
  static const JoinKind values[] = {
    JoinKind::NONE,
    JoinKind::CanonicalJoinKind,
    JoinKind::NonCanonicalJoinKind
  };
  return values;
}

inline const char * const *EnumNamesJoinKind() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalJoinKind",
    "NonCanonicalJoinKind",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinKind(JoinKind e) {
  if (flatbuffers::IsOutRange(e, JoinKind::NONE, JoinKind::NonCanonicalJoinKind)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinKind()[index];
}

template<typename T> struct JoinKindTraits {
  static const JoinKind enum_value = JoinKind::NONE;
};

template<> struct JoinKindTraits<org::apache::arrow::flatbuf::computeir::CanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::CanonicalJoinKind;
};

template<> struct JoinKindTraits<org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::NonCanonicalJoinKind;
};

bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type);
bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum class Ordering : uint8_t {
  ASCENDING_THEN_NULLS = 0,
  DESCENDING_THEN_NULLS = 1,
  NULLS_THEN_ASCENDING = 2,
  NULLS_THEN_DESCENDING = 3,
  MIN = ASCENDING_THEN_NULLS,
  MAX = NULLS_THEN_DESCENDING
};

inline const Ordering (&EnumValuesOrdering())[4] {
  static const Ordering values[] = {
    Ordering::ASCENDING_THEN_NULLS,
    Ordering::DESCENDING_THEN_NULLS,
    Ordering::NULLS_THEN_ASCENDING,
    Ordering::NULLS_THEN_DESCENDING
  };
  return values;
}

inline const char * const *EnumNamesOrdering() {
  static const char * const names[5] = {
    "ASCENDING_THEN_NULLS",
    "DESCENDING_THEN_NULLS",
    "NULLS_THEN_ASCENDING",
    "NULLS_THEN_DESCENDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrdering(Ordering e) {
  if (flatbuffers::IsOutRange(e, Ordering::ASCENDING_THEN_NULLS, Ordering::NULLS_THEN_DESCENDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrdering()[index];
}

struct Int8Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int8BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int8BufferBuilder {
  typedef Int8Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(Int8Buffer::VT_ITEMS, items);
  }
  explicit Int8BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int8BufferBuilder &operator=(const Int8BufferBuilder &);
  flatbuffers::Offset<Int8Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int8Buffer>(end);
    fbb_.Required(o, Int8Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int8Buffer> CreateInt8Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  Int8BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int8Buffer> CreateInt8BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateInt8Buffer(
      _fbb,
      items__);
}

struct Int16Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int16BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint16_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int16BufferBuilder {
  typedef Int16Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items) {
    fbb_.AddOffset(Int16Buffer::VT_ITEMS, items);
  }
  explicit Int16BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int16BufferBuilder &operator=(const Int16BufferBuilder &);
  flatbuffers::Offset<Int16Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int16Buffer>(end);
    fbb_.Required(o, Int16Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int16Buffer> CreateInt16Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items = 0) {
  Int16BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int16Buffer> CreateInt16BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint16_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateInt16Buffer(
      _fbb,
      items__);
}

struct Int32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int32BufferBuilder {
  typedef Int32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(Int32Buffer::VT_ITEMS, items);
  }
  explicit Int32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32BufferBuilder &operator=(const Int32BufferBuilder &);
  flatbuffers::Offset<Int32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Buffer>(end);
    fbb_.Required(o, Int32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int32Buffer> CreateInt32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items = 0) {
  Int32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Buffer> CreateInt32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateInt32Buffer(
      _fbb,
      items__);
}

struct Int64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int64BufferBuilder {
  typedef Int64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items) {
    fbb_.AddOffset(Int64Buffer::VT_ITEMS, items);
  }
  explicit Int64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int64BufferBuilder &operator=(const Int64BufferBuilder &);
  flatbuffers::Offset<Int64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int64Buffer>(end);
    fbb_.Required(o, Int64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int64Buffer> CreateInt64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items = 0) {
  Int64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int64Buffer> CreateInt64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint64_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateInt64Buffer(
      _fbb,
      items__);
}

struct UInt8Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt8BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt8BufferBuilder {
  typedef UInt8Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(UInt8Buffer::VT_ITEMS, items);
  }
  explicit UInt8BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt8BufferBuilder &operator=(const UInt8BufferBuilder &);
  flatbuffers::Offset<UInt8Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt8Buffer>(end);
    fbb_.Required(o, UInt8Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt8Buffer> CreateUInt8Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  UInt8BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt8Buffer> CreateUInt8BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateUInt8Buffer(
      _fbb,
      items__);
}

struct UInt16Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt16BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint16_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt16BufferBuilder {
  typedef UInt16Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items) {
    fbb_.AddOffset(UInt16Buffer::VT_ITEMS, items);
  }
  explicit UInt16BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt16BufferBuilder &operator=(const UInt16BufferBuilder &);
  flatbuffers::Offset<UInt16Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt16Buffer>(end);
    fbb_.Required(o, UInt16Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt16Buffer> CreateUInt16Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items = 0) {
  UInt16BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt16Buffer> CreateUInt16BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint16_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateUInt16Buffer(
      _fbb,
      items__);
}

struct UInt32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt32BufferBuilder {
  typedef UInt32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(UInt32Buffer::VT_ITEMS, items);
  }
  explicit UInt32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt32BufferBuilder &operator=(const UInt32BufferBuilder &);
  flatbuffers::Offset<UInt32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt32Buffer>(end);
    fbb_.Required(o, UInt32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt32Buffer> CreateUInt32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items = 0) {
  UInt32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt32Buffer> CreateUInt32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateUInt32Buffer(
      _fbb,
      items__);
}

struct UInt64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt64BufferBuilder {
  typedef UInt64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items) {
    fbb_.AddOffset(UInt64Buffer::VT_ITEMS, items);
  }
  explicit UInt64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt64BufferBuilder &operator=(const UInt64BufferBuilder &);
  flatbuffers::Offset<UInt64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt64Buffer>(end);
    fbb_.Required(o, UInt64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt64Buffer> CreateUInt64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items = 0) {
  UInt64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt64Buffer> CreateUInt64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint64_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateUInt64Buffer(
      _fbb,
      items__);
}

struct Float32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<float> *items() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Float32BufferBuilder {
  typedef Float32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<float>> items) {
    fbb_.AddOffset(Float32Buffer::VT_ITEMS, items);
  }
  explicit Float32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float32BufferBuilder &operator=(const Float32BufferBuilder &);
  flatbuffers::Offset<Float32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float32Buffer>(end);
    fbb_.Required(o, Float32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Float32Buffer> CreateFloat32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> items = 0) {
  Float32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float32Buffer> CreateFloat32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<float>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateFloat32Buffer(
      _fbb,
      items__);
}

struct Float64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<double> *items() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Float64BufferBuilder {
  typedef Float64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(Float64Buffer::VT_ITEMS, items);
  }
  explicit Float64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float64BufferBuilder &operator=(const Float64BufferBuilder &);
  flatbuffers::Offset<Float64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float64Buffer>(end);
    fbb_.Required(o, Float64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Float64Buffer> CreateFloat64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> items = 0) {
  Float64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float64Buffer> CreateFloat64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateFloat64Buffer(
      _fbb,
      items__);
}

struct TableBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  const org::apache::arrow::flatbuf::computeir::InlineBuffer *items_nested_root() const {
    return flatbuffers::GetRoot<org::apache::arrow::flatbuf::computeir::InlineBuffer>(items()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct TableBufferBuilder {
  typedef TableBuffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(TableBuffer::VT_ITEMS, items);
  }
  explicit TableBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableBufferBuilder &operator=(const TableBufferBuilder &);
  flatbuffers::Offset<TableBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableBuffer>(end);
    fbb_.Required(o, TableBuffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<TableBuffer> CreateTableBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  TableBufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableBuffer> CreateTableBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateTableBuffer(
      _fbb,
      items__);
}

/// An inline replacement for org.apache.arrow.Buffer because that
/// requires a sidecar block of bytes into which offsets can point.
/// A union of buffers of each primitive type is provided to avoid
/// the need for reinterpret_cast, std::mem::transmute, ...
/// The final member of the union is a bytes buffer aligned suitably
/// to hold any flatbuffer Table.
struct InlineBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InlineBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::flatbuf::computeir::InlineBufferImpl impl_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::InlineBufferImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::flatbuf::computeir::Int8Buffer *impl_as_Int8Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Int8Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Int8Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Int16Buffer *impl_as_Int16Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Int16Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Int16Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Int32Buffer *impl_as_Int32Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Int32Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Int32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Int64Buffer *impl_as_Int64Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Int64Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Int64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::UInt8Buffer *impl_as_UInt8Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::UInt8Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::UInt8Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::UInt16Buffer *impl_as_UInt16Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::UInt16Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::UInt16Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::UInt32Buffer *impl_as_UInt32Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::UInt32Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::UInt32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::UInt64Buffer *impl_as_UInt64Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::UInt64Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::UInt64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Float32Buffer *impl_as_Float32Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Float32Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Float32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Float64Buffer *impl_as_Float64Buffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::Float64Buffer ? static_cast<const org::apache::arrow::flatbuf::computeir::Float64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::TableBuffer *impl_as_TableBuffer() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::InlineBufferImpl::TableBuffer ? static_cast<const org::apache::arrow::flatbuf::computeir::TableBuffer *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyInlineBufferImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Int8Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Int8Buffer>() const {
  return impl_as_Int8Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Int16Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Int16Buffer>() const {
  return impl_as_Int16Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Int32Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Int32Buffer>() const {
  return impl_as_Int32Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Int64Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Int64Buffer>() const {
  return impl_as_Int64Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::UInt8Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::UInt8Buffer>() const {
  return impl_as_UInt8Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::UInt16Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::UInt16Buffer>() const {
  return impl_as_UInt16Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::UInt32Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::UInt32Buffer>() const {
  return impl_as_UInt32Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::UInt64Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::UInt64Buffer>() const {
  return impl_as_UInt64Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Float32Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Float32Buffer>() const {
  return impl_as_Float32Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Float64Buffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::Float64Buffer>() const {
  return impl_as_Float64Buffer();
}

template<> inline const org::apache::arrow::flatbuf::computeir::TableBuffer *InlineBuffer::impl_as<org::apache::arrow::flatbuf::computeir::TableBuffer>() const {
  return impl_as_TableBuffer();
}

struct InlineBufferBuilder {
  typedef InlineBuffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::flatbuf::computeir::InlineBufferImpl impl_type) {
    fbb_.AddElement<uint8_t>(InlineBuffer::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(InlineBuffer::VT_IMPL, impl);
  }
  explicit InlineBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InlineBufferBuilder &operator=(const InlineBufferBuilder &);
  flatbuffers::Offset<InlineBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InlineBuffer>(end);
    fbb_.Required(o, InlineBuffer::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<InlineBuffer> CreateInlineBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::InlineBufferImpl impl_type = org::apache::arrow::flatbuf::computeir::InlineBufferImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  InlineBufferBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

struct Expression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4,
    VT_IMPL_TYPE = 6,
    VT_IMPL = 8
  };
  /// The type of this literal. Field is used instead of Type to pick
  /// up child fields, dictionary encoding, etc.
  /// Field.name should always be absent since it is not meaningful
  /// for Expressions.
  const org::apache::arrow::flatbuf::Field *field() const {
    return GetPointer<const org::apache::arrow::flatbuf::Field *>(VT_FIELD);
  }
  org::apache::arrow::flatbuf::computeir::ExpressionImpl impl_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::ExpressionImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::flatbuf::computeir::Literal *impl_as_Literal() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::ExpressionImpl::Literal ? static_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::FieldRef *impl_as_FieldRef() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::ExpressionImpl::FieldRef ? static_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(impl()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Call *impl_as_Call() const {
    return impl_type() == org::apache::arrow::flatbuf::computeir::ExpressionImpl::Call ? static_cast<const org::apache::arrow::flatbuf::computeir::Call *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyExpressionImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Literal *Expression::impl_as<org::apache::arrow::flatbuf::computeir::Literal>() const {
  return impl_as_Literal();
}

template<> inline const org::apache::arrow::flatbuf::computeir::FieldRef *Expression::impl_as<org::apache::arrow::flatbuf::computeir::FieldRef>() const {
  return impl_as_FieldRef();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Call *Expression::impl_as<org::apache::arrow::flatbuf::computeir::Call>() const {
  return impl_as_Call();
}

struct ExpressionBuilder {
  typedef Expression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_field(flatbuffers::Offset<org::apache::arrow::flatbuf::Field> field) {
    fbb_.AddOffset(Expression::VT_FIELD, field);
  }
  void add_impl_type(org::apache::arrow::flatbuf::computeir::ExpressionImpl impl_type) {
    fbb_.AddElement<uint8_t>(Expression::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Expression::VT_IMPL, impl);
  }
  explicit ExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionBuilder &operator=(const ExpressionBuilder &);
  flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expression>(end);
    fbb_.Required(o, Expression::VT_FIELD);
    fbb_.Required(o, Expression::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Expression> CreateExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Field> field = 0,
    org::apache::arrow::flatbuf::computeir::ExpressionImpl impl_type = org::apache::arrow::flatbuf::computeir::ExpressionImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_field(field);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScalarBuilder {
  typedef Scalar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScalarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScalarBuilder &operator=(const ScalarBuilder &);
  flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scalar> CreateScalar(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScalarBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LENGTH = 4
  };
  /// Number of slots.
  int64_t length() const {
    return GetField<int64_t>(VT_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct ArrayBuilder {
  typedef Array Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int64_t length) {
    fbb_.AddElement<int64_t>(Array::VT_LENGTH, length, 0);
  }
  explicit ArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArrayBuilder &operator=(const ArrayBuilder &);
  flatbuffers::Offset<Array> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Array>(end);
    return o;
  }
};

inline flatbuffers::Offset<Array> CreateArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t length = 0) {
  ArrayBuilder builder_(_fbb);
  builder_.add_length(length);
  return builder_.Finish();
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_TYPE = 4,
    VT_SHAPE = 6,
    VT_BUFFERS = 8,
    VT_DICTIONARY = 10
  };
  org::apache::arrow::flatbuf::computeir::Shape shape_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Shape>(GetField<uint8_t>(VT_SHAPE_TYPE, 0));
  }
  /// Shape of this literal.
  ///
  /// Note that this is orthogonal to type and refers to the number
  /// of rows spanned by this Literal - a Literal may be Scalar shaped
  /// with multiple "columns" if the type happens to be Struct.
  const void *shape() const {
    return GetPointer<const void *>(VT_SHAPE);
  }
  template<typename T> const T *shape_as() const;
  const org::apache::arrow::flatbuf::computeir::Array *shape_as_Array() const {
    return shape_type() == org::apache::arrow::flatbuf::computeir::Shape::Array ? static_cast<const org::apache::arrow::flatbuf::computeir::Array *>(shape()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Scalar *shape_as_Scalar() const {
    return shape_type() == org::apache::arrow::flatbuf::computeir::Shape::Scalar ? static_cast<const org::apache::arrow::flatbuf::computeir::Scalar *>(shape()) : nullptr;
  }
  /// Buffers containing N elements of arrow-formatted data, where N
  /// is Array.length if shape is Array or 1 if shape is Scalar.
  /// XXX this can be optimized for trivial scalars later
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>> *>(VT_BUFFERS);
  }
  /// If (and only if) this Literal has dictionary type, this field dictionary
  /// into which the literal's indices refer.
  const org::apache::arrow::flatbuf::computeir::Literal *dictionary() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Literal *>(VT_DICTIONARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHAPE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           VerifyShape(verifier, shape(), shape_type()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_DICTIONARY) &&
           verifier.VerifyTable(dictionary()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Array *Literal::shape_as<org::apache::arrow::flatbuf::computeir::Array>() const {
  return shape_as_Array();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Scalar *Literal::shape_as<org::apache::arrow::flatbuf::computeir::Scalar>() const {
  return shape_as_Scalar();
}

struct LiteralBuilder {
  typedef Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape_type(org::apache::arrow::flatbuf::computeir::Shape shape_type) {
    fbb_.AddElement<uint8_t>(Literal::VT_SHAPE_TYPE, static_cast<uint8_t>(shape_type), 0);
  }
  void add_shape(flatbuffers::Offset<void> shape) {
    fbb_.AddOffset(Literal::VT_SHAPE, shape);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>>> buffers) {
    fbb_.AddOffset(Literal::VT_BUFFERS, buffers);
  }
  void add_dictionary(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal> dictionary) {
    fbb_.AddOffset(Literal::VT_DICTIONARY, dictionary);
  }
  explicit LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Literal>(end);
    fbb_.Required(o, Literal::VT_SHAPE);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Shape shape_type = org::apache::arrow::flatbuf::computeir::Shape::NONE,
    flatbuffers::Offset<void> shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>>> buffers = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal> dictionary = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_dictionary(dictionary);
  builder_.add_buffers(buffers);
  builder_.add_shape(shape);
  builder_.add_shape_type(shape_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Literal> CreateLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Shape shape_type = org::apache::arrow::flatbuf::computeir::Shape::NONE,
    flatbuffers::Offset<void> shape = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>> *buffers = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal> dictionary = 0) {
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer>>(*buffers) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateLiteral(
      _fbb,
      shape_type,
      shape,
      buffers__,
      dictionary);
}

struct FieldRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_RELATION_INDEX = 6
  };
  /// A sequence of field names to allow referencing potentially nested fields
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  int32_t relation_index() const {
    return GetField<int32_t>(VT_RELATION_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfStrings(path()) &&
           VerifyField<int32_t>(verifier, VT_RELATION_INDEX) &&
           verifier.EndTable();
  }
};

struct FieldRefBuilder {
  typedef FieldRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path) {
    fbb_.AddOffset(FieldRef::VT_PATH, path);
  }
  void add_relation_index(int32_t relation_index) {
    fbb_.AddElement<int32_t>(FieldRef::VT_RELATION_INDEX, relation_index, 0);
  }
  explicit FieldRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldRefBuilder &operator=(const FieldRefBuilder &);
  flatbuffers::Offset<FieldRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldRef> CreateFieldRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path = 0,
    int32_t relation_index = 0) {
  FieldRefBuilder builder_(_fbb);
  builder_.add_relation_index(relation_index);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldRef> CreateFieldRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path = nullptr,
    int32_t relation_index = 0) {
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateFieldRef(
      _fbb,
      path__,
      relation_index);
}

struct CanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::flatbuf::computeir::CanonicalFunctionId id() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::CanonicalFunctionId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalFunctionBuilder {
  typedef CanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::flatbuf::computeir::CanonicalFunctionId id) {
    fbb_.AddElement<uint32_t>(CanonicalFunction::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalFunctionBuilder &operator=(const CanonicalFunctionBuilder &);
  flatbuffers::Offset<CanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalFunction> CreateCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::CanonicalFunctionId id = org::apache::arrow::flatbuf::computeir::CanonicalFunctionId::And) {
  CanonicalFunctionBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalFunctionBuilder {
  typedef NonCanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME, name);
  }
  explicit NonCanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalFunctionBuilder &operator=(const NonCanonicalFunctionBuilder &);
  flatbuffers::Offset<NonCanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalFunction>(end);
    fbb_.Required(o, NonCanonicalFunction::VT_NAME_SPACE);
    fbb_.Required(o, NonCanonicalFunction::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalFunctionBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateNonCanonicalFunction(
      _fbb,
      name_space__,
      name__);
}

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_TYPE = 4,
    VT_FUNCTION = 6,
    VT_OPTIONS = 8,
    VT_ARGUMENTS = 10
  };
  org::apache::arrow::flatbuf::computeir::Function function_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Function>(GetField<uint8_t>(VT_FUNCTION_TYPE, 0));
  }
  /// The function whose invocation this Call represents.
  const void *function() const {
    return GetPointer<const void *>(VT_FUNCTION);
  }
  template<typename T> const T *function_as() const;
  const org::apache::arrow::flatbuf::computeir::CanonicalFunction *function_as_CanonicalFunction() const {
    return function_type() == org::apache::arrow::flatbuf::computeir::Function::CanonicalFunction ? static_cast<const org::apache::arrow::flatbuf::computeir::CanonicalFunction *>(function()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::NonCanonicalFunction *function_as_NonCanonicalFunction() const {
    return function_type() == org::apache::arrow::flatbuf::computeir::Function::NonCanonicalFunction ? static_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalFunction *>(function()) : nullptr;
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::flatbuf::computeir::InlineBuffer *options() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::InlineBuffer *>(VT_OPTIONS);
  }
  /// The arguments passed to `function_name`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FUNCTION_TYPE) &&
           VerifyOffsetRequired(verifier, VT_FUNCTION) &&
           VerifyFunction(verifier, function(), function_type()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::CanonicalFunction *Call::function_as<org::apache::arrow::flatbuf::computeir::CanonicalFunction>() const {
  return function_as_CanonicalFunction();
}

template<> inline const org::apache::arrow::flatbuf::computeir::NonCanonicalFunction *Call::function_as<org::apache::arrow::flatbuf::computeir::NonCanonicalFunction>() const {
  return function_as_NonCanonicalFunction();
}

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function_type(org::apache::arrow::flatbuf::computeir::Function function_type) {
    fbb_.AddElement<uint8_t>(Call::VT_FUNCTION_TYPE, static_cast<uint8_t>(function_type), 0);
  }
  void add_function(flatbuffers::Offset<void> function) {
    fbb_.AddOffset(Call::VT_FUNCTION, function);
  }
  void add_options(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options) {
    fbb_.AddOffset(Call::VT_OPTIONS, options);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> arguments) {
    fbb_.AddOffset(Call::VT_ARGUMENTS, arguments);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    fbb_.Required(o, Call::VT_FUNCTION);
    fbb_.Required(o, Call::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Function function_type = org::apache::arrow::flatbuf::computeir::Function::NONE,
    flatbuffers::Offset<void> function = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> arguments = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_options(options);
  builder_.add_function(function);
  builder_.add_function_type(function_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Call> CreateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Function function_type = org::apache::arrow::flatbuf::computeir::Function::NONE,
    flatbuffers::Offset<void> function = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *arguments = nullptr) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>(*arguments) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateCall(
      _fbb,
      function_type,
      function,
      options,
      arguments__);
}

struct CanonicalOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::flatbuf::computeir::CanonicalOperationId id() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::CanonicalOperationId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalOperationBuilder {
  typedef CanonicalOperation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::flatbuf::computeir::CanonicalOperationId id) {
    fbb_.AddElement<uint32_t>(CanonicalOperation::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalOperationBuilder &operator=(const CanonicalOperationBuilder &);
  flatbuffers::Offset<CanonicalOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalOperation>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalOperation> CreateCanonicalOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::CanonicalOperationId id = org::apache::arrow::flatbuf::computeir::CanonicalOperationId::Literal) {
  CanonicalOperationBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalOperationBuilder {
  typedef NonCanonicalOperation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalOperation::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalOperation::VT_NAME, name);
  }
  explicit NonCanonicalOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalOperationBuilder &operator=(const NonCanonicalOperationBuilder &);
  flatbuffers::Offset<NonCanonicalOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalOperation>(end);
    fbb_.Required(o, NonCanonicalOperation::VT_NAME_SPACE);
    fbb_.Required(o, NonCanonicalOperation::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalOperation> CreateNonCanonicalOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalOperationBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalOperation> CreateNonCanonicalOperationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateNonCanonicalOperation(
      _fbb,
      name_space__,
      name__);
}

/// A relation is a set of rows with consistent schema.
struct Relation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION_TYPE = 4,
    VT_OPERATION = 6,
    VT_OPTIONS = 8,
    VT_ARGUMENTS = 10,
    VT_SCHEMA = 12
  };
  org::apache::arrow::flatbuf::computeir::Operation operation_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Operation>(GetField<uint8_t>(VT_OPERATION_TYPE, 0));
  }
  /// The operation which this Relation wraps.
  const void *operation() const {
    return GetPointer<const void *>(VT_OPERATION);
  }
  template<typename T> const T *operation_as() const;
  const org::apache::arrow::flatbuf::computeir::CanonicalOperation *operation_as_CanonicalOperation() const {
    return operation_type() == org::apache::arrow::flatbuf::computeir::Operation::CanonicalOperation ? static_cast<const org::apache::arrow::flatbuf::computeir::CanonicalOperation *>(operation()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::NonCanonicalOperation *operation_as_NonCanonicalOperation() const {
    return operation_type() == org::apache::arrow::flatbuf::computeir::Operation::NonCanonicalOperation ? static_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalOperation *>(operation()) : nullptr;
  }
  /// Parameters for `operation`; content/format may be unique to each
  /// value of `operation`.
  const org::apache::arrow::flatbuf::computeir::InlineBuffer *options() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::InlineBuffer *>(VT_OPTIONS);
  }
  /// The arguments passed to `operation`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *>(VT_ARGUMENTS);
  }
  /// The schema of rows in this Relation
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPERATION_TYPE) &&
           VerifyOffsetRequired(verifier, VT_OPERATION) &&
           VerifyOperation(verifier, operation(), operation_type()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::CanonicalOperation *Relation::operation_as<org::apache::arrow::flatbuf::computeir::CanonicalOperation>() const {
  return operation_as_CanonicalOperation();
}

template<> inline const org::apache::arrow::flatbuf::computeir::NonCanonicalOperation *Relation::operation_as<org::apache::arrow::flatbuf::computeir::NonCanonicalOperation>() const {
  return operation_as_NonCanonicalOperation();
}

struct RelationBuilder {
  typedef Relation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation_type(org::apache::arrow::flatbuf::computeir::Operation operation_type) {
    fbb_.AddElement<uint8_t>(Relation::VT_OPERATION_TYPE, static_cast<uint8_t>(operation_type), 0);
  }
  void add_operation(flatbuffers::Offset<void> operation) {
    fbb_.AddOffset(Relation::VT_OPERATION, operation);
  }
  void add_options(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options) {
    fbb_.AddOffset(Relation::VT_OPTIONS, options);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> arguments) {
    fbb_.AddOffset(Relation::VT_ARGUMENTS, arguments);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Relation::VT_SCHEMA, schema);
  }
  explicit RelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelationBuilder &operator=(const RelationBuilder &);
  flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_OPERATION);
    fbb_.Required(o, Relation::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Relation> CreateRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Operation operation_type = org::apache::arrow::flatbuf::computeir::Operation::NONE,
    flatbuffers::Offset<void> operation = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> arguments = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_arguments(arguments);
  builder_.add_options(options);
  builder_.add_operation(operation);
  builder_.add_operation_type(operation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relation> CreateRelationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Operation operation_type = org::apache::arrow::flatbuf::computeir::Operation::NONE,
    flatbuffers::Offset<void> operation = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::InlineBuffer> options = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *arguments = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>(*arguments) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateRelation(
      _fbb,
      operation_type,
      operation,
      options,
      arguments__,
      schema);
}

/// The contents of Relation.options will be FilterOptions
/// if Relation.operation = CanonicalOperation::Filter
struct FilterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTER_EXPRESSION = 4
  };
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// filter relation's output.
  const org::apache::arrow::flatbuf::computeir::Expression *filter_expression() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Expression *>(VT_FILTER_EXPRESSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FILTER_EXPRESSION) &&
           verifier.VerifyTable(filter_expression()) &&
           verifier.EndTable();
  }
};

struct FilterOptionsBuilder {
  typedef FilterOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filter_expression(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> filter_expression) {
    fbb_.AddOffset(FilterOptions::VT_FILTER_EXPRESSION, filter_expression);
  }
  explicit FilterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FilterOptionsBuilder &operator=(const FilterOptionsBuilder &);
  flatbuffers::Offset<FilterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilterOptions>(end);
    fbb_.Required(o, FilterOptions::VT_FILTER_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<FilterOptions> CreateFilterOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> filter_expression = 0) {
  FilterOptionsBuilder builder_(_fbb);
  builder_.add_filter_expression(filter_expression);
  return builder_.Finish();
}

/// The contents of Relation.options will be ProjectOptions
/// if Relation.operation = CanonicalOperation::Project
struct ProjectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSIONS = 4
  };
  /// Expressions which will be evaluated to produce to
  /// the rows of the project relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *>(VT_EXPRESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(expressions()) &&
           verifier.VerifyVectorOfTables(expressions()) &&
           verifier.EndTable();
  }
};

struct ProjectOptionsBuilder {
  typedef ProjectOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> expressions) {
    fbb_.AddOffset(ProjectOptions::VT_EXPRESSIONS, expressions);
  }
  explicit ProjectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectOptionsBuilder &operator=(const ProjectOptionsBuilder &);
  flatbuffers::Offset<ProjectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectOptions>(end);
    fbb_.Required(o, ProjectOptions::VT_EXPRESSIONS);
    return o;
  }
};

inline flatbuffers::Offset<ProjectOptions> CreateProjectOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> expressions = 0) {
  ProjectOptionsBuilder builder_(_fbb);
  builder_.add_expressions(expressions);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectOptions> CreateProjectOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *expressions = nullptr) {
  auto expressions__ = expressions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>(*expressions) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateProjectOptions(
      _fbb,
      expressions__);
}

/// The contents of Relation.options will be AggregateOptions
/// if Relation.operation = CanonicalOperation::Aggregate
struct AggregateOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AGGREGATIONS = 4,
    VT_KEYS = 6
  };
  /// Expressions which will be evaluated to produce to
  /// the rows of the aggregate relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *aggregations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *>(VT_AGGREGATIONS);
  }
  /// Keys by which `aggregations` will be grouped.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_AGGREGATIONS) &&
           verifier.VerifyVector(aggregations()) &&
           verifier.VerifyVectorOfTables(aggregations()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct AggregateOptionsBuilder {
  typedef AggregateOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aggregations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> aggregations) {
    fbb_.AddOffset(AggregateOptions::VT_AGGREGATIONS, aggregations);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> keys) {
    fbb_.AddOffset(AggregateOptions::VT_KEYS, keys);
  }
  explicit AggregateOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateOptionsBuilder &operator=(const AggregateOptionsBuilder &);
  flatbuffers::Offset<AggregateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggregateOptions>(end);
    fbb_.Required(o, AggregateOptions::VT_AGGREGATIONS);
    fbb_.Required(o, AggregateOptions::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<AggregateOptions> CreateAggregateOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> aggregations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>> keys = 0) {
  AggregateOptionsBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_aggregations(aggregations);
  return builder_.Finish();
}

inline flatbuffers::Offset<AggregateOptions> CreateAggregateOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *aggregations = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>> *keys = nullptr) {
  auto aggregations__ = aggregations ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>(*aggregations) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression>>(*keys) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateAggregateOptions(
      _fbb,
      aggregations__,
      keys__);
}

struct CanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::flatbuf::computeir::CanonicalJoinKindId id() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::CanonicalJoinKindId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalJoinKindBuilder {
  typedef CanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::flatbuf::computeir::CanonicalJoinKindId id) {
    fbb_.AddElement<uint32_t>(CanonicalJoinKind::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalJoinKindBuilder &operator=(const CanonicalJoinKindBuilder &);
  flatbuffers::Offset<CanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalJoinKind>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalJoinKind> CreateCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::CanonicalJoinKindId id = org::apache::arrow::flatbuf::computeir::CanonicalJoinKindId::Inner) {
  CanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalJoinKindBuilder {
  typedef NonCanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME, name);
  }
  explicit NonCanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalJoinKindBuilder &operator=(const NonCanonicalJoinKindBuilder &);
  flatbuffers::Offset<NonCanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalJoinKind>(end);
    fbb_.Required(o, NonCanonicalJoinKind::VT_NAME_SPACE);
    fbb_.Required(o, NonCanonicalJoinKind::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKindDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateNonCanonicalJoinKind(
      _fbb,
      name_space__,
      name__);
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.operation = CanonicalOperation::Join
struct JoinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON_EXPRESSION = 4,
    VT_JOIN_KIND_TYPE = 6,
    VT_JOIN_KIND = 8
  };
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// join relation's output.
  const org::apache::arrow::flatbuf::computeir::Expression *on_expression() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Expression *>(VT_ON_EXPRESSION);
  }
  org::apache::arrow::flatbuf::computeir::JoinKind join_kind_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::JoinKind>(GetField<uint8_t>(VT_JOIN_KIND_TYPE, 0));
  }
  /// The kind of join to use.
  const void *join_kind() const {
    return GetPointer<const void *>(VT_JOIN_KIND);
  }
  template<typename T> const T *join_kind_as() const;
  const org::apache::arrow::flatbuf::computeir::CanonicalJoinKind *join_kind_as_CanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::flatbuf::computeir::JoinKind::CanonicalJoinKind ? static_cast<const org::apache::arrow::flatbuf::computeir::CanonicalJoinKind *>(join_kind()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind *join_kind_as_NonCanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::flatbuf::computeir::JoinKind::NonCanonicalJoinKind ? static_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind *>(join_kind()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ON_EXPRESSION) &&
           verifier.VerifyTable(on_expression()) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_JOIN_KIND) &&
           VerifyJoinKind(verifier, join_kind(), join_kind_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::CanonicalJoinKind *JoinOptions::join_kind_as<org::apache::arrow::flatbuf::computeir::CanonicalJoinKind>() const {
  return join_kind_as_CanonicalJoinKind();
}

template<> inline const org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind *JoinOptions::join_kind_as<org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind>() const {
  return join_kind_as_NonCanonicalJoinKind();
}

struct JoinOptionsBuilder {
  typedef JoinOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on_expression(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> on_expression) {
    fbb_.AddOffset(JoinOptions::VT_ON_EXPRESSION, on_expression);
  }
  void add_join_kind_type(org::apache::arrow::flatbuf::computeir::JoinKind join_kind_type) {
    fbb_.AddElement<uint8_t>(JoinOptions::VT_JOIN_KIND_TYPE, static_cast<uint8_t>(join_kind_type), 0);
  }
  void add_join_kind(flatbuffers::Offset<void> join_kind) {
    fbb_.AddOffset(JoinOptions::VT_JOIN_KIND, join_kind);
  }
  explicit JoinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinOptionsBuilder &operator=(const JoinOptionsBuilder &);
  flatbuffers::Offset<JoinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinOptions>(end);
    fbb_.Required(o, JoinOptions::VT_ON_EXPRESSION);
    fbb_.Required(o, JoinOptions::VT_JOIN_KIND);
    return o;
  }
};

inline flatbuffers::Offset<JoinOptions> CreateJoinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> on_expression = 0,
    org::apache::arrow::flatbuf::computeir::JoinKind join_kind_type = org::apache::arrow::flatbuf::computeir::JoinKind::NONE,
    flatbuffers::Offset<void> join_kind = 0) {
  JoinOptionsBuilder builder_(_fbb);
  builder_.add_join_kind(join_kind);
  builder_.add_on_expression(on_expression);
  builder_.add_join_kind_type(join_kind_type);
  return builder_.Finish();
}

struct SortKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_ORDERING = 6
  };
  const org::apache::arrow::flatbuf::computeir::Expression *value() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Expression *>(VT_VALUE);
  }
  org::apache::arrow::flatbuf::computeir::Ordering ordering() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Ordering>(GetField<uint8_t>(VT_ORDERING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyField<uint8_t>(verifier, VT_ORDERING) &&
           verifier.EndTable();
  }
};

struct SortKeyBuilder {
  typedef SortKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> value) {
    fbb_.AddOffset(SortKey::VT_VALUE, value);
  }
  void add_ordering(org::apache::arrow::flatbuf::computeir::Ordering ordering) {
    fbb_.AddElement<uint8_t>(SortKey::VT_ORDERING, static_cast<uint8_t>(ordering), 0);
  }
  explicit SortKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortKeyBuilder &operator=(const SortKeyBuilder &);
  flatbuffers::Offset<SortKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortKey>(end);
    fbb_.Required(o, SortKey::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<SortKey> CreateSortKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Expression> value = 0,
    org::apache::arrow::flatbuf::computeir::Ordering ordering = org::apache::arrow::flatbuf::computeir::Ordering::ASCENDING_THEN_NULLS) {
  SortKeyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_ordering(ordering);
  return builder_.Finish();
}

/// The contents of Relation.options will be OrderByOptions
/// if Relation.operation = CanonicalOperation::OrderBy
struct OrderByOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderByOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4
  };
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct OrderByOptionsBuilder {
  typedef OrderByOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>> keys) {
    fbb_.AddOffset(OrderByOptions::VT_KEYS, keys);
  }
  explicit OrderByOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderByOptionsBuilder &operator=(const OrderByOptionsBuilder &);
  flatbuffers::Offset<OrderByOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderByOptions>(end);
    fbb_.Required(o, OrderByOptions::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<OrderByOptions> CreateOrderByOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>> keys = 0) {
  OrderByOptionsBuilder builder_(_fbb);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderByOptions> CreateOrderByOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>(*keys) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateOrderByOptions(
      _fbb,
      keys__);
}

/// The contents of Relation.options will be LimitOptions
/// if Relation.operation = CanonicalOperation::Limit
struct LimitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LimitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4
  };
  /// Set the maximum number of rows of output.
  int64_t count() const {
    return GetField<int64_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LimitOptionsBuilder {
  typedef LimitOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int64_t count) {
    fbb_.AddElement<int64_t>(LimitOptions::VT_COUNT, count, 0);
  }
  explicit LimitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LimitOptionsBuilder &operator=(const LimitOptionsBuilder &);
  flatbuffers::Offset<LimitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LimitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LimitOptions> CreateLimitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t count = 0) {
  LimitOptionsBuilder builder_(_fbb);
  builder_.add_count(count);
  return builder_.Finish();
}

/// The contents of Relation.options will be CommonOptions
/// if Relation.operation = CanonicalOperation::Common
struct CommonOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommonOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CommonOptionsBuilder {
  typedef CommonOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CommonOptions::VT_NAME, name);
  }
  explicit CommonOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommonOptionsBuilder &operator=(const CommonOptionsBuilder &);
  flatbuffers::Offset<CommonOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommonOptions>(end);
    fbb_.Required(o, CommonOptions::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<CommonOptions> CreateCommonOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CommonOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommonOptions> CreateCommonOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateCommonOptions(
      _fbb,
      name__);
}

/// The contents of Relation.options will be UnionOptions
/// if Relation.operation = CanonicalOperation::Union
struct UnionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnionOptionsBuilder {
  typedef UnionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnionOptionsBuilder &operator=(const UnionOptionsBuilder &);
  flatbuffers::Offset<UnionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionOptions> CreateUnionOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnionOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

/// The contents of Relation.options will be LiteralOptions
/// if Relation.operation = CanonicalOperation::Literal
struct LiteralOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  /// The columns of this literal relation.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LiteralOptionsBuilder {
  typedef LiteralOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>>> columns) {
    fbb_.AddOffset(LiteralOptions::VT_COLUMNS, columns);
  }
  explicit LiteralOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralOptionsBuilder &operator=(const LiteralOptionsBuilder &);
  flatbuffers::Offset<LiteralOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralOptions>(end);
    fbb_.Required(o, LiteralOptions::VT_COLUMNS);
    return o;
  }
};

inline flatbuffers::Offset<LiteralOptions> CreateLiteralOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>>> columns = 0) {
  LiteralOptionsBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralOptions> CreateLiteralOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Literal>>(*columns) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateLiteralOptions(
      _fbb,
      columns__);
}

/// A specification of a query.
struct Plan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINKS = 4,
    VT_DERIVED_FROM = 6
  };
  /// One or more output relations.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *>(VT_SINKS);
  }
  /// If this Plan was derived from another (for example by running
  /// an optimization pass), that plan may be included here to
  /// provide a backtrace of derivations.
  const org::apache::arrow::flatbuf::computeir::Plan *derived_from() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Plan *>(VT_DERIVED_FROM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_DERIVED_FROM) &&
           verifier.VerifyTable(derived_from()) &&
           verifier.EndTable();
  }
};

struct PlanBuilder {
  typedef Plan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> sinks) {
    fbb_.AddOffset(Plan::VT_SINKS, sinks);
  }
  void add_derived_from(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from) {
    fbb_.AddOffset(Plan::VT_DERIVED_FROM, derived_from);
  }
  explicit PlanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlanBuilder &operator=(const PlanBuilder &);
  flatbuffers::Offset<Plan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plan>(end);
    fbb_.Required(o, Plan::VT_SINKS);
    return o;
  }
};

inline flatbuffers::Offset<Plan> CreatePlan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> sinks = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from = 0) {
  PlanBuilder builder_(_fbb);
  builder_.add_derived_from(derived_from);
  builder_.add_sinks(sinks);
  return builder_.Finish();
}

inline flatbuffers::Offset<Plan> CreatePlanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *sinks = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from = 0) {
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>(*sinks) : 0;
  return org::apache::arrow::flatbuf::computeir::CreatePlan(
      _fbb,
      sinks__,
      derived_from);
}

inline bool VerifyInlineBufferImpl(flatbuffers::Verifier &verifier, const void *obj, InlineBufferImpl type) {
  switch (type) {
    case InlineBufferImpl::NONE: {
      return true;
    }
    case InlineBufferImpl::Int8Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Int8Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int16Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Int16Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Int32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Int64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt8Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::UInt8Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt16Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::UInt16Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::UInt32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::UInt64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Float32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Float32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Float64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Float64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::TableBuffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::TableBuffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInlineBufferImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInlineBufferImpl(
        verifier,  values->Get(i), types->GetEnum<InlineBufferImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type) {
  switch (type) {
    case ExpressionImpl::NONE: {
      return true;
    }
    case ExpressionImpl::Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::FieldRef: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Call: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExpressionImpl(
        verifier,  values->Get(i), types->GetEnum<ExpressionImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type) {
  switch (type) {
    case Shape::NONE: {
      return true;
    }
    case Shape::Array: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Shape::Scalar: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Scalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyShape(
        verifier,  values->Get(i), types->GetEnum<Shape>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFunction(flatbuffers::Verifier &verifier, const void *obj, Function type) {
  switch (type) {
    case Function::NONE: {
      return true;
    }
    case Function::CanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::CanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Function::NonCanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFunctionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFunction(
        verifier,  values->Get(i), types->GetEnum<Function>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOperation(flatbuffers::Verifier &verifier, const void *obj, Operation type) {
  switch (type) {
    case Operation::NONE: {
      return true;
    }
    case Operation::CanonicalOperation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::CanonicalOperation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation::NonCanonicalOperation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalOperation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOperationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOperation(
        verifier,  values->Get(i), types->GetEnum<Operation>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type) {
  switch (type) {
    case JoinKind::NONE: {
      return true;
    }
    case JoinKind::CanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::CanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case JoinKind::NonCanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::NonCanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyJoinKind(
        verifier,  values->Get(i), types->GetEnum<JoinKind>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::flatbuf::computeir::Plan *GetPlan(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::flatbuf::computeir::Plan>(buf);
}

inline const org::apache::arrow::flatbuf::computeir::Plan *GetSizePrefixedPlan(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::flatbuf::computeir::Plan>(buf);
}

inline bool VerifyPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::flatbuf::computeir::Plan>(nullptr);
}

inline bool VerifySizePrefixedPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::flatbuf::computeir::Plan>(nullptr);
}

inline void FinishPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace computeir
}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_
