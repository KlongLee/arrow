// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_
#define FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_

#include "flatbuffers/flatbuffers.h"

#include "Message_generated.h"
#include "Schema_generated.h"
#include "SparseTensor_generated.h"
#include "Tensor_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {
namespace computeir {

struct ScalarShape;
struct ScalarShapeBuilder;

struct ArrayShape;
struct ArrayShapeBuilder;

struct Literal;
struct LiteralBuilder;

struct FieldRef;
struct FieldRefBuilder;

struct Call;
struct CallBuilder;

struct Relation;
struct RelationBuilder;

struct FilterOptions;
struct FilterOptionsBuilder;

struct ProjectOptions;
struct ProjectOptionsBuilder;

struct AggregateOptions;
struct AggregateOptionsBuilder;

struct JoinOptions;
struct JoinOptionsBuilder;

struct SortKey;
struct SortKeyBuilder;

struct OrderByOptions;
struct OrderByOptionsBuilder;

struct LimitOptions;
struct LimitOptionsBuilder;

struct CommonOptions;
struct CommonOptionsBuilder;

struct UnionOptions;
struct UnionOptionsBuilder;

struct LiteralOptions;
struct LiteralOptionsBuilder;

struct Plan;
struct PlanBuilder;

/// An expression is one of
/// - a Literal datum
/// - a reference to a Field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
enum class Expression : uint8_t {
  NONE = 0,
  Literal = 1,
  FieldRef = 2,
  Call = 3,
  MIN = NONE,
  MAX = Call
};

inline const Expression (&EnumValuesExpression())[4] {
  static const Expression values[] = {
    Expression::NONE,
    Expression::Literal,
    Expression::FieldRef,
    Expression::Call
  };
  return values;
}

inline const char * const *EnumNamesExpression() {
  static const char * const names[5] = {
    "NONE",
    "Literal",
    "FieldRef",
    "Call",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpression(Expression e) {
  if (flatbuffers::IsOutRange(e, Expression::NONE, Expression::Call)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpression()[index];
}

template<typename T> struct ExpressionTraits {
  static const Expression enum_value = Expression::NONE;
};

template<> struct ExpressionTraits<org::apache::arrow::flatbuf::computeir::Literal> {
  static const Expression enum_value = Expression::Literal;
};

template<> struct ExpressionTraits<org::apache::arrow::flatbuf::computeir::FieldRef> {
  static const Expression enum_value = Expression::FieldRef;
};

template<> struct ExpressionTraits<org::apache::arrow::flatbuf::computeir::Call> {
  static const Expression enum_value = Expression::Call;
};

bool VerifyExpression(flatbuffers::Verifier &verifier, const void *obj, Expression type);
bool VerifyExpressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Shape : uint8_t {
  NONE = 0,
  ArrayShape = 1,
  ScalarShape = 2,
  MIN = NONE,
  MAX = ScalarShape
};

inline const Shape (&EnumValuesShape())[3] {
  static const Shape values[] = {
    Shape::NONE,
    Shape::ArrayShape,
    Shape::ScalarShape
  };
  return values;
}

inline const char * const *EnumNamesShape() {
  static const char * const names[4] = {
    "NONE",
    "ArrayShape",
    "ScalarShape",
    nullptr
  };
  return names;
}

inline const char *EnumNameShape(Shape e) {
  if (flatbuffers::IsOutRange(e, Shape::NONE, Shape::ScalarShape)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShape()[index];
}

template<typename T> struct ShapeTraits {
  static const Shape enum_value = Shape::NONE;
};

template<> struct ShapeTraits<org::apache::arrow::flatbuf::computeir::ArrayShape> {
  static const Shape enum_value = Shape::ArrayShape;
};

template<> struct ShapeTraits<org::apache::arrow::flatbuf::computeir::ScalarShape> {
  static const Shape enum_value = Shape::ScalarShape;
};

bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type);
bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum class Ordering : uint8_t {
  ASCENDING_THEN_NULLS = 0,
  DESCENDING_THEN_NULLS = 1,
  NULLS_THEN_ASCENDING = 2,
  NULLS_THEN_DESCENDING = 3,
  MIN = ASCENDING_THEN_NULLS,
  MAX = NULLS_THEN_DESCENDING
};

inline const Ordering (&EnumValuesOrdering())[4] {
  static const Ordering values[] = {
    Ordering::ASCENDING_THEN_NULLS,
    Ordering::DESCENDING_THEN_NULLS,
    Ordering::NULLS_THEN_ASCENDING,
    Ordering::NULLS_THEN_DESCENDING
  };
  return values;
}

inline const char * const *EnumNamesOrdering() {
  static const char * const names[5] = {
    "ASCENDING_THEN_NULLS",
    "DESCENDING_THEN_NULLS",
    "NULLS_THEN_ASCENDING",
    "NULLS_THEN_DESCENDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrdering(Ordering e) {
  if (flatbuffers::IsOutRange(e, Ordering::ASCENDING_THEN_NULLS, Ordering::NULLS_THEN_DESCENDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrdering()[index];
}

struct ScalarShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarShapeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScalarShapeBuilder {
  typedef ScalarShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScalarShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScalarShapeBuilder &operator=(const ScalarShapeBuilder &);
  flatbuffers::Offset<ScalarShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarShape> CreateScalarShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScalarShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArrayShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LENGTH = 4
  };
  /// Number of slots.
  int64_t length() const {
    return GetField<int64_t>(VT_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct ArrayShapeBuilder {
  typedef ArrayShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int64_t length) {
    fbb_.AddElement<int64_t>(ArrayShape::VT_LENGTH, length, 0);
  }
  explicit ArrayShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArrayShapeBuilder &operator=(const ArrayShapeBuilder &);
  flatbuffers::Offset<ArrayShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayShape> CreateArrayShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t length = 0) {
  ArrayShapeBuilder builder_(_fbb);
  builder_.add_length(length);
  return builder_.Finish();
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_TYPE = 4,
    VT_SHAPE = 6,
    VT_TYPE_TYPE = 8,
    VT_TYPE = 10,
    VT_BUFFERS = 12
  };
  org::apache::arrow::flatbuf::computeir::Shape shape_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Shape>(GetField<uint8_t>(VT_SHAPE_TYPE, 0));
  }
  /// Shape of this literal.
  const void *shape() const {
    return GetPointer<const void *>(VT_SHAPE);
  }
  template<typename T> const T *shape_as() const;
  const org::apache::arrow::flatbuf::computeir::ArrayShape *shape_as_ArrayShape() const {
    return shape_type() == org::apache::arrow::flatbuf::computeir::Shape::ArrayShape ? static_cast<const org::apache::arrow::flatbuf::computeir::ArrayShape *>(shape()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::ScalarShape *shape_as_ScalarShape() const {
    return shape_type() == org::apache::arrow::flatbuf::computeir::Shape::ScalarShape ? static_cast<const org::apache::arrow::flatbuf::computeir::ScalarShape *>(shape()) : nullptr;
  }
  org::apache::arrow::flatbuf::Type type_type() const {
    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  /// The type of this literal.
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::List *type_as_List() const {
    return type_type() == org::apache::arrow::flatbuf::Type::List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
  }
  /// Buffers containing `length` elements of arrow-formatted data.
  /// If `length` is absent (this Literal is scalar), these buffers
  /// are sized to accommodate a single element of arrow-formatted data.
  /// XXX this can be optimized for trivial scalars later
  const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *buffers() const {
    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *>(VT_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHAPE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           VerifyShape(verifier, shape(), shape_type()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::ArrayShape *Literal::shape_as<org::apache::arrow::flatbuf::computeir::ArrayShape>() const {
  return shape_as_ArrayShape();
}

template<> inline const org::apache::arrow::flatbuf::computeir::ScalarShape *Literal::shape_as<org::apache::arrow::flatbuf::computeir::ScalarShape>() const {
  return shape_as_ScalarShape();
}

template<> inline const org::apache::arrow::flatbuf::Null *Literal::type_as<org::apache::arrow::flatbuf::Null>() const {
  return type_as_Null();
}

template<> inline const org::apache::arrow::flatbuf::Int *Literal::type_as<org::apache::arrow::flatbuf::Int>() const {
  return type_as_Int();
}

template<> inline const org::apache::arrow::flatbuf::FloatingPoint *Literal::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
  return type_as_FloatingPoint();
}

template<> inline const org::apache::arrow::flatbuf::Binary *Literal::type_as<org::apache::arrow::flatbuf::Binary>() const {
  return type_as_Binary();
}

template<> inline const org::apache::arrow::flatbuf::Utf8 *Literal::type_as<org::apache::arrow::flatbuf::Utf8>() const {
  return type_as_Utf8();
}

template<> inline const org::apache::arrow::flatbuf::Bool *Literal::type_as<org::apache::arrow::flatbuf::Bool>() const {
  return type_as_Bool();
}

template<> inline const org::apache::arrow::flatbuf::Decimal *Literal::type_as<org::apache::arrow::flatbuf::Decimal>() const {
  return type_as_Decimal();
}

template<> inline const org::apache::arrow::flatbuf::Date *Literal::type_as<org::apache::arrow::flatbuf::Date>() const {
  return type_as_Date();
}

template<> inline const org::apache::arrow::flatbuf::Time *Literal::type_as<org::apache::arrow::flatbuf::Time>() const {
  return type_as_Time();
}

template<> inline const org::apache::arrow::flatbuf::Timestamp *Literal::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
  return type_as_Timestamp();
}

template<> inline const org::apache::arrow::flatbuf::Interval *Literal::type_as<org::apache::arrow::flatbuf::Interval>() const {
  return type_as_Interval();
}

template<> inline const org::apache::arrow::flatbuf::List *Literal::type_as<org::apache::arrow::flatbuf::List>() const {
  return type_as_List();
}

template<> inline const org::apache::arrow::flatbuf::Struct_ *Literal::type_as<org::apache::arrow::flatbuf::Struct_>() const {
  return type_as_Struct_();
}

template<> inline const org::apache::arrow::flatbuf::Union *Literal::type_as<org::apache::arrow::flatbuf::Union>() const {
  return type_as_Union();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *Literal::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
  return type_as_FixedSizeBinary();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeList *Literal::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
  return type_as_FixedSizeList();
}

template<> inline const org::apache::arrow::flatbuf::Map *Literal::type_as<org::apache::arrow::flatbuf::Map>() const {
  return type_as_Map();
}

template<> inline const org::apache::arrow::flatbuf::Duration *Literal::type_as<org::apache::arrow::flatbuf::Duration>() const {
  return type_as_Duration();
}

template<> inline const org::apache::arrow::flatbuf::LargeBinary *Literal::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
  return type_as_LargeBinary();
}

template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *Literal::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
  return type_as_LargeUtf8();
}

template<> inline const org::apache::arrow::flatbuf::LargeList *Literal::type_as<org::apache::arrow::flatbuf::LargeList>() const {
  return type_as_LargeList();
}

struct LiteralBuilder {
  typedef Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape_type(org::apache::arrow::flatbuf::computeir::Shape shape_type) {
    fbb_.AddElement<uint8_t>(Literal::VT_SHAPE_TYPE, static_cast<uint8_t>(shape_type), 0);
  }
  void add_shape(flatbuffers::Offset<void> shape) {
    fbb_.AddOffset(Literal::VT_SHAPE, shape);
  }
  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
    fbb_.AddElement<uint8_t>(Literal::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(Literal::VT_TYPE, type);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers) {
    fbb_.AddOffset(Literal::VT_BUFFERS, buffers);
  }
  explicit LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Literal>(end);
    fbb_.Required(o, Literal::VT_SHAPE);
    fbb_.Required(o, Literal::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Shape shape_type = org::apache::arrow::flatbuf::computeir::Shape::NONE,
    flatbuffers::Offset<void> shape = 0,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_buffers(buffers);
  builder_.add_type(type);
  builder_.add_shape(shape);
  builder_.add_type_type(type_type);
  builder_.add_shape_type(shape_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Literal> CreateLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Shape shape_type = org::apache::arrow::flatbuf::computeir::Shape::NONE,
    flatbuffers::Offset<void> shape = 0,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0,
    const std::vector<org::apache::arrow::flatbuf::Buffer> *buffers = nullptr) {
  auto buffers__ = buffers ? _fbb.CreateVectorOfStructs<org::apache::arrow::flatbuf::Buffer>(*buffers) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateLiteral(
      _fbb,
      shape_type,
      shape,
      type_type,
      type,
      buffers__);
}

struct FieldRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_RELATION_INDEX = 6,
    VT_TYPE_TYPE = 8,
    VT_TYPE = 10
  };
  /// A sequence of field names to allow referencing potentially nested fields
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  int32_t relation_index() const {
    return GetField<int32_t>(VT_RELATION_INDEX, 0);
  }
  org::apache::arrow::flatbuf::Type type_type() const {
    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  /// The type of data in the referenced Field.
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::List *type_as_List() const {
    return type_type() == org::apache::arrow::flatbuf::Type::List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfStrings(path()) &&
           VerifyField<int32_t>(verifier, VT_RELATION_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::Null *FieldRef::type_as<org::apache::arrow::flatbuf::Null>() const {
  return type_as_Null();
}

template<> inline const org::apache::arrow::flatbuf::Int *FieldRef::type_as<org::apache::arrow::flatbuf::Int>() const {
  return type_as_Int();
}

template<> inline const org::apache::arrow::flatbuf::FloatingPoint *FieldRef::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
  return type_as_FloatingPoint();
}

template<> inline const org::apache::arrow::flatbuf::Binary *FieldRef::type_as<org::apache::arrow::flatbuf::Binary>() const {
  return type_as_Binary();
}

template<> inline const org::apache::arrow::flatbuf::Utf8 *FieldRef::type_as<org::apache::arrow::flatbuf::Utf8>() const {
  return type_as_Utf8();
}

template<> inline const org::apache::arrow::flatbuf::Bool *FieldRef::type_as<org::apache::arrow::flatbuf::Bool>() const {
  return type_as_Bool();
}

template<> inline const org::apache::arrow::flatbuf::Decimal *FieldRef::type_as<org::apache::arrow::flatbuf::Decimal>() const {
  return type_as_Decimal();
}

template<> inline const org::apache::arrow::flatbuf::Date *FieldRef::type_as<org::apache::arrow::flatbuf::Date>() const {
  return type_as_Date();
}

template<> inline const org::apache::arrow::flatbuf::Time *FieldRef::type_as<org::apache::arrow::flatbuf::Time>() const {
  return type_as_Time();
}

template<> inline const org::apache::arrow::flatbuf::Timestamp *FieldRef::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
  return type_as_Timestamp();
}

template<> inline const org::apache::arrow::flatbuf::Interval *FieldRef::type_as<org::apache::arrow::flatbuf::Interval>() const {
  return type_as_Interval();
}

template<> inline const org::apache::arrow::flatbuf::List *FieldRef::type_as<org::apache::arrow::flatbuf::List>() const {
  return type_as_List();
}

template<> inline const org::apache::arrow::flatbuf::Struct_ *FieldRef::type_as<org::apache::arrow::flatbuf::Struct_>() const {
  return type_as_Struct_();
}

template<> inline const org::apache::arrow::flatbuf::Union *FieldRef::type_as<org::apache::arrow::flatbuf::Union>() const {
  return type_as_Union();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *FieldRef::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
  return type_as_FixedSizeBinary();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeList *FieldRef::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
  return type_as_FixedSizeList();
}

template<> inline const org::apache::arrow::flatbuf::Map *FieldRef::type_as<org::apache::arrow::flatbuf::Map>() const {
  return type_as_Map();
}

template<> inline const org::apache::arrow::flatbuf::Duration *FieldRef::type_as<org::apache::arrow::flatbuf::Duration>() const {
  return type_as_Duration();
}

template<> inline const org::apache::arrow::flatbuf::LargeBinary *FieldRef::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
  return type_as_LargeBinary();
}

template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *FieldRef::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
  return type_as_LargeUtf8();
}

template<> inline const org::apache::arrow::flatbuf::LargeList *FieldRef::type_as<org::apache::arrow::flatbuf::LargeList>() const {
  return type_as_LargeList();
}

struct FieldRefBuilder {
  typedef FieldRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path) {
    fbb_.AddOffset(FieldRef::VT_PATH, path);
  }
  void add_relation_index(int32_t relation_index) {
    fbb_.AddElement<int32_t>(FieldRef::VT_RELATION_INDEX, relation_index, 0);
  }
  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
    fbb_.AddElement<uint8_t>(FieldRef::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(FieldRef::VT_TYPE, type);
  }
  explicit FieldRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldRefBuilder &operator=(const FieldRefBuilder &);
  flatbuffers::Offset<FieldRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldRef> CreateFieldRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path = 0,
    int32_t relation_index = 0,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0) {
  FieldRefBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_relation_index(relation_index);
  builder_.add_path(path);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldRef> CreateFieldRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path = nullptr,
    int32_t relation_index = 0,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0) {
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateFieldRef(
      _fbb,
      path__,
      relation_index,
      type_type,
      type);
}

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_NAME = 4,
    VT_OPTIONS = 6,
    VT_ARGUMENTS_TYPE = 8,
    VT_ARGUMENTS = 10,
    VT_TYPE_TYPE = 12,
    VT_TYPE = 14
  };
  /// The name of the function whose invocation this Call represents.
  const flatbuffers::String *function_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNCTION_NAME);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::flatbuf::Buffer *options() const {
    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_OPTIONS);
  }
  const flatbuffers::Vector<uint8_t> *arguments_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARGUMENTS_TYPE);
  }
  /// The arguments passed to `function_name`.
  const flatbuffers::Vector<flatbuffers::Offset<void>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ARGUMENTS);
  }
  org::apache::arrow::flatbuf::Type type_type() const {
    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  /// The type of data which invoking `function_name` will return.
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::List *type_as_List() const {
    return type_type() == org::apache::arrow::flatbuf::Type::List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FUNCTION_NAME) &&
           verifier.VerifyString(function_name()) &&
           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_OPTIONS) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS_TYPE) &&
           verifier.VerifyVector(arguments_type()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           VerifyExpressionVector(verifier, arguments(), arguments_type()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::Null *Call::type_as<org::apache::arrow::flatbuf::Null>() const {
  return type_as_Null();
}

template<> inline const org::apache::arrow::flatbuf::Int *Call::type_as<org::apache::arrow::flatbuf::Int>() const {
  return type_as_Int();
}

template<> inline const org::apache::arrow::flatbuf::FloatingPoint *Call::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
  return type_as_FloatingPoint();
}

template<> inline const org::apache::arrow::flatbuf::Binary *Call::type_as<org::apache::arrow::flatbuf::Binary>() const {
  return type_as_Binary();
}

template<> inline const org::apache::arrow::flatbuf::Utf8 *Call::type_as<org::apache::arrow::flatbuf::Utf8>() const {
  return type_as_Utf8();
}

template<> inline const org::apache::arrow::flatbuf::Bool *Call::type_as<org::apache::arrow::flatbuf::Bool>() const {
  return type_as_Bool();
}

template<> inline const org::apache::arrow::flatbuf::Decimal *Call::type_as<org::apache::arrow::flatbuf::Decimal>() const {
  return type_as_Decimal();
}

template<> inline const org::apache::arrow::flatbuf::Date *Call::type_as<org::apache::arrow::flatbuf::Date>() const {
  return type_as_Date();
}

template<> inline const org::apache::arrow::flatbuf::Time *Call::type_as<org::apache::arrow::flatbuf::Time>() const {
  return type_as_Time();
}

template<> inline const org::apache::arrow::flatbuf::Timestamp *Call::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
  return type_as_Timestamp();
}

template<> inline const org::apache::arrow::flatbuf::Interval *Call::type_as<org::apache::arrow::flatbuf::Interval>() const {
  return type_as_Interval();
}

template<> inline const org::apache::arrow::flatbuf::List *Call::type_as<org::apache::arrow::flatbuf::List>() const {
  return type_as_List();
}

template<> inline const org::apache::arrow::flatbuf::Struct_ *Call::type_as<org::apache::arrow::flatbuf::Struct_>() const {
  return type_as_Struct_();
}

template<> inline const org::apache::arrow::flatbuf::Union *Call::type_as<org::apache::arrow::flatbuf::Union>() const {
  return type_as_Union();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *Call::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
  return type_as_FixedSizeBinary();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeList *Call::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
  return type_as_FixedSizeList();
}

template<> inline const org::apache::arrow::flatbuf::Map *Call::type_as<org::apache::arrow::flatbuf::Map>() const {
  return type_as_Map();
}

template<> inline const org::apache::arrow::flatbuf::Duration *Call::type_as<org::apache::arrow::flatbuf::Duration>() const {
  return type_as_Duration();
}

template<> inline const org::apache::arrow::flatbuf::LargeBinary *Call::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
  return type_as_LargeBinary();
}

template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *Call::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
  return type_as_LargeUtf8();
}

template<> inline const org::apache::arrow::flatbuf::LargeList *Call::type_as<org::apache::arrow::flatbuf::LargeList>() const {
  return type_as_LargeList();
}

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function_name(flatbuffers::Offset<flatbuffers::String> function_name) {
    fbb_.AddOffset(Call::VT_FUNCTION_NAME, function_name);
  }
  void add_options(const org::apache::arrow::flatbuf::Buffer *options) {
    fbb_.AddStruct(Call::VT_OPTIONS, options);
  }
  void add_arguments_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> arguments_type) {
    fbb_.AddOffset(Call::VT_ARGUMENTS_TYPE, arguments_type);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> arguments) {
    fbb_.AddOffset(Call::VT_ARGUMENTS, arguments);
  }
  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
    fbb_.AddElement<uint8_t>(Call::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(Call::VT_TYPE, type);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    fbb_.Required(o, Call::VT_FUNCTION_NAME);
    fbb_.Required(o, Call::VT_ARGUMENTS_TYPE);
    fbb_.Required(o, Call::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> function_name = 0,
    const org::apache::arrow::flatbuf::Buffer *options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> arguments_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> arguments = 0,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_arguments(arguments);
  builder_.add_arguments_type(arguments_type);
  builder_.add_options(options);
  builder_.add_function_name(function_name);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Call> CreateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *function_name = nullptr,
    const org::apache::arrow::flatbuf::Buffer *options = 0,
    const std::vector<uint8_t> *arguments_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *arguments = nullptr,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0) {
  auto function_name__ = function_name ? _fbb.CreateString(function_name) : 0;
  auto arguments_type__ = arguments_type ? _fbb.CreateVector<uint8_t>(*arguments_type) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<void>>(*arguments) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateCall(
      _fbb,
      function_name__,
      options,
      arguments_type__,
      arguments__,
      type_type,
      type);
}

/// A relation is a set of rows with consistent schema.
struct Relation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELATION_NAME = 4,
    VT_OPTIONS = 6,
    VT_ARGUMENTS = 8,
    VT_SCHEMA = 10
  };
  /// The namespaced name of this Relation.
  ///
  /// Names with no namespace are reserved for pure relational
  /// algebraic operations, which currently include:
  ///   "filter"
  ///   "project"
  ///   "aggregate"
  ///   "join"
  ///   "order_by"
  ///   "limit"
  ///   "common"
  ///   "union"
  ///   "literal"
  ///   "interactive_output"
  const flatbuffers::String *relation_name() const {
    return GetPointer<const flatbuffers::String *>(VT_RELATION_NAME);
  }
  /// Parameters for `relation_name`; content/format may be unique to each
  /// value of `relation_name`.
  const org::apache::arrow::flatbuf::Buffer *options() const {
    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_OPTIONS);
  }
  /// The arguments passed to `relation_name`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *>(VT_ARGUMENTS);
  }
  /// The schema of rows in this Relation
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RELATION_NAME) &&
           verifier.VerifyString(relation_name()) &&
           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_OPTIONS) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct RelationBuilder {
  typedef Relation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relation_name(flatbuffers::Offset<flatbuffers::String> relation_name) {
    fbb_.AddOffset(Relation::VT_RELATION_NAME, relation_name);
  }
  void add_options(const org::apache::arrow::flatbuf::Buffer *options) {
    fbb_.AddStruct(Relation::VT_OPTIONS, options);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> arguments) {
    fbb_.AddOffset(Relation::VT_ARGUMENTS, arguments);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Relation::VT_SCHEMA, schema);
  }
  explicit RelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelationBuilder &operator=(const RelationBuilder &);
  flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_RELATION_NAME);
    fbb_.Required(o, Relation::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Relation> CreateRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> relation_name = 0,
    const org::apache::arrow::flatbuf::Buffer *options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> arguments = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_arguments(arguments);
  builder_.add_options(options);
  builder_.add_relation_name(relation_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relation> CreateRelationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *relation_name = nullptr,
    const org::apache::arrow::flatbuf::Buffer *options = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *arguments = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto relation_name__ = relation_name ? _fbb.CreateString(relation_name) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>(*arguments) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateRelation(
      _fbb,
      relation_name__,
      options,
      arguments__,
      schema);
}

/// The contents of Relation.options will be FilterOptions
/// if Relation.relation_name = "filter"
struct FilterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTER_EXPRESSION_TYPE = 4,
    VT_FILTER_EXPRESSION = 6
  };
  org::apache::arrow::flatbuf::computeir::Expression filter_expression_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Expression>(GetField<uint8_t>(VT_FILTER_EXPRESSION_TYPE, 0));
  }
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// "filter" relation's output.
  const void *filter_expression() const {
    return GetPointer<const void *>(VT_FILTER_EXPRESSION);
  }
  template<typename T> const T *filter_expression_as() const;
  const org::apache::arrow::flatbuf::computeir::Literal *filter_expression_as_Literal() const {
    return filter_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::Literal ? static_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(filter_expression()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::FieldRef *filter_expression_as_FieldRef() const {
    return filter_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::FieldRef ? static_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(filter_expression()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Call *filter_expression_as_Call() const {
    return filter_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::Call ? static_cast<const org::apache::arrow::flatbuf::computeir::Call *>(filter_expression()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FILTER_EXPRESSION_TYPE) &&
           VerifyOffsetRequired(verifier, VT_FILTER_EXPRESSION) &&
           VerifyExpression(verifier, filter_expression(), filter_expression_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Literal *FilterOptions::filter_expression_as<org::apache::arrow::flatbuf::computeir::Literal>() const {
  return filter_expression_as_Literal();
}

template<> inline const org::apache::arrow::flatbuf::computeir::FieldRef *FilterOptions::filter_expression_as<org::apache::arrow::flatbuf::computeir::FieldRef>() const {
  return filter_expression_as_FieldRef();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Call *FilterOptions::filter_expression_as<org::apache::arrow::flatbuf::computeir::Call>() const {
  return filter_expression_as_Call();
}

struct FilterOptionsBuilder {
  typedef FilterOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filter_expression_type(org::apache::arrow::flatbuf::computeir::Expression filter_expression_type) {
    fbb_.AddElement<uint8_t>(FilterOptions::VT_FILTER_EXPRESSION_TYPE, static_cast<uint8_t>(filter_expression_type), 0);
  }
  void add_filter_expression(flatbuffers::Offset<void> filter_expression) {
    fbb_.AddOffset(FilterOptions::VT_FILTER_EXPRESSION, filter_expression);
  }
  explicit FilterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FilterOptionsBuilder &operator=(const FilterOptionsBuilder &);
  flatbuffers::Offset<FilterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilterOptions>(end);
    fbb_.Required(o, FilterOptions::VT_FILTER_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<FilterOptions> CreateFilterOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Expression filter_expression_type = org::apache::arrow::flatbuf::computeir::Expression::NONE,
    flatbuffers::Offset<void> filter_expression = 0) {
  FilterOptionsBuilder builder_(_fbb);
  builder_.add_filter_expression(filter_expression);
  builder_.add_filter_expression_type(filter_expression_type);
  return builder_.Finish();
}

/// The contents of Relation.options will be ProjectOptions
/// if Relation.relation_name = "project"
struct ProjectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSIONS_TYPE = 4,
    VT_EXPRESSIONS = 6
  };
  const flatbuffers::Vector<uint8_t> *expressions_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXPRESSIONS_TYPE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the "project" relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<void>> *expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_EXPRESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS_TYPE) &&
           verifier.VerifyVector(expressions_type()) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(expressions()) &&
           VerifyExpressionVector(verifier, expressions(), expressions_type()) &&
           verifier.EndTable();
  }
};

struct ProjectOptionsBuilder {
  typedef ProjectOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expressions_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expressions_type) {
    fbb_.AddOffset(ProjectOptions::VT_EXPRESSIONS_TYPE, expressions_type);
  }
  void add_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> expressions) {
    fbb_.AddOffset(ProjectOptions::VT_EXPRESSIONS, expressions);
  }
  explicit ProjectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectOptionsBuilder &operator=(const ProjectOptionsBuilder &);
  flatbuffers::Offset<ProjectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectOptions>(end);
    fbb_.Required(o, ProjectOptions::VT_EXPRESSIONS_TYPE);
    fbb_.Required(o, ProjectOptions::VT_EXPRESSIONS);
    return o;
  }
};

inline flatbuffers::Offset<ProjectOptions> CreateProjectOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> expressions_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> expressions = 0) {
  ProjectOptionsBuilder builder_(_fbb);
  builder_.add_expressions(expressions);
  builder_.add_expressions_type(expressions_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectOptions> CreateProjectOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *expressions_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *expressions = nullptr) {
  auto expressions_type__ = expressions_type ? _fbb.CreateVector<uint8_t>(*expressions_type) : 0;
  auto expressions__ = expressions ? _fbb.CreateVector<flatbuffers::Offset<void>>(*expressions) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateProjectOptions(
      _fbb,
      expressions_type__,
      expressions__);
}

/// The contents of Relation.options will be AggregateOptions
/// if Relation.relation_name = "aggregate"
struct AggregateOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AGGREGATIONS_TYPE = 4,
    VT_AGGREGATIONS = 6,
    VT_KEYS_TYPE = 8,
    VT_KEYS = 10
  };
  const flatbuffers::Vector<uint8_t> *aggregations_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AGGREGATIONS_TYPE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the "aggregate" relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<void>> *aggregations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_AGGREGATIONS);
  }
  const flatbuffers::Vector<uint8_t> *keys_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_KEYS_TYPE);
  }
  /// Keys by which `aggregations` will be grouped.
  const flatbuffers::Vector<flatbuffers::Offset<void>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_AGGREGATIONS_TYPE) &&
           verifier.VerifyVector(aggregations_type()) &&
           VerifyOffsetRequired(verifier, VT_AGGREGATIONS) &&
           verifier.VerifyVector(aggregations()) &&
           VerifyExpressionVector(verifier, aggregations(), aggregations_type()) &&
           VerifyOffset(verifier, VT_KEYS_TYPE) &&
           verifier.VerifyVector(keys_type()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyExpressionVector(verifier, keys(), keys_type()) &&
           verifier.EndTable();
  }
};

struct AggregateOptionsBuilder {
  typedef AggregateOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aggregations_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aggregations_type) {
    fbb_.AddOffset(AggregateOptions::VT_AGGREGATIONS_TYPE, aggregations_type);
  }
  void add_aggregations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> aggregations) {
    fbb_.AddOffset(AggregateOptions::VT_AGGREGATIONS, aggregations);
  }
  void add_keys_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> keys_type) {
    fbb_.AddOffset(AggregateOptions::VT_KEYS_TYPE, keys_type);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> keys) {
    fbb_.AddOffset(AggregateOptions::VT_KEYS, keys);
  }
  explicit AggregateOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateOptionsBuilder &operator=(const AggregateOptionsBuilder &);
  flatbuffers::Offset<AggregateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggregateOptions>(end);
    fbb_.Required(o, AggregateOptions::VT_AGGREGATIONS_TYPE);
    fbb_.Required(o, AggregateOptions::VT_AGGREGATIONS);
    return o;
  }
};

inline flatbuffers::Offset<AggregateOptions> CreateAggregateOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aggregations_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> aggregations = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> keys_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> keys = 0) {
  AggregateOptionsBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_keys_type(keys_type);
  builder_.add_aggregations(aggregations);
  builder_.add_aggregations_type(aggregations_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AggregateOptions> CreateAggregateOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *aggregations_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *aggregations = nullptr,
    const std::vector<uint8_t> *keys_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *keys = nullptr) {
  auto aggregations_type__ = aggregations_type ? _fbb.CreateVector<uint8_t>(*aggregations_type) : 0;
  auto aggregations__ = aggregations ? _fbb.CreateVector<flatbuffers::Offset<void>>(*aggregations) : 0;
  auto keys_type__ = keys_type ? _fbb.CreateVector<uint8_t>(*keys_type) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<void>>(*keys) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateAggregateOptions(
      _fbb,
      aggregations_type__,
      aggregations__,
      keys_type__,
      keys__);
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.relation_name = "join"
struct JoinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON_EXPRESSION_TYPE = 4,
    VT_ON_EXPRESSION = 6,
    VT_JOIN_KIND = 8
  };
  org::apache::arrow::flatbuf::computeir::Expression on_expression_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Expression>(GetField<uint8_t>(VT_ON_EXPRESSION_TYPE, 0));
  }
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// "join" relation's output.
  const void *on_expression() const {
    return GetPointer<const void *>(VT_ON_EXPRESSION);
  }
  template<typename T> const T *on_expression_as() const;
  const org::apache::arrow::flatbuf::computeir::Literal *on_expression_as_Literal() const {
    return on_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::Literal ? static_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(on_expression()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::FieldRef *on_expression_as_FieldRef() const {
    return on_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::FieldRef ? static_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(on_expression()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Call *on_expression_as_Call() const {
    return on_expression_type() == org::apache::arrow::flatbuf::computeir::Expression::Call ? static_cast<const org::apache::arrow::flatbuf::computeir::Call *>(on_expression()) : nullptr;
  }
  const flatbuffers::String *join_kind() const {
    return GetPointer<const flatbuffers::String *>(VT_JOIN_KIND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON_EXPRESSION_TYPE) &&
           VerifyOffsetRequired(verifier, VT_ON_EXPRESSION) &&
           VerifyExpression(verifier, on_expression(), on_expression_type()) &&
           VerifyOffset(verifier, VT_JOIN_KIND) &&
           verifier.VerifyString(join_kind()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Literal *JoinOptions::on_expression_as<org::apache::arrow::flatbuf::computeir::Literal>() const {
  return on_expression_as_Literal();
}

template<> inline const org::apache::arrow::flatbuf::computeir::FieldRef *JoinOptions::on_expression_as<org::apache::arrow::flatbuf::computeir::FieldRef>() const {
  return on_expression_as_FieldRef();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Call *JoinOptions::on_expression_as<org::apache::arrow::flatbuf::computeir::Call>() const {
  return on_expression_as_Call();
}

struct JoinOptionsBuilder {
  typedef JoinOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on_expression_type(org::apache::arrow::flatbuf::computeir::Expression on_expression_type) {
    fbb_.AddElement<uint8_t>(JoinOptions::VT_ON_EXPRESSION_TYPE, static_cast<uint8_t>(on_expression_type), 0);
  }
  void add_on_expression(flatbuffers::Offset<void> on_expression) {
    fbb_.AddOffset(JoinOptions::VT_ON_EXPRESSION, on_expression);
  }
  void add_join_kind(flatbuffers::Offset<flatbuffers::String> join_kind) {
    fbb_.AddOffset(JoinOptions::VT_JOIN_KIND, join_kind);
  }
  explicit JoinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinOptionsBuilder &operator=(const JoinOptionsBuilder &);
  flatbuffers::Offset<JoinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinOptions>(end);
    fbb_.Required(o, JoinOptions::VT_ON_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<JoinOptions> CreateJoinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Expression on_expression_type = org::apache::arrow::flatbuf::computeir::Expression::NONE,
    flatbuffers::Offset<void> on_expression = 0,
    flatbuffers::Offset<flatbuffers::String> join_kind = 0) {
  JoinOptionsBuilder builder_(_fbb);
  builder_.add_join_kind(join_kind);
  builder_.add_on_expression(on_expression);
  builder_.add_on_expression_type(on_expression_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<JoinOptions> CreateJoinOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Expression on_expression_type = org::apache::arrow::flatbuf::computeir::Expression::NONE,
    flatbuffers::Offset<void> on_expression = 0,
    const char *join_kind = nullptr) {
  auto join_kind__ = join_kind ? _fbb.CreateString(join_kind) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateJoinOptions(
      _fbb,
      on_expression_type,
      on_expression,
      join_kind__);
}

struct SortKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6,
    VT_ORDERING = 8
  };
  org::apache::arrow::flatbuf::computeir::Expression value_type() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Expression>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const org::apache::arrow::flatbuf::computeir::Literal *value_as_Literal() const {
    return value_type() == org::apache::arrow::flatbuf::computeir::Expression::Literal ? static_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::FieldRef *value_as_FieldRef() const {
    return value_type() == org::apache::arrow::flatbuf::computeir::Expression::FieldRef ? static_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(value()) : nullptr;
  }
  const org::apache::arrow::flatbuf::computeir::Call *value_as_Call() const {
    return value_type() == org::apache::arrow::flatbuf::computeir::Expression::Call ? static_cast<const org::apache::arrow::flatbuf::computeir::Call *>(value()) : nullptr;
  }
  org::apache::arrow::flatbuf::computeir::Ordering ordering() const {
    return static_cast<org::apache::arrow::flatbuf::computeir::Ordering>(GetField<uint8_t>(VT_ORDERING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyExpression(verifier, value(), value_type()) &&
           VerifyField<uint8_t>(verifier, VT_ORDERING) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::computeir::Literal *SortKey::value_as<org::apache::arrow::flatbuf::computeir::Literal>() const {
  return value_as_Literal();
}

template<> inline const org::apache::arrow::flatbuf::computeir::FieldRef *SortKey::value_as<org::apache::arrow::flatbuf::computeir::FieldRef>() const {
  return value_as_FieldRef();
}

template<> inline const org::apache::arrow::flatbuf::computeir::Call *SortKey::value_as<org::apache::arrow::flatbuf::computeir::Call>() const {
  return value_as_Call();
}

struct SortKeyBuilder {
  typedef SortKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(org::apache::arrow::flatbuf::computeir::Expression value_type) {
    fbb_.AddElement<uint8_t>(SortKey::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SortKey::VT_VALUE, value);
  }
  void add_ordering(org::apache::arrow::flatbuf::computeir::Ordering ordering) {
    fbb_.AddElement<uint8_t>(SortKey::VT_ORDERING, static_cast<uint8_t>(ordering), 0);
  }
  explicit SortKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortKeyBuilder &operator=(const SortKeyBuilder &);
  flatbuffers::Offset<SortKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortKey>(end);
    fbb_.Required(o, SortKey::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<SortKey> CreateSortKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::computeir::Expression value_type = org::apache::arrow::flatbuf::computeir::Expression::NONE,
    flatbuffers::Offset<void> value = 0,
    org::apache::arrow::flatbuf::computeir::Ordering ordering = org::apache::arrow::flatbuf::computeir::Ordering::ASCENDING_THEN_NULLS) {
  SortKeyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_ordering(ordering);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

/// The contents of Relation.options will be OrderByOptions
/// if Relation.relation_name = "order_by"
struct OrderByOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderByOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4
  };
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct OrderByOptionsBuilder {
  typedef OrderByOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>> keys) {
    fbb_.AddOffset(OrderByOptions::VT_KEYS, keys);
  }
  explicit OrderByOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderByOptionsBuilder &operator=(const OrderByOptionsBuilder &);
  flatbuffers::Offset<OrderByOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderByOptions>(end);
    fbb_.Required(o, OrderByOptions::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<OrderByOptions> CreateOrderByOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>> keys = 0) {
  OrderByOptionsBuilder builder_(_fbb);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderByOptions> CreateOrderByOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::SortKey>>(*keys) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateOrderByOptions(
      _fbb,
      keys__);
}

/// The contents of Relation.options will be LimitOptions
/// if Relation.relation_name = "limit"
struct LimitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LimitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4
  };
  /// Set the maximum number of rows of output.
  int64_t count() const {
    return GetField<int64_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LimitOptionsBuilder {
  typedef LimitOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int64_t count) {
    fbb_.AddElement<int64_t>(LimitOptions::VT_COUNT, count, 0);
  }
  explicit LimitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LimitOptionsBuilder &operator=(const LimitOptionsBuilder &);
  flatbuffers::Offset<LimitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LimitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LimitOptions> CreateLimitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t count = 0) {
  LimitOptionsBuilder builder_(_fbb);
  builder_.add_count(count);
  return builder_.Finish();
}

/// The contents of Relation.options will be CommonOptions
/// if Relation.relation_name = "common"
struct CommonOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommonOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CommonOptionsBuilder {
  typedef CommonOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CommonOptions::VT_NAME, name);
  }
  explicit CommonOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommonOptionsBuilder &operator=(const CommonOptionsBuilder &);
  flatbuffers::Offset<CommonOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommonOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommonOptions> CreateCommonOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CommonOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommonOptions> CreateCommonOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateCommonOptions(
      _fbb,
      name__);
}

/// The contents of Relation.options will be UnionOptions
/// if Relation.relation_name = "union"
struct UnionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnionOptionsBuilder {
  typedef UnionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnionOptionsBuilder &operator=(const UnionOptionsBuilder &);
  flatbuffers::Offset<UnionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionOptions> CreateUnionOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnionOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

/// The contents of Relation.options will be LiteralOptions
/// if Relation.relation_name = "literal"
struct LiteralOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCHES = 4
  };
  /// Batches of rows in this literal.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>> *batches() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>> *>(VT_BATCHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BATCHES) &&
           verifier.VerifyVector(batches()) &&
           verifier.VerifyVectorOfTables(batches()) &&
           verifier.EndTable();
  }
};

struct LiteralOptionsBuilder {
  typedef LiteralOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>>> batches) {
    fbb_.AddOffset(LiteralOptions::VT_BATCHES, batches);
  }
  explicit LiteralOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralOptionsBuilder &operator=(const LiteralOptionsBuilder &);
  flatbuffers::Offset<LiteralOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralOptions>(end);
    fbb_.Required(o, LiteralOptions::VT_BATCHES);
    return o;
  }
};

inline flatbuffers::Offset<LiteralOptions> CreateLiteralOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>>> batches = 0) {
  LiteralOptionsBuilder builder_(_fbb);
  builder_.add_batches(batches);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralOptions> CreateLiteralOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>> *batches = nullptr) {
  auto batches__ = batches ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch>>(*batches) : 0;
  return org::apache::arrow::flatbuf::computeir::CreateLiteralOptions(
      _fbb,
      batches__);
}

/// A specification of a query.
struct Plan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINKS = 4,
    VT_DICTIONARY_BATCH = 6,
    VT_DERIVED_FROM = 8
  };
  /// One or more output relations.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *>(VT_SINKS);
  }
  /// Dictionary batches which may be referenced by Literals.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>> *dictionary_batch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>> *>(VT_DICTIONARY_BATCH);
  }
  /// If this Plan was derived from another (for example by running
  /// an optimization pass), that plan may be included here to
  /// provide a backtrace of derivations.
  const org::apache::arrow::flatbuf::computeir::Plan *derived_from() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::Plan *>(VT_DERIVED_FROM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_DICTIONARY_BATCH) &&
           verifier.VerifyVector(dictionary_batch()) &&
           verifier.VerifyVectorOfTables(dictionary_batch()) &&
           VerifyOffset(verifier, VT_DERIVED_FROM) &&
           verifier.VerifyTable(derived_from()) &&
           verifier.EndTable();
  }
};

struct PlanBuilder {
  typedef Plan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> sinks) {
    fbb_.AddOffset(Plan::VT_SINKS, sinks);
  }
  void add_dictionary_batch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>>> dictionary_batch) {
    fbb_.AddOffset(Plan::VT_DICTIONARY_BATCH, dictionary_batch);
  }
  void add_derived_from(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from) {
    fbb_.AddOffset(Plan::VT_DERIVED_FROM, derived_from);
  }
  explicit PlanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlanBuilder &operator=(const PlanBuilder &);
  flatbuffers::Offset<Plan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plan>(end);
    fbb_.Required(o, Plan::VT_SINKS);
    return o;
  }
};

inline flatbuffers::Offset<Plan> CreatePlan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>> sinks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>>> dictionary_batch = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from = 0) {
  PlanBuilder builder_(_fbb);
  builder_.add_derived_from(derived_from);
  builder_.add_dictionary_batch(dictionary_batch);
  builder_.add_sinks(sinks);
  return builder_.Finish();
}

inline flatbuffers::Offset<Plan> CreatePlanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>> *sinks = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>> *dictionary_batch = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> derived_from = 0) {
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Relation>>(*sinks) : 0;
  auto dictionary_batch__ = dictionary_batch ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryBatch>>(*dictionary_batch) : 0;
  return org::apache::arrow::flatbuf::computeir::CreatePlan(
      _fbb,
      sinks__,
      dictionary_batch__,
      derived_from);
}

inline bool VerifyExpression(flatbuffers::Verifier &verifier, const void *obj, Expression type) {
  switch (type) {
    case Expression::NONE: {
      return true;
    }
    case Expression::Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression::FieldRef: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::FieldRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression::Call: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExpressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExpression(
        verifier,  values->Get(i), types->GetEnum<Expression>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type) {
  switch (type) {
    case Shape::NONE: {
      return true;
    }
    case Shape::ArrayShape: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::ArrayShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Shape::ScalarShape: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::computeir::ScalarShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyShape(
        verifier,  values->Get(i), types->GetEnum<Shape>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::flatbuf::computeir::Plan *GetPlan(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::flatbuf::computeir::Plan>(buf);
}

inline const org::apache::arrow::flatbuf::computeir::Plan *GetSizePrefixedPlan(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::flatbuf::computeir::Plan>(buf);
}

inline bool VerifyPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::flatbuf::computeir::Plan>(nullptr);
}

inline bool VerifySizePrefixedPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::flatbuf::computeir::Plan>(nullptr);
}

inline void FinishPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::Plan> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace computeir
}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_H_
