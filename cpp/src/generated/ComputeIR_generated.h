// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"
#include "IRLiteral_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct Int8Buffer;
struct Int8BufferBuilder;

struct Int16Buffer;
struct Int16BufferBuilder;

struct Int32Buffer;
struct Int32BufferBuilder;

struct Int64Buffer;
struct Int64BufferBuilder;

struct UInt8Buffer;
struct UInt8BufferBuilder;

struct UInt16Buffer;
struct UInt16BufferBuilder;

struct UInt32Buffer;
struct UInt32BufferBuilder;

struct UInt64Buffer;
struct UInt64BufferBuilder;

struct Float32Buffer;
struct Float32BufferBuilder;

struct Float64Buffer;
struct Float64BufferBuilder;

struct TableBuffer;
struct TableBufferBuilder;

struct InlineBuffer;
struct InlineBufferBuilder;

struct Expression;
struct ExpressionBuilder;

struct Scalar;
struct ScalarBuilder;

struct Array;
struct ArrayBuilder;

struct MapKey;
struct MapKeyBuilder;

struct StructField;
struct StructFieldBuilder;

struct ArraySubscript;
struct ArraySubscriptBuilder;

struct ArraySlice;
struct ArraySliceBuilder;

struct FieldName;
struct FieldNameBuilder;

struct FieldRef;
struct FieldRefBuilder;

struct CanonicalFunction;
struct CanonicalFunctionBuilder;

struct NonCanonicalFunction;
struct NonCanonicalFunctionBuilder;

struct Call;
struct CallBuilder;

struct Remap;
struct RemapBuilder;

struct PassThrough;
struct PassThroughBuilder;

struct RelBase;
struct RelBaseBuilder;

struct Filter;
struct FilterBuilder;

struct Project;
struct ProjectBuilder;

struct Aggregate;
struct AggregateBuilder;

struct CanonicalJoinKind;
struct CanonicalJoinKindBuilder;

struct NonCanonicalJoinKind;
struct NonCanonicalJoinKindBuilder;

struct Join;
struct JoinBuilder;

struct SortKey;
struct SortKeyBuilder;

struct OrderBy;
struct OrderByBuilder;

struct Limit;
struct LimitBuilder;

struct Common;
struct CommonBuilder;

struct CanonicalSetOpKind;
struct CanonicalSetOpKindBuilder;

struct NonCanonicalSetOpKind;
struct NonCanonicalSetOpKindBuilder;

struct SetOperation;
struct SetOperationBuilder;

struct LiteralRelation;
struct LiteralRelationBuilder;

struct Custom;
struct CustomBuilder;

struct Read;
struct ReadBuilder;

struct Write;
struct WriteBuilder;

struct Relation;
struct RelationBuilder;

struct Plan;
struct PlanBuilder;

enum class InlineBufferImpl : uint8_t {
  NONE = 0,
  Int8Buffer = 1,
  Int16Buffer = 2,
  Int32Buffer = 3,
  Int64Buffer = 4,
  UInt8Buffer = 5,
  UInt16Buffer = 6,
  UInt32Buffer = 7,
  UInt64Buffer = 8,
  Float32Buffer = 9,
  Float64Buffer = 10,
  TableBuffer = 11,
  MIN = NONE,
  MAX = TableBuffer
};

inline const InlineBufferImpl (&EnumValuesInlineBufferImpl())[12] {
  static const InlineBufferImpl values[] = {
    InlineBufferImpl::NONE,
    InlineBufferImpl::Int8Buffer,
    InlineBufferImpl::Int16Buffer,
    InlineBufferImpl::Int32Buffer,
    InlineBufferImpl::Int64Buffer,
    InlineBufferImpl::UInt8Buffer,
    InlineBufferImpl::UInt16Buffer,
    InlineBufferImpl::UInt32Buffer,
    InlineBufferImpl::UInt64Buffer,
    InlineBufferImpl::Float32Buffer,
    InlineBufferImpl::Float64Buffer,
    InlineBufferImpl::TableBuffer
  };
  return values;
}

inline const char * const *EnumNamesInlineBufferImpl() {
  static const char * const names[13] = {
    "NONE",
    "Int8Buffer",
    "Int16Buffer",
    "Int32Buffer",
    "Int64Buffer",
    "UInt8Buffer",
    "UInt16Buffer",
    "UInt32Buffer",
    "UInt64Buffer",
    "Float32Buffer",
    "Float64Buffer",
    "TableBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameInlineBufferImpl(InlineBufferImpl e) {
  if (flatbuffers::IsOutRange(e, InlineBufferImpl::NONE, InlineBufferImpl::TableBuffer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInlineBufferImpl()[index];
}

template<typename T> struct InlineBufferImplTraits {
  static const InlineBufferImpl enum_value = InlineBufferImpl::NONE;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Int8Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int8Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Int16Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int16Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Int32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Int64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Int64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::UInt8Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt8Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::UInt16Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt16Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::UInt32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::UInt64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::UInt64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Float32Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Float32Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::Float64Buffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::Float64Buffer;
};

template<> struct InlineBufferImplTraits<org::apache::arrow::computeir::flatbuf::TableBuffer> {
  static const InlineBufferImpl enum_value = InlineBufferImpl::TableBuffer;
};

bool VerifyInlineBufferImpl(flatbuffers::Verifier &verifier, const void *obj, InlineBufferImpl type);
bool VerifyInlineBufferImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// An expression is one of
/// - a Literal datum
/// - a reference to a field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
enum class ExpressionImpl : uint8_t {
  NONE = 0,
  Literal = 1,
  FieldRef = 2,
  Call = 3,
  MIN = NONE,
  MAX = Call
};

inline const ExpressionImpl (&EnumValuesExpressionImpl())[4] {
  static const ExpressionImpl values[] = {
    ExpressionImpl::NONE,
    ExpressionImpl::Literal,
    ExpressionImpl::FieldRef,
    ExpressionImpl::Call
  };
  return values;
}

inline const char * const *EnumNamesExpressionImpl() {
  static const char * const names[5] = {
    "NONE",
    "Literal",
    "FieldRef",
    "Call",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpressionImpl(ExpressionImpl e) {
  if (flatbuffers::IsOutRange(e, ExpressionImpl::NONE, ExpressionImpl::Call)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpressionImpl()[index];
}

template<typename T> struct ExpressionImplTraits {
  static const ExpressionImpl enum_value = ExpressionImpl::NONE;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Literal> {
  static const ExpressionImpl enum_value = ExpressionImpl::Literal;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::FieldRef> {
  static const ExpressionImpl enum_value = ExpressionImpl::FieldRef;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Call> {
  static const ExpressionImpl enum_value = ExpressionImpl::Call;
};

bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type);
bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Shape : uint8_t {
  NONE = 0,
  Array = 1,
  Scalar = 2,
  MIN = NONE,
  MAX = Scalar
};

inline const Shape (&EnumValuesShape())[3] {
  static const Shape values[] = {
    Shape::NONE,
    Shape::Array,
    Shape::Scalar
  };
  return values;
}

inline const char * const *EnumNamesShape() {
  static const char * const names[4] = {
    "NONE",
    "Array",
    "Scalar",
    nullptr
  };
  return names;
}

inline const char *EnumNameShape(Shape e) {
  if (flatbuffers::IsOutRange(e, Shape::NONE, Shape::Scalar)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShape()[index];
}

template<typename T> struct ShapeTraits {
  static const Shape enum_value = Shape::NONE;
};

template<> struct ShapeTraits<org::apache::arrow::computeir::flatbuf::Array> {
  static const Shape enum_value = Shape::Array;
};

template<> struct ShapeTraits<org::apache::arrow::computeir::flatbuf::Scalar> {
  static const Shape enum_value = Shape::Scalar;
};

bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type);
bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Deref : uint8_t {
  NONE = 0,
  MapKey = 1,
  StructField = 2,
  ArraySubscript = 3,
  ArraySlice = 4,
  FieldName = 5,
  MIN = NONE,
  MAX = FieldName
};

inline const Deref (&EnumValuesDeref())[6] {
  static const Deref values[] = {
    Deref::NONE,
    Deref::MapKey,
    Deref::StructField,
    Deref::ArraySubscript,
    Deref::ArraySlice,
    Deref::FieldName
  };
  return values;
}

inline const char * const *EnumNamesDeref() {
  static const char * const names[7] = {
    "NONE",
    "MapKey",
    "StructField",
    "ArraySubscript",
    "ArraySlice",
    "FieldName",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeref(Deref e) {
  if (flatbuffers::IsOutRange(e, Deref::NONE, Deref::FieldName)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeref()[index];
}

template<typename T> struct DerefTraits {
  static const Deref enum_value = Deref::NONE;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::MapKey> {
  static const Deref enum_value = Deref::MapKey;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::StructField> {
  static const Deref enum_value = Deref::StructField;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySubscript> {
  static const Deref enum_value = Deref::ArraySubscript;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySlice> {
  static const Deref enum_value = Deref::ArraySlice;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::FieldName> {
  static const Deref enum_value = Deref::FieldName;
};

bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type);
bool VerifyDerefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A canonical (probably SQL equivalent) function
enum class CanonicalFunctionId : uint32_t {
  And = 0,
  Not = 1,
  Or = 2,
  Add = 3,
  Subtract = 4,
  Multiply = 5,
  Divide = 6,
  Power = 7,
  AbsoluteValue = 8,
  Negate = 9,
  Sign = 10,
  Equals = 11,
  NotEquals = 12,
  Greater = 13,
  GreaterEqual = 14,
  Less = 15,
  LessEqual = 16,
  All = 17,
  Any = 18,
  Count = 19,
  Mean = 20,
  Min = 21,
  Max = 22,
  Product = 23,
  Sum = 24,
  Variance = 25,
  StandardDeviation = 26,
  Cast = 27,
  Extract = 28,
  Case = 29,
  Coalesce = 30,
  IsIn = 31,
  MIN = And,
  MAX = IsIn
};

inline const CanonicalFunctionId (&EnumValuesCanonicalFunctionId())[32] {
  static const CanonicalFunctionId values[] = {
    CanonicalFunctionId::And,
    CanonicalFunctionId::Not,
    CanonicalFunctionId::Or,
    CanonicalFunctionId::Add,
    CanonicalFunctionId::Subtract,
    CanonicalFunctionId::Multiply,
    CanonicalFunctionId::Divide,
    CanonicalFunctionId::Power,
    CanonicalFunctionId::AbsoluteValue,
    CanonicalFunctionId::Negate,
    CanonicalFunctionId::Sign,
    CanonicalFunctionId::Equals,
    CanonicalFunctionId::NotEquals,
    CanonicalFunctionId::Greater,
    CanonicalFunctionId::GreaterEqual,
    CanonicalFunctionId::Less,
    CanonicalFunctionId::LessEqual,
    CanonicalFunctionId::All,
    CanonicalFunctionId::Any,
    CanonicalFunctionId::Count,
    CanonicalFunctionId::Mean,
    CanonicalFunctionId::Min,
    CanonicalFunctionId::Max,
    CanonicalFunctionId::Product,
    CanonicalFunctionId::Sum,
    CanonicalFunctionId::Variance,
    CanonicalFunctionId::StandardDeviation,
    CanonicalFunctionId::Cast,
    CanonicalFunctionId::Extract,
    CanonicalFunctionId::Case,
    CanonicalFunctionId::Coalesce,
    CanonicalFunctionId::IsIn
  };
  return values;
}

inline const char * const *EnumNamesCanonicalFunctionId() {
  static const char * const names[33] = {
    "And",
    "Not",
    "Or",
    "Add",
    "Subtract",
    "Multiply",
    "Divide",
    "Power",
    "AbsoluteValue",
    "Negate",
    "Sign",
    "Equals",
    "NotEquals",
    "Greater",
    "GreaterEqual",
    "Less",
    "LessEqual",
    "All",
    "Any",
    "Count",
    "Mean",
    "Min",
    "Max",
    "Product",
    "Sum",
    "Variance",
    "StandardDeviation",
    "Cast",
    "Extract",
    "Case",
    "Coalesce",
    "IsIn",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalFunctionId(CanonicalFunctionId e) {
  if (flatbuffers::IsOutRange(e, CanonicalFunctionId::And, CanonicalFunctionId::IsIn)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalFunctionId()[index];
}

enum class FunctionImpl : uint8_t {
  NONE = 0,
  CanonicalFunction = 1,
  NonCanonicalFunction = 2,
  MIN = NONE,
  MAX = NonCanonicalFunction
};

inline const FunctionImpl (&EnumValuesFunctionImpl())[3] {
  static const FunctionImpl values[] = {
    FunctionImpl::NONE,
    FunctionImpl::CanonicalFunction,
    FunctionImpl::NonCanonicalFunction
  };
  return values;
}

inline const char * const *EnumNamesFunctionImpl() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalFunction",
    "NonCanonicalFunction",
    nullptr
  };
  return names;
}

inline const char *EnumNameFunctionImpl(FunctionImpl e) {
  if (flatbuffers::IsOutRange(e, FunctionImpl::NONE, FunctionImpl::NonCanonicalFunction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFunctionImpl()[index];
}

template<typename T> struct FunctionImplTraits {
  static const FunctionImpl enum_value = FunctionImpl::NONE;
};

template<> struct FunctionImplTraits<org::apache::arrow::computeir::flatbuf::CanonicalFunction> {
  static const FunctionImpl enum_value = FunctionImpl::CanonicalFunction;
};

template<> struct FunctionImplTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalFunction> {
  static const FunctionImpl enum_value = FunctionImpl::NonCanonicalFunction;
};

bool VerifyFunctionImpl(flatbuffers::Verifier &verifier, const void *obj, FunctionImpl type);
bool VerifyFunctionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A union for the different colum remapping variants
enum class Emit : uint8_t {
  NONE = 0,
  Remap = 1,
  PassThrough = 2,
  MIN = NONE,
  MAX = PassThrough
};

inline const Emit (&EnumValuesEmit())[3] {
  static const Emit values[] = {
    Emit::NONE,
    Emit::Remap,
    Emit::PassThrough
  };
  return values;
}

inline const char * const *EnumNamesEmit() {
  static const char * const names[4] = {
    "NONE",
    "Remap",
    "PassThrough",
    nullptr
  };
  return names;
}

inline const char *EnumNameEmit(Emit e) {
  if (flatbuffers::IsOutRange(e, Emit::NONE, Emit::PassThrough)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmit()[index];
}

template<typename T> struct EmitTraits {
  static const Emit enum_value = Emit::NONE;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::Remap> {
  static const Emit enum_value = Emit::Remap;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::PassThrough> {
  static const Emit enum_value = Emit::PassThrough;
};

bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type);
bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class CanonicalJoinKindId : uint8_t {
  Anti = 0,
  Cross = 1,
  FullOuter = 2,
  Inner = 3,
  LeftOuter = 4,
  LeftSemi = 5,
  RightOuter = 6,
  MIN = Anti,
  MAX = RightOuter
};

inline const CanonicalJoinKindId (&EnumValuesCanonicalJoinKindId())[7] {
  static const CanonicalJoinKindId values[] = {
    CanonicalJoinKindId::Anti,
    CanonicalJoinKindId::Cross,
    CanonicalJoinKindId::FullOuter,
    CanonicalJoinKindId::Inner,
    CanonicalJoinKindId::LeftOuter,
    CanonicalJoinKindId::LeftSemi,
    CanonicalJoinKindId::RightOuter
  };
  return values;
}

inline const char * const *EnumNamesCanonicalJoinKindId() {
  static const char * const names[8] = {
    "Anti",
    "Cross",
    "FullOuter",
    "Inner",
    "LeftOuter",
    "LeftSemi",
    "RightOuter",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalJoinKindId(CanonicalJoinKindId e) {
  if (flatbuffers::IsOutRange(e, CanonicalJoinKindId::Anti, CanonicalJoinKindId::RightOuter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalJoinKindId()[index];
}

enum class JoinKind : uint8_t {
  NONE = 0,
  CanonicalJoinKind = 1,
  NonCanonicalJoinKind = 2,
  MIN = NONE,
  MAX = NonCanonicalJoinKind
};

inline const JoinKind (&EnumValuesJoinKind())[3] {
  static const JoinKind values[] = {
    JoinKind::NONE,
    JoinKind::CanonicalJoinKind,
    JoinKind::NonCanonicalJoinKind
  };
  return values;
}

inline const char * const *EnumNamesJoinKind() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalJoinKind",
    "NonCanonicalJoinKind",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinKind(JoinKind e) {
  if (flatbuffers::IsOutRange(e, JoinKind::NONE, JoinKind::NonCanonicalJoinKind)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinKind()[index];
}

template<typename T> struct JoinKindTraits {
  static const JoinKind enum_value = JoinKind::NONE;
};

template<> struct JoinKindTraits<org::apache::arrow::computeir::flatbuf::CanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::CanonicalJoinKind;
};

template<> struct JoinKindTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::NonCanonicalJoinKind;
};

bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type);
bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum class Ordering : uint8_t {
  ASCENDING_THEN_NULLS = 0,
  DESCENDING_THEN_NULLS = 1,
  NULLS_THEN_ASCENDING = 2,
  NULLS_THEN_DESCENDING = 3,
  MIN = ASCENDING_THEN_NULLS,
  MAX = NULLS_THEN_DESCENDING
};

inline const Ordering (&EnumValuesOrdering())[4] {
  static const Ordering values[] = {
    Ordering::ASCENDING_THEN_NULLS,
    Ordering::DESCENDING_THEN_NULLS,
    Ordering::NULLS_THEN_ASCENDING,
    Ordering::NULLS_THEN_DESCENDING
  };
  return values;
}

inline const char * const *EnumNamesOrdering() {
  static const char * const names[5] = {
    "ASCENDING_THEN_NULLS",
    "DESCENDING_THEN_NULLS",
    "NULLS_THEN_ASCENDING",
    "NULLS_THEN_DESCENDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrdering(Ordering e) {
  if (flatbuffers::IsOutRange(e, Ordering::ASCENDING_THEN_NULLS, Ordering::NULLS_THEN_DESCENDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrdering()[index];
}

/// The kind of set operation being performed.
enum class CanonicalSetOpKindId : uint8_t {
  Union = 0,
  Intersection = 1,
  Difference = 2,
  MIN = Union,
  MAX = Difference
};

inline const CanonicalSetOpKindId (&EnumValuesCanonicalSetOpKindId())[3] {
  static const CanonicalSetOpKindId values[] = {
    CanonicalSetOpKindId::Union,
    CanonicalSetOpKindId::Intersection,
    CanonicalSetOpKindId::Difference
  };
  return values;
}

inline const char * const *EnumNamesCanonicalSetOpKindId() {
  static const char * const names[4] = {
    "Union",
    "Intersection",
    "Difference",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalSetOpKindId(CanonicalSetOpKindId e) {
  if (flatbuffers::IsOutRange(e, CanonicalSetOpKindId::Union, CanonicalSetOpKindId::Difference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalSetOpKindId()[index];
}

enum class SetOpKind : uint8_t {
  NONE = 0,
  CanonicalSetOpKind = 1,
  NonCanonicalSetOpKind = 2,
  MIN = NONE,
  MAX = NonCanonicalSetOpKind
};

inline const SetOpKind (&EnumValuesSetOpKind())[3] {
  static const SetOpKind values[] = {
    SetOpKind::NONE,
    SetOpKind::CanonicalSetOpKind,
    SetOpKind::NonCanonicalSetOpKind
  };
  return values;
}

inline const char * const *EnumNamesSetOpKind() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalSetOpKind",
    "NonCanonicalSetOpKind",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetOpKind(SetOpKind e) {
  if (flatbuffers::IsOutRange(e, SetOpKind::NONE, SetOpKind::NonCanonicalSetOpKind)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetOpKind()[index];
}

template<typename T> struct SetOpKindTraits {
  static const SetOpKind enum_value = SetOpKind::NONE;
};

template<> struct SetOpKindTraits<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind> {
  static const SetOpKind enum_value = SetOpKind::CanonicalSetOpKind;
};

template<> struct SetOpKindTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind> {
  static const SetOpKind enum_value = SetOpKind::NonCanonicalSetOpKind;
};

bool VerifySetOpKind(flatbuffers::Verifier &verifier, const void *obj, SetOpKind type);
bool VerifySetOpKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class RelationImpl : uint8_t {
  NONE = 0,
  Aggregate = 1,
  Common = 2,
  Custom = 3,
  SetOperation = 4,
  Filter = 5,
  Limit = 6,
  LiteralRelation = 7,
  OrderBy = 8,
  Project = 9,
  Read = 10,
  Write = 11,
  MIN = NONE,
  MAX = Write
};

inline const RelationImpl (&EnumValuesRelationImpl())[12] {
  static const RelationImpl values[] = {
    RelationImpl::NONE,
    RelationImpl::Aggregate,
    RelationImpl::Common,
    RelationImpl::Custom,
    RelationImpl::SetOperation,
    RelationImpl::Filter,
    RelationImpl::Limit,
    RelationImpl::LiteralRelation,
    RelationImpl::OrderBy,
    RelationImpl::Project,
    RelationImpl::Read,
    RelationImpl::Write
  };
  return values;
}

inline const char * const *EnumNamesRelationImpl() {
  static const char * const names[13] = {
    "NONE",
    "Aggregate",
    "Common",
    "Custom",
    "SetOperation",
    "Filter",
    "Limit",
    "LiteralRelation",
    "OrderBy",
    "Project",
    "Read",
    "Write",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelationImpl(RelationImpl e) {
  if (flatbuffers::IsOutRange(e, RelationImpl::NONE, RelationImpl::Write)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelationImpl()[index];
}

template<typename T> struct RelationImplTraits {
  static const RelationImpl enum_value = RelationImpl::NONE;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Aggregate> {
  static const RelationImpl enum_value = RelationImpl::Aggregate;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Common> {
  static const RelationImpl enum_value = RelationImpl::Common;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Custom> {
  static const RelationImpl enum_value = RelationImpl::Custom;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::SetOperation> {
  static const RelationImpl enum_value = RelationImpl::SetOperation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Filter> {
  static const RelationImpl enum_value = RelationImpl::Filter;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Limit> {
  static const RelationImpl enum_value = RelationImpl::Limit;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::LiteralRelation> {
  static const RelationImpl enum_value = RelationImpl::LiteralRelation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::OrderBy> {
  static const RelationImpl enum_value = RelationImpl::OrderBy;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Project> {
  static const RelationImpl enum_value = RelationImpl::Project;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Read> {
  static const RelationImpl enum_value = RelationImpl::Read;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Write> {
  static const RelationImpl enum_value = RelationImpl::Write;
};

bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type);
bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Int8Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int8BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int8BufferBuilder {
  typedef Int8Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(Int8Buffer::VT_ITEMS, items);
  }
  explicit Int8BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int8BufferBuilder &operator=(const Int8BufferBuilder &);
  flatbuffers::Offset<Int8Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int8Buffer>(end);
    fbb_.Required(o, Int8Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int8Buffer> CreateInt8Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  Int8BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int8Buffer> CreateInt8BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateInt8Buffer(
      _fbb,
      items__);
}

struct Int16Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int16BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint16_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int16BufferBuilder {
  typedef Int16Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items) {
    fbb_.AddOffset(Int16Buffer::VT_ITEMS, items);
  }
  explicit Int16BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int16BufferBuilder &operator=(const Int16BufferBuilder &);
  flatbuffers::Offset<Int16Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int16Buffer>(end);
    fbb_.Required(o, Int16Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int16Buffer> CreateInt16Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items = 0) {
  Int16BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int16Buffer> CreateInt16BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint16_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateInt16Buffer(
      _fbb,
      items__);
}

struct Int32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int32BufferBuilder {
  typedef Int32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(Int32Buffer::VT_ITEMS, items);
  }
  explicit Int32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32BufferBuilder &operator=(const Int32BufferBuilder &);
  flatbuffers::Offset<Int32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Buffer>(end);
    fbb_.Required(o, Int32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int32Buffer> CreateInt32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items = 0) {
  Int32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Buffer> CreateInt32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateInt32Buffer(
      _fbb,
      items__);
}

struct Int64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Int64BufferBuilder {
  typedef Int64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items) {
    fbb_.AddOffset(Int64Buffer::VT_ITEMS, items);
  }
  explicit Int64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int64BufferBuilder &operator=(const Int64BufferBuilder &);
  flatbuffers::Offset<Int64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int64Buffer>(end);
    fbb_.Required(o, Int64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Int64Buffer> CreateInt64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items = 0) {
  Int64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int64Buffer> CreateInt64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint64_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateInt64Buffer(
      _fbb,
      items__);
}

struct UInt8Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt8BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt8BufferBuilder {
  typedef UInt8Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(UInt8Buffer::VT_ITEMS, items);
  }
  explicit UInt8BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt8BufferBuilder &operator=(const UInt8BufferBuilder &);
  flatbuffers::Offset<UInt8Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt8Buffer>(end);
    fbb_.Required(o, UInt8Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt8Buffer> CreateUInt8Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  UInt8BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt8Buffer> CreateUInt8BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateUInt8Buffer(
      _fbb,
      items__);
}

struct UInt16Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt16BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint16_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt16BufferBuilder {
  typedef UInt16Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items) {
    fbb_.AddOffset(UInt16Buffer::VT_ITEMS, items);
  }
  explicit UInt16BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt16BufferBuilder &operator=(const UInt16BufferBuilder &);
  flatbuffers::Offset<UInt16Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt16Buffer>(end);
    fbb_.Required(o, UInt16Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt16Buffer> CreateUInt16Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> items = 0) {
  UInt16BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt16Buffer> CreateUInt16BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint16_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateUInt16Buffer(
      _fbb,
      items__);
}

struct UInt32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt32BufferBuilder {
  typedef UInt32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(UInt32Buffer::VT_ITEMS, items);
  }
  explicit UInt32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt32BufferBuilder &operator=(const UInt32BufferBuilder &);
  flatbuffers::Offset<UInt32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt32Buffer>(end);
    fbb_.Required(o, UInt32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt32Buffer> CreateUInt32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> items = 0) {
  UInt32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt32Buffer> CreateUInt32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateUInt32Buffer(
      _fbb,
      items__);
}

struct UInt64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct UInt64BufferBuilder {
  typedef UInt64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items) {
    fbb_.AddOffset(UInt64Buffer::VT_ITEMS, items);
  }
  explicit UInt64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt64BufferBuilder &operator=(const UInt64BufferBuilder &);
  flatbuffers::Offset<UInt64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt64Buffer>(end);
    fbb_.Required(o, UInt64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UInt64Buffer> CreateUInt64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> items = 0) {
  UInt64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<UInt64Buffer> CreateUInt64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint64_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateUInt64Buffer(
      _fbb,
      items__);
}

struct Float32Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float32BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<float> *items() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Float32BufferBuilder {
  typedef Float32Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<float>> items) {
    fbb_.AddOffset(Float32Buffer::VT_ITEMS, items);
  }
  explicit Float32BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float32BufferBuilder &operator=(const Float32BufferBuilder &);
  flatbuffers::Offset<Float32Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float32Buffer>(end);
    fbb_.Required(o, Float32Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Float32Buffer> CreateFloat32Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> items = 0) {
  Float32BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float32Buffer> CreateFloat32BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<float>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateFloat32Buffer(
      _fbb,
      items__);
}

struct Float64Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float64BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<double> *items() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct Float64BufferBuilder {
  typedef Float64Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(Float64Buffer::VT_ITEMS, items);
  }
  explicit Float64BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float64BufferBuilder &operator=(const Float64BufferBuilder &);
  flatbuffers::Offset<Float64Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float64Buffer>(end);
    fbb_.Required(o, Float64Buffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<Float64Buffer> CreateFloat64Buffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> items = 0) {
  Float64BufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float64Buffer> CreateFloat64BufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateFloat64Buffer(
      _fbb,
      items__);
}

struct TableBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *items_nested_root() const {
    return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::InlineBuffer>(items()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct TableBufferBuilder {
  typedef TableBuffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(TableBuffer::VT_ITEMS, items);
  }
  explicit TableBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableBufferBuilder &operator=(const TableBufferBuilder &);
  flatbuffers::Offset<TableBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableBuffer>(end);
    fbb_.Required(o, TableBuffer::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<TableBuffer> CreateTableBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  TableBufferBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableBuffer> CreateTableBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateTableBuffer(
      _fbb,
      items__);
}

/// An inline replacement for org.apache.arrow.Buffer because that
/// requires a sidecar block of bytes into which offsets can point.
/// A union of buffers of each primitive type is provided to avoid
/// the need for reinterpret_cast, std::mem::transmute, ...
/// The final member of the union is a bytes buffer aligned suitably
/// to hold any flatbuffer Table.
struct InlineBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InlineBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::InlineBufferImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::InlineBufferImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Int8Buffer *impl_as_Int8Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Int8Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Int8Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int16Buffer *impl_as_Int16Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Int16Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Int16Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int32Buffer *impl_as_Int32Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Int32Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Int32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int64Buffer *impl_as_Int64Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Int64Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Int64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt8Buffer *impl_as_UInt8Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::UInt8Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt8Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt16Buffer *impl_as_UInt16Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::UInt16Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt16Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt32Buffer *impl_as_UInt32Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::UInt32Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt64Buffer *impl_as_UInt64Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::UInt64Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Float32Buffer *impl_as_Float32Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Float32Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Float32Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Float64Buffer *impl_as_Float64Buffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::Float64Buffer ? static_cast<const org::apache::arrow::computeir::flatbuf::Float64Buffer *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::TableBuffer *impl_as_TableBuffer() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::InlineBufferImpl::TableBuffer ? static_cast<const org::apache::arrow::computeir::flatbuf::TableBuffer *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyInlineBufferImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Int8Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Int8Buffer>() const {
  return impl_as_Int8Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int16Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Int16Buffer>() const {
  return impl_as_Int16Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int32Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Int32Buffer>() const {
  return impl_as_Int32Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int64Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Int64Buffer>() const {
  return impl_as_Int64Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt8Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::UInt8Buffer>() const {
  return impl_as_UInt8Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt16Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::UInt16Buffer>() const {
  return impl_as_UInt16Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt32Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::UInt32Buffer>() const {
  return impl_as_UInt32Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt64Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::UInt64Buffer>() const {
  return impl_as_UInt64Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Float32Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Float32Buffer>() const {
  return impl_as_Float32Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Float64Buffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::Float64Buffer>() const {
  return impl_as_Float64Buffer();
}

template<> inline const org::apache::arrow::computeir::flatbuf::TableBuffer *InlineBuffer::impl_as<org::apache::arrow::computeir::flatbuf::TableBuffer>() const {
  return impl_as_TableBuffer();
}

struct InlineBufferBuilder {
  typedef InlineBuffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::InlineBufferImpl impl_type) {
    fbb_.AddElement<uint8_t>(InlineBuffer::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(InlineBuffer::VT_IMPL, impl);
  }
  explicit InlineBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InlineBufferBuilder &operator=(const InlineBufferBuilder &);
  flatbuffers::Offset<InlineBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InlineBuffer>(end);
    fbb_.Required(o, InlineBuffer::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<InlineBuffer> CreateInlineBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::InlineBufferImpl impl_type = org::apache::arrow::computeir::flatbuf::InlineBufferImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  InlineBufferBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

struct Expression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::ExpressionImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Literal *impl_as_Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::FieldRef *impl_as_FieldRef() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::FieldRef ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Call *impl_as_Call() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Call ? static_cast<const org::apache::arrow::computeir::flatbuf::Call *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyExpressionImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Literal *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Literal>() const {
  return impl_as_Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::FieldRef *Expression::impl_as<org::apache::arrow::computeir::flatbuf::FieldRef>() const {
  return impl_as_FieldRef();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Call *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Call>() const {
  return impl_as_Call();
}

struct ExpressionBuilder {
  typedef Expression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type) {
    fbb_.AddElement<uint8_t>(Expression::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Expression::VT_IMPL, impl);
  }
  explicit ExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionBuilder &operator=(const ExpressionBuilder &);
  flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expression>(end);
    fbb_.Required(o, Expression::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Expression> CreateExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type = org::apache::arrow::computeir::flatbuf::ExpressionImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScalarBuilder {
  typedef Scalar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScalarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScalarBuilder &operator=(const ScalarBuilder &);
  flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scalar> CreateScalar(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScalarBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LENGTH = 4
  };
  /// Number of slots.
  int64_t length() const {
    return GetField<int64_t>(VT_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct ArrayBuilder {
  typedef Array Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int64_t length) {
    fbb_.AddElement<int64_t>(Array::VT_LENGTH, length, 0);
  }
  explicit ArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArrayBuilder &operator=(const ArrayBuilder &);
  flatbuffers::Offset<Array> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Array>(end);
    return o;
  }
};

inline flatbuffers::Offset<Array> CreateArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t length = 0) {
  ArrayBuilder builder_(_fbb);
  builder_.add_length(length);
  return builder_.Finish();
}

struct MapKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct MapKeyBuilder {
  typedef MapKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(MapKey::VT_KEY, key);
  }
  explicit MapKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapKeyBuilder &operator=(const MapKeyBuilder &);
  flatbuffers::Offset<MapKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapKey>(end);
    fbb_.Required(o, MapKey::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<MapKey> CreateMapKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  MapKeyBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapKey> CreateMapKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateMapKey(
      _fbb,
      key__);
}

struct StructField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_NESTING_LEVEL = 6
  };
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  uint32_t nesting_level() const {
    return GetField<uint32_t>(VT_NESTING_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POSITION) &&
           VerifyField<uint32_t>(verifier, VT_NESTING_LEVEL) &&
           verifier.EndTable();
  }
};

struct StructFieldBuilder {
  typedef StructField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(StructField::VT_POSITION, position, 0);
  }
  void add_nesting_level(uint32_t nesting_level) {
    fbb_.AddElement<uint32_t>(StructField::VT_NESTING_LEVEL, nesting_level, 0);
  }
  explicit StructFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructFieldBuilder &operator=(const StructFieldBuilder &);
  flatbuffers::Offset<StructField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructField>(end);
    return o;
  }
};

inline flatbuffers::Offset<StructField> CreateStructField(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t position = 0,
    uint32_t nesting_level = 0) {
  StructFieldBuilder builder_(_fbb);
  builder_.add_nesting_level(nesting_level);
  builder_.add_position(position);
  return builder_.Finish();
}

struct ArraySubscript FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArraySubscriptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  int64_t position() const {
    return GetField<int64_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct ArraySubscriptBuilder {
  typedef ArraySubscript Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(int64_t position) {
    fbb_.AddElement<int64_t>(ArraySubscript::VT_POSITION, position, 0);
  }
  explicit ArraySubscriptBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArraySubscriptBuilder &operator=(const ArraySubscriptBuilder &);
  flatbuffers::Offset<ArraySubscript> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArraySubscript>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArraySubscript> CreateArraySubscript(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t position = 0) {
  ArraySubscriptBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct ArraySlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArraySliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_INCLUSIVE = 4,
    VT_END_EXCLUSIVE = 6
  };
  int64_t start_inclusive() const {
    return GetField<int64_t>(VT_START_INCLUSIVE, 0);
  }
  int64_t end_exclusive() const {
    return GetField<int64_t>(VT_END_EXCLUSIVE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_START_INCLUSIVE) &&
           VerifyField<int64_t>(verifier, VT_END_EXCLUSIVE) &&
           verifier.EndTable();
  }
};

struct ArraySliceBuilder {
  typedef ArraySlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_inclusive(int64_t start_inclusive) {
    fbb_.AddElement<int64_t>(ArraySlice::VT_START_INCLUSIVE, start_inclusive, 0);
  }
  void add_end_exclusive(int64_t end_exclusive) {
    fbb_.AddElement<int64_t>(ArraySlice::VT_END_EXCLUSIVE, end_exclusive, 0);
  }
  explicit ArraySliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArraySliceBuilder &operator=(const ArraySliceBuilder &);
  flatbuffers::Offset<ArraySlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArraySlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArraySlice> CreateArraySlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t start_inclusive = 0,
    int64_t end_exclusive = 0) {
  ArraySliceBuilder builder_(_fbb);
  builder_.add_end_exclusive(end_exclusive);
  builder_.add_start_inclusive(start_inclusive);
  return builder_.Finish();
}

struct FieldName FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct FieldNameBuilder {
  typedef FieldName Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(FieldName::VT_POSITION, position, 0);
  }
  explicit FieldNameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldNameBuilder &operator=(const FieldNameBuilder &);
  flatbuffers::Offset<FieldName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldName>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldName> CreateFieldName(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t position = 0) {
  FieldNameBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct FieldRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REF_TYPE = 4,
    VT_REF = 6,
    VT_RELATION_INDEX = 8
  };
  org::apache::arrow::computeir::flatbuf::Deref ref_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Deref>(GetField<uint8_t>(VT_REF_TYPE, 0));
  }
  /// A sequence of field names to allow referencing potentially nested fields
  const void *ref() const {
    return GetPointer<const void *>(VT_REF);
  }
  template<typename T> const T *ref_as() const;
  const org::apache::arrow::computeir::flatbuf::MapKey *ref_as_MapKey() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::MapKey ? static_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::StructField *ref_as_StructField() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::StructField ? static_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::ArraySubscript *ref_as_ArraySubscript() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::ArraySubscript ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::ArraySlice *ref_as_ArraySlice() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::ArraySlice ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::FieldName *ref_as_FieldName() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::FieldName ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldName *>(ref()) : nullptr;
  }
  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  int32_t relation_index() const {
    return GetField<int32_t>(VT_RELATION_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REF_TYPE) &&
           VerifyOffsetRequired(verifier, VT_REF) &&
           VerifyDeref(verifier, ref(), ref_type()) &&
           VerifyField<int32_t>(verifier, VT_RELATION_INDEX) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::MapKey *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::MapKey>() const {
  return ref_as_MapKey();
}

template<> inline const org::apache::arrow::computeir::flatbuf::StructField *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::StructField>() const {
  return ref_as_StructField();
}

template<> inline const org::apache::arrow::computeir::flatbuf::ArraySubscript *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySubscript>() const {
  return ref_as_ArraySubscript();
}

template<> inline const org::apache::arrow::computeir::flatbuf::ArraySlice *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySlice>() const {
  return ref_as_ArraySlice();
}

template<> inline const org::apache::arrow::computeir::flatbuf::FieldName *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::FieldName>() const {
  return ref_as_FieldName();
}

struct FieldRefBuilder {
  typedef FieldRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ref_type(org::apache::arrow::computeir::flatbuf::Deref ref_type) {
    fbb_.AddElement<uint8_t>(FieldRef::VT_REF_TYPE, static_cast<uint8_t>(ref_type), 0);
  }
  void add_ref(flatbuffers::Offset<void> ref) {
    fbb_.AddOffset(FieldRef::VT_REF, ref);
  }
  void add_relation_index(int32_t relation_index) {
    fbb_.AddElement<int32_t>(FieldRef::VT_RELATION_INDEX, relation_index, 0);
  }
  explicit FieldRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldRefBuilder &operator=(const FieldRefBuilder &);
  flatbuffers::Offset<FieldRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldRef>(end);
    fbb_.Required(o, FieldRef::VT_REF);
    return o;
  }
};

inline flatbuffers::Offset<FieldRef> CreateFieldRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Deref ref_type = org::apache::arrow::computeir::flatbuf::Deref::NONE,
    flatbuffers::Offset<void> ref = 0,
    int32_t relation_index = 0) {
  FieldRefBuilder builder_(_fbb);
  builder_.add_relation_index(relation_index);
  builder_.add_ref(ref);
  builder_.add_ref_type(ref_type);
  return builder_.Finish();
}

struct CanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalFunctionId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalFunctionBuilder {
  typedef CanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id) {
    fbb_.AddElement<uint32_t>(CanonicalFunction::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalFunctionBuilder &operator=(const CanonicalFunctionBuilder &);
  flatbuffers::Offset<CanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalFunction> CreateCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id = org::apache::arrow::computeir::flatbuf::CanonicalFunctionId::And) {
  CanonicalFunctionBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalFunctionBuilder {
  typedef NonCanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME, name);
  }
  explicit NonCanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalFunctionBuilder &operator=(const NonCanonicalFunctionBuilder &);
  flatbuffers::Offset<NonCanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalFunction>(end);
    fbb_.Required(o, NonCanonicalFunction::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalFunctionBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalFunction(
      _fbb,
      name_space__,
      name__);
}

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND_TYPE = 4,
    VT_KIND = 6,
    VT_ARGUMENTS = 8,
    VT_METADATA = 10
  };
  org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::FunctionImpl>(GetField<uint8_t>(VT_KIND_TYPE, 0));
  }
  /// The kind of function call this is
  const void *kind() const {
    return GetPointer<const void *>(VT_KIND);
  }
  template<typename T> const T *kind_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalFunction *kind_as_CanonicalFunction() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::FunctionImpl::CanonicalFunction ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalFunction *>(kind()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *kind_as_NonCanonicalFunction() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::FunctionImpl::NonCanonicalFunction ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *>(kind()) : nullptr;
  }
  /// The arguments passed to `function_name`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_ARGUMENTS);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *metadata() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           VerifyFunctionImpl(verifier, kind(), kind_type()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalFunction *Call::kind_as<org::apache::arrow::computeir::flatbuf::CanonicalFunction>() const {
  return kind_as_CanonicalFunction();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *Call::kind_as<org::apache::arrow::computeir::flatbuf::NonCanonicalFunction>() const {
  return kind_as_NonCanonicalFunction();
}

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind_type(org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type) {
    fbb_.AddElement<uint8_t>(Call::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
  }
  void add_kind(flatbuffers::Offset<void> kind) {
    fbb_.AddOffset(Call::VT_KIND, kind);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments) {
    fbb_.AddOffset(Call::VT_ARGUMENTS, arguments);
  }
  void add_metadata(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata) {
    fbb_.AddOffset(Call::VT_METADATA, metadata);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    fbb_.Required(o, Call::VT_KIND);
    fbb_.Required(o, Call::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type = org::apache::arrow::computeir::flatbuf::FunctionImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_arguments(arguments);
  builder_.add_kind(kind);
  builder_.add_kind_type(kind_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Call> CreateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type = org::apache::arrow::computeir::flatbuf::FunctionImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*arguments) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateCall(
      _fbb,
      kind_type,
      kind,
      arguments__,
      metadata);
}

/// A data type indicating a different mapping of columns
/// should occur in the output.
///
/// For example:
///
/// Given a query `SELECT a, b FROM t` where `t` has columns a, b, c
/// the mapping value for the projection would equal [0, 1].
struct Remap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPPING = 4
  };
  const flatbuffers::Vector<uint32_t> *mapping() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MAPPING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MAPPING) &&
           verifier.VerifyVector(mapping()) &&
           verifier.EndTable();
  }
};

struct RemapBuilder {
  typedef Remap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mapping(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> mapping) {
    fbb_.AddOffset(Remap::VT_MAPPING, mapping);
  }
  explicit RemapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemapBuilder &operator=(const RemapBuilder &);
  flatbuffers::Offset<Remap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Remap>(end);
    fbb_.Required(o, Remap::VT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<Remap> CreateRemap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> mapping = 0) {
  RemapBuilder builder_(_fbb);
  builder_.add_mapping(mapping);
  return builder_.Finish();
}

inline flatbuffers::Offset<Remap> CreateRemapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *mapping = nullptr) {
  auto mapping__ = mapping ? _fbb.CreateVector<uint32_t>(*mapping) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRemap(
      _fbb,
      mapping__);
}

struct PassThrough FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassThroughBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PassThroughBuilder {
  typedef PassThrough Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PassThroughBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassThroughBuilder &operator=(const PassThroughBuilder &);
  flatbuffers::Offset<PassThrough> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassThrough>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassThrough> CreatePassThrough(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PassThroughBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Fields common to every relational operator
struct RelBase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelBaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENTS = 4,
    VT_OUTPUT_MAPPING_TYPE = 6,
    VT_OUTPUT_MAPPING = 8,
    VT_OPTIONS = 10
  };
  /// The arguments passed to `operation`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *>(VT_ARGUMENTS);
  }
  org::apache::arrow::computeir::flatbuf::Emit output_mapping_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Emit>(GetField<uint8_t>(VT_OUTPUT_MAPPING_TYPE, 0));
  }
  /// Output remapping of ordinals for a given operation
  const void *output_mapping() const {
    return GetPointer<const void *>(VT_OUTPUT_MAPPING);
  }
  template<typename T> const T *output_mapping_as() const;
  const org::apache::arrow::computeir::flatbuf::Remap *output_mapping_as_Remap() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit::Remap ? static_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(output_mapping()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::PassThrough *output_mapping_as_PassThrough() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit::PassThrough ? static_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(output_mapping()) : nullptr;
  }
  /// Arguments for custom operations
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *options() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_MAPPING_TYPE) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT_MAPPING) &&
           VerifyEmit(verifier, output_mapping(), output_mapping_type()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Remap *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::Remap>() const {
  return output_mapping_as_Remap();
}

template<> inline const org::apache::arrow::computeir::flatbuf::PassThrough *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::PassThrough>() const {
  return output_mapping_as_PassThrough();
}

struct RelBaseBuilder {
  typedef RelBase Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> arguments) {
    fbb_.AddOffset(RelBase::VT_ARGUMENTS, arguments);
  }
  void add_output_mapping_type(org::apache::arrow::computeir::flatbuf::Emit output_mapping_type) {
    fbb_.AddElement<uint8_t>(RelBase::VT_OUTPUT_MAPPING_TYPE, static_cast<uint8_t>(output_mapping_type), 0);
  }
  void add_output_mapping(flatbuffers::Offset<void> output_mapping) {
    fbb_.AddOffset(RelBase::VT_OUTPUT_MAPPING, output_mapping);
  }
  void add_options(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options) {
    fbb_.AddOffset(RelBase::VT_OPTIONS, options);
  }
  explicit RelBaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelBaseBuilder &operator=(const RelBaseBuilder &);
  flatbuffers::Offset<RelBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelBase>(end);
    fbb_.Required(o, RelBase::VT_ARGUMENTS);
    fbb_.Required(o, RelBase::VT_OUTPUT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<RelBase> CreateRelBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> arguments = 0,
    org::apache::arrow::computeir::flatbuf::Emit output_mapping_type = org::apache::arrow::computeir::flatbuf::Emit::NONE,
    flatbuffers::Offset<void> output_mapping = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options = 0) {
  RelBaseBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_output_mapping(output_mapping);
  builder_.add_arguments(arguments);
  builder_.add_output_mapping_type(output_mapping_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelBase> CreateRelBaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *arguments = nullptr,
    org::apache::arrow::computeir::flatbuf::Emit output_mapping_type = org::apache::arrow::computeir::flatbuf::Emit::NONE,
    flatbuffers::Offset<void> output_mapping = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>(*arguments) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRelBase(
      _fbb,
      arguments__,
      output_mapping_type,
      output_mapping,
      options);
}

/// Filter operation
struct Filter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_PREDICATE = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// filter relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *predicate() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_PREDICATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_PREDICATE) &&
           verifier.VerifyTable(predicate()) &&
           verifier.EndTable();
  }
};

struct FilterBuilder {
  typedef Filter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Filter::VT_BASE, base);
  }
  void add_predicate(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate) {
    fbb_.AddOffset(Filter::VT_PREDICATE, predicate);
  }
  explicit FilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FilterBuilder &operator=(const FilterBuilder &);
  flatbuffers::Offset<Filter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Filter>(end);
    fbb_.Required(o, Filter::VT_PREDICATE);
    return o;
  }
};

inline flatbuffers::Offset<Filter> CreateFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate = 0) {
  FilterBuilder builder_(_fbb);
  builder_.add_predicate(predicate);
  builder_.add_base(base);
  return builder_.Finish();
}

/// Projection
struct Project FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_EXPRESSIONS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the project relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_EXPRESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(expressions()) &&
           verifier.VerifyVectorOfTables(expressions()) &&
           verifier.EndTable();
  }
};

struct ProjectBuilder {
  typedef Project Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Project::VT_BASE, base);
  }
  void add_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions) {
    fbb_.AddOffset(Project::VT_EXPRESSIONS, expressions);
  }
  explicit ProjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectBuilder &operator=(const ProjectBuilder &);
  flatbuffers::Offset<Project> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Project>(end);
    fbb_.Required(o, Project::VT_EXPRESSIONS);
    return o;
  }
};

inline flatbuffers::Offset<Project> CreateProject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions = 0) {
  ProjectBuilder builder_(_fbb);
  builder_.add_expressions(expressions);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Project> CreateProjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions = nullptr) {
  auto expressions__ = expressions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*expressions) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateProject(
      _fbb,
      base,
      expressions__);
}

/// Aggregate operation
struct Aggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_AGGREGATIONS = 6,
    VT_KEYS = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the aggregate relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *aggregations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_AGGREGATIONS);
  }
  /// Keys by which `aggregations` will be grouped.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_AGGREGATIONS) &&
           verifier.VerifyVector(aggregations()) &&
           verifier.VerifyVectorOfTables(aggregations()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct AggregateBuilder {
  typedef Aggregate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Aggregate::VT_BASE, base);
  }
  void add_aggregations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> aggregations) {
    fbb_.AddOffset(Aggregate::VT_AGGREGATIONS, aggregations);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys) {
    fbb_.AddOffset(Aggregate::VT_KEYS, keys);
  }
  explicit AggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateBuilder &operator=(const AggregateBuilder &);
  flatbuffers::Offset<Aggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Aggregate>(end);
    fbb_.Required(o, Aggregate::VT_AGGREGATIONS);
    fbb_.Required(o, Aggregate::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<Aggregate> CreateAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> aggregations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys = 0) {
  AggregateBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_aggregations(aggregations);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Aggregate> CreateAggregateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *aggregations = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys = nullptr) {
  auto aggregations__ = aggregations ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*aggregations) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateAggregate(
      _fbb,
      base,
      aggregations__,
      keys__);
}

struct CanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId>(GetField<uint8_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalJoinKindBuilder {
  typedef CanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id) {
    fbb_.AddElement<uint8_t>(CanonicalJoinKind::VT_ID, static_cast<uint8_t>(id), 0);
  }
  explicit CanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalJoinKindBuilder &operator=(const CanonicalJoinKindBuilder &);
  flatbuffers::Offset<CanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalJoinKind>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalJoinKind> CreateCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id = org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId::Anti) {
  CanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalJoinKindBuilder {
  typedef NonCanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME, name);
  }
  explicit NonCanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalJoinKindBuilder &operator=(const NonCanonicalJoinKindBuilder &);
  flatbuffers::Offset<NonCanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalJoinKind>(end);
    fbb_.Required(o, NonCanonicalJoinKind::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKindDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalJoinKind(
      _fbb,
      name_space__,
      name__);
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.operation = CanonicalOperation::Join
struct Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_ON_EXPRESSION = 6,
    VT_JOIN_KIND_TYPE = 8,
    VT_JOIN_KIND = 10
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// join relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *on_expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_ON_EXPRESSION);
  }
  org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::JoinKind>(GetField<uint8_t>(VT_JOIN_KIND_TYPE, 0));
  }
  /// The kind of join to use.
  const void *join_kind() const {
    return GetPointer<const void *>(VT_JOIN_KIND);
  }
  template<typename T> const T *join_kind_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *join_kind_as_CanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::computeir::flatbuf::JoinKind::CanonicalJoinKind ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *>(join_kind()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *join_kind_as_NonCanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::computeir::flatbuf::JoinKind::NonCanonicalJoinKind ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *>(join_kind()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_ON_EXPRESSION) &&
           verifier.VerifyTable(on_expression()) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_JOIN_KIND) &&
           VerifyJoinKind(verifier, join_kind(), join_kind_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *Join::join_kind_as<org::apache::arrow::computeir::flatbuf::CanonicalJoinKind>() const {
  return join_kind_as_CanonicalJoinKind();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *Join::join_kind_as<org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind>() const {
  return join_kind_as_NonCanonicalJoinKind();
}

struct JoinBuilder {
  typedef Join Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Join::VT_BASE, base);
  }
  void add_on_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression) {
    fbb_.AddOffset(Join::VT_ON_EXPRESSION, on_expression);
  }
  void add_join_kind_type(org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type) {
    fbb_.AddElement<uint8_t>(Join::VT_JOIN_KIND_TYPE, static_cast<uint8_t>(join_kind_type), 0);
  }
  void add_join_kind(flatbuffers::Offset<void> join_kind) {
    fbb_.AddOffset(Join::VT_JOIN_KIND, join_kind);
  }
  explicit JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinBuilder &operator=(const JoinBuilder &);
  flatbuffers::Offset<Join> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Join>(end);
    fbb_.Required(o, Join::VT_ON_EXPRESSION);
    fbb_.Required(o, Join::VT_JOIN_KIND);
    return o;
  }
};

inline flatbuffers::Offset<Join> CreateJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression = 0,
    org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type = org::apache::arrow::computeir::flatbuf::JoinKind::NONE,
    flatbuffers::Offset<void> join_kind = 0) {
  JoinBuilder builder_(_fbb);
  builder_.add_join_kind(join_kind);
  builder_.add_on_expression(on_expression);
  builder_.add_base(base);
  builder_.add_join_kind_type(join_kind_type);
  return builder_.Finish();
}

struct SortKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_ORDERING = 6
  };
  const org::apache::arrow::computeir::flatbuf::Expression *value() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_VALUE);
  }
  org::apache::arrow::computeir::flatbuf::Ordering ordering() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Ordering>(GetField<uint8_t>(VT_ORDERING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyField<uint8_t>(verifier, VT_ORDERING) &&
           verifier.EndTable();
  }
};

struct SortKeyBuilder {
  typedef SortKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> value) {
    fbb_.AddOffset(SortKey::VT_VALUE, value);
  }
  void add_ordering(org::apache::arrow::computeir::flatbuf::Ordering ordering) {
    fbb_.AddElement<uint8_t>(SortKey::VT_ORDERING, static_cast<uint8_t>(ordering), 0);
  }
  explicit SortKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortKeyBuilder &operator=(const SortKeyBuilder &);
  flatbuffers::Offset<SortKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortKey>(end);
    fbb_.Required(o, SortKey::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<SortKey> CreateSortKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> value = 0,
    org::apache::arrow::computeir::flatbuf::Ordering ordering = org::apache::arrow::computeir::flatbuf::Ordering::ASCENDING_THEN_NULLS) {
  SortKeyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_ordering(ordering);
  return builder_.Finish();
}

/// Order by relation
struct OrderBy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderByBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_KEYS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct OrderByBuilder {
  typedef OrderBy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(OrderBy::VT_BASE, base);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys) {
    fbb_.AddOffset(OrderBy::VT_KEYS, keys);
  }
  explicit OrderByBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderByBuilder &operator=(const OrderByBuilder &);
  flatbuffers::Offset<OrderBy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderBy>(end);
    fbb_.Required(o, OrderBy::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<OrderBy> CreateOrderBy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys = 0) {
  OrderByBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderBy> CreateOrderByDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateOrderBy(
      _fbb,
      base,
      keys__);
}

/// Limit operation
struct Limit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LimitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_COUNT = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Set the maximum number of rows of output.
  int64_t count() const {
    return GetField<int64_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<int64_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LimitBuilder {
  typedef Limit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Limit::VT_BASE, base);
  }
  void add_count(int64_t count) {
    fbb_.AddElement<int64_t>(Limit::VT_COUNT, count, 0);
  }
  explicit LimitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LimitBuilder &operator=(const LimitBuilder &);
  flatbuffers::Offset<Limit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Limit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Limit> CreateLimit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    int64_t count = 0) {
  LimitBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_base(base);
  return builder_.Finish();
}

/// Common table expresssion
struct Common FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_NAME = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CommonBuilder {
  typedef Common Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Common::VT_BASE, base);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Common::VT_NAME, name);
  }
  explicit CommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommonBuilder &operator=(const CommonBuilder &);
  flatbuffers::Offset<Common> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Common>(end);
    fbb_.Required(o, Common::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Common> CreateCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CommonBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Common> CreateCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateCommon(
      _fbb,
      base,
      name__);
}

struct CanonicalSetOpKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalSetOpKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId>(GetField<uint8_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalSetOpKindBuilder {
  typedef CanonicalSetOpKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id) {
    fbb_.AddElement<uint8_t>(CanonicalSetOpKind::VT_ID, static_cast<uint8_t>(id), 0);
  }
  explicit CanonicalSetOpKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalSetOpKindBuilder &operator=(const CanonicalSetOpKindBuilder &);
  flatbuffers::Offset<CanonicalSetOpKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalSetOpKind>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalSetOpKind> CreateCanonicalSetOpKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id = org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId::Union) {
  CanonicalSetOpKindBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalSetOpKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalSetOpKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalSetOpKindBuilder {
  typedef NonCanonicalSetOpKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalSetOpKind::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalSetOpKind::VT_NAME, name);
  }
  explicit NonCanonicalSetOpKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalSetOpKindBuilder &operator=(const NonCanonicalSetOpKindBuilder &);
  flatbuffers::Offset<NonCanonicalSetOpKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalSetOpKind>(end);
    fbb_.Required(o, NonCanonicalSetOpKind::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalSetOpKind> CreateNonCanonicalSetOpKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalSetOpKindBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalSetOpKind> CreateNonCanonicalSetOpKindDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalSetOpKind(
      _fbb,
      name_space__,
      name__);
}

/// A set operation on two or more relations
struct SetOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SET_OP_TYPE = 6,
    VT_SET_OP = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::SetOpKind>(GetField<uint8_t>(VT_SET_OP_TYPE, 0));
  }
  /// The kind of set operation
  const void *set_op() const {
    return GetPointer<const void *>(VT_SET_OP);
  }
  template<typename T> const T *set_op_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *set_op_as_CanonicalSetOpKind() const {
    return set_op_type() == org::apache::arrow::computeir::flatbuf::SetOpKind::CanonicalSetOpKind ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *>(set_op()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *set_op_as_NonCanonicalSetOpKind() const {
    return set_op_type() == org::apache::arrow::computeir::flatbuf::SetOpKind::NonCanonicalSetOpKind ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *>(set_op()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint8_t>(verifier, VT_SET_OP_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SET_OP) &&
           VerifySetOpKind(verifier, set_op(), set_op_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *SetOperation::set_op_as<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind>() const {
  return set_op_as_CanonicalSetOpKind();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *SetOperation::set_op_as<org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind>() const {
  return set_op_as_NonCanonicalSetOpKind();
}

struct SetOperationBuilder {
  typedef SetOperation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(SetOperation::VT_BASE, base);
  }
  void add_set_op_type(org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type) {
    fbb_.AddElement<uint8_t>(SetOperation::VT_SET_OP_TYPE, static_cast<uint8_t>(set_op_type), 0);
  }
  void add_set_op(flatbuffers::Offset<void> set_op) {
    fbb_.AddOffset(SetOperation::VT_SET_OP, set_op);
  }
  explicit SetOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetOperationBuilder &operator=(const SetOperationBuilder &);
  flatbuffers::Offset<SetOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetOperation>(end);
    fbb_.Required(o, SetOperation::VT_BASE);
    fbb_.Required(o, SetOperation::VT_SET_OP);
    return o;
  }
};

inline flatbuffers::Offset<SetOperation> CreateSetOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type = org::apache::arrow::computeir::flatbuf::SetOpKind::NONE,
    flatbuffers::Offset<void> set_op = 0) {
  SetOperationBuilder builder_(_fbb);
  builder_.add_set_op(set_op);
  builder_.add_base(base);
  builder_.add_set_op_type(set_op_type);
  return builder_.Finish();
}

/// Literal relation
struct LiteralRelation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralRelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_COLUMNS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The columns of this literal relation.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LiteralRelationBuilder {
  typedef LiteralRelation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(LiteralRelation::VT_BASE, base);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> columns) {
    fbb_.AddOffset(LiteralRelation::VT_COLUMNS, columns);
  }
  explicit LiteralRelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralRelationBuilder &operator=(const LiteralRelationBuilder &);
  flatbuffers::Offset<LiteralRelation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralRelation>(end);
    fbb_.Required(o, LiteralRelation::VT_BASE);
    fbb_.Required(o, LiteralRelation::VT_COLUMNS);
    return o;
  }
};

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> columns = 0) {
  LiteralRelationBuilder builder_(_fbb);
  builder_.add_columns(columns);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*columns) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateLiteralRelation(
      _fbb,
      base,
      columns__);
}

/// A user-defined relation
struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
};

struct CustomBuilder {
  typedef Custom Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Custom::VT_BASE, base);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomBuilder &operator=(const CustomBuilder &);
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

struct Read FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RESOURCE = 6,
    VT_OPTIONS = 8,
    VT_SCHEMA = 10
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  const flatbuffers::String *resource() const {
    return GetPointer<const flatbuffers::String *>(VT_RESOURCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *>(VT_OPTIONS);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct ReadBuilder {
  typedef Read Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Read::VT_BASE, base);
  }
  void add_resource(flatbuffers::Offset<flatbuffers::String> resource) {
    fbb_.AddOffset(Read::VT_RESOURCE, resource);
  }
  void add_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> options) {
    fbb_.AddOffset(Read::VT_OPTIONS, options);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Read::VT_SCHEMA, schema);
  }
  explicit ReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadBuilder &operator=(const ReadBuilder &);
  flatbuffers::Offset<Read> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Read>(end);
    fbb_.Required(o, Read::VT_RESOURCE);
    fbb_.Required(o, Read::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Read> CreateRead(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> resource = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> options = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  ReadBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_options(options);
  builder_.add_resource(resource);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Read> CreateReadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *resource = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *options = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  auto options__ = options ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>(*options) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRead(
      _fbb,
      base,
      resource__,
      options__,
      schema);
}

struct Write FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RESOURCE = 6,
    VT_OPTIONS = 8,
    VT_SCHEMA = 10
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  const flatbuffers::String *resource() const {
    return GetPointer<const flatbuffers::String *>(VT_RESOURCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *>(VT_OPTIONS);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct WriteBuilder {
  typedef Write Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Write::VT_BASE, base);
  }
  void add_resource(flatbuffers::Offset<flatbuffers::String> resource) {
    fbb_.AddOffset(Write::VT_RESOURCE, resource);
  }
  void add_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> options) {
    fbb_.AddOffset(Write::VT_OPTIONS, options);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Write::VT_SCHEMA, schema);
  }
  explicit WriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteBuilder &operator=(const WriteBuilder &);
  flatbuffers::Offset<Write> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Write>(end);
    fbb_.Required(o, Write::VT_RESOURCE);
    fbb_.Required(o, Write::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Write> CreateWrite(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> resource = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> options = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  WriteBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_options(options);
  builder_.add_resource(resource);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Write> CreateWriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *resource = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *options = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  auto options__ = options ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>(*options) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateWrite(
      _fbb,
      base,
      resource__,
      options__,
      schema);
}

/// A table holding an instance of the possible relation types.
struct Relation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REL_TYPE = 4,
    VT_REL = 6
  };
  org::apache::arrow::computeir::flatbuf::RelationImpl rel_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::RelationImpl>(GetField<uint8_t>(VT_REL_TYPE, 0));
  }
  const void *rel() const {
    return GetPointer<const void *>(VT_REL);
  }
  template<typename T> const T *rel_as() const;
  const org::apache::arrow::computeir::flatbuf::Aggregate *rel_as_Aggregate() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Aggregate ? static_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Common *rel_as_Common() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Common ? static_cast<const org::apache::arrow::computeir::flatbuf::Common *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Custom *rel_as_Custom() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Custom ? static_cast<const org::apache::arrow::computeir::flatbuf::Custom *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::SetOperation *rel_as_SetOperation() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::SetOperation ? static_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Filter *rel_as_Filter() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Filter ? static_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Limit *rel_as_Limit() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Limit ? static_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::LiteralRelation *rel_as_LiteralRelation() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::LiteralRelation ? static_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::OrderBy *rel_as_OrderBy() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::OrderBy ? static_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Project *rel_as_Project() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Project ? static_cast<const org::apache::arrow::computeir::flatbuf::Project *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Read *rel_as_Read() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Read ? static_cast<const org::apache::arrow::computeir::flatbuf::Read *>(rel()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Write *rel_as_Write() const {
    return rel_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Write ? static_cast<const org::apache::arrow::computeir::flatbuf::Write *>(rel()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           VerifyRelationImpl(verifier, rel(), rel_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Aggregate *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Aggregate>() const {
  return rel_as_Aggregate();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Common *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Common>() const {
  return rel_as_Common();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Custom *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Custom>() const {
  return rel_as_Custom();
}

template<> inline const org::apache::arrow::computeir::flatbuf::SetOperation *Relation::rel_as<org::apache::arrow::computeir::flatbuf::SetOperation>() const {
  return rel_as_SetOperation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Filter *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Filter>() const {
  return rel_as_Filter();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Limit *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Limit>() const {
  return rel_as_Limit();
}

template<> inline const org::apache::arrow::computeir::flatbuf::LiteralRelation *Relation::rel_as<org::apache::arrow::computeir::flatbuf::LiteralRelation>() const {
  return rel_as_LiteralRelation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::OrderBy *Relation::rel_as<org::apache::arrow::computeir::flatbuf::OrderBy>() const {
  return rel_as_OrderBy();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Project *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Project>() const {
  return rel_as_Project();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Read *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Read>() const {
  return rel_as_Read();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Write *Relation::rel_as<org::apache::arrow::computeir::flatbuf::Write>() const {
  return rel_as_Write();
}

struct RelationBuilder {
  typedef Relation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rel_type(org::apache::arrow::computeir::flatbuf::RelationImpl rel_type) {
    fbb_.AddElement<uint8_t>(Relation::VT_REL_TYPE, static_cast<uint8_t>(rel_type), 0);
  }
  void add_rel(flatbuffers::Offset<void> rel) {
    fbb_.AddOffset(Relation::VT_REL, rel);
  }
  explicit RelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelationBuilder &operator=(const RelationBuilder &);
  flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_REL);
    return o;
  }
};

inline flatbuffers::Offset<Relation> CreateRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::RelationImpl rel_type = org::apache::arrow::computeir::flatbuf::RelationImpl::NONE,
    flatbuffers::Offset<void> rel = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_rel(rel);
  builder_.add_rel_type(rel_type);
  return builder_.Finish();
}

/// A specification of a query.
struct Plan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINKS = 4,
    VT_DERIVED_FROM = 6
  };
  /// One or more output relations.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *>(VT_SINKS);
  }
  /// If this Plan was derived from another (for example by running
  /// an optimization pass), that plan may be included here to
  /// provide a backtrace of derivations.
  const org::apache::arrow::computeir::flatbuf::Plan *derived_from() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Plan *>(VT_DERIVED_FROM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_DERIVED_FROM) &&
           verifier.VerifyTable(derived_from()) &&
           verifier.EndTable();
  }
};

struct PlanBuilder {
  typedef Plan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> sinks) {
    fbb_.AddOffset(Plan::VT_SINKS, sinks);
  }
  void add_derived_from(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Plan> derived_from) {
    fbb_.AddOffset(Plan::VT_DERIVED_FROM, derived_from);
  }
  explicit PlanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlanBuilder &operator=(const PlanBuilder &);
  flatbuffers::Offset<Plan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plan>(end);
    fbb_.Required(o, Plan::VT_SINKS);
    return o;
  }
};

inline flatbuffers::Offset<Plan> CreatePlan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> sinks = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Plan> derived_from = 0) {
  PlanBuilder builder_(_fbb);
  builder_.add_derived_from(derived_from);
  builder_.add_sinks(sinks);
  return builder_.Finish();
}

inline flatbuffers::Offset<Plan> CreatePlanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *sinks = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Plan> derived_from = 0) {
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>(*sinks) : 0;
  return org::apache::arrow::computeir::flatbuf::CreatePlan(
      _fbb,
      sinks__,
      derived_from);
}

inline bool VerifyInlineBufferImpl(flatbuffers::Verifier &verifier, const void *obj, InlineBufferImpl type) {
  switch (type) {
    case InlineBufferImpl::NONE: {
      return true;
    }
    case InlineBufferImpl::Int8Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int8Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int16Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int16Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Int64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt8Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt8Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt16Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt16Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::UInt64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Float32Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float32Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::Float64Buffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float64Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InlineBufferImpl::TableBuffer: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::TableBuffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInlineBufferImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInlineBufferImpl(
        verifier,  values->Get(i), types->GetEnum<InlineBufferImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type) {
  switch (type) {
    case ExpressionImpl::NONE: {
      return true;
    }
    case ExpressionImpl::Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::FieldRef: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Call: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExpressionImpl(
        verifier,  values->Get(i), types->GetEnum<ExpressionImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyShape(flatbuffers::Verifier &verifier, const void *obj, Shape type) {
  switch (type) {
    case Shape::NONE: {
      return true;
    }
    case Shape::Array: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Shape::Scalar: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Scalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyShape(
        verifier,  values->Get(i), types->GetEnum<Shape>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type) {
  switch (type) {
    case Deref::NONE: {
      return true;
    }
    case Deref::MapKey: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::StructField: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::ArraySubscript: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::ArraySlice: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::FieldName: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldName *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDerefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDeref(
        verifier,  values->Get(i), types->GetEnum<Deref>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFunctionImpl(flatbuffers::Verifier &verifier, const void *obj, FunctionImpl type) {
  switch (type) {
    case FunctionImpl::NONE: {
      return true;
    }
    case FunctionImpl::CanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FunctionImpl::NonCanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFunctionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFunctionImpl(
        verifier,  values->Get(i), types->GetEnum<FunctionImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type) {
  switch (type) {
    case Emit::NONE: {
      return true;
    }
    case Emit::Remap: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Emit::PassThrough: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEmit(
        verifier,  values->Get(i), types->GetEnum<Emit>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type) {
  switch (type) {
    case JoinKind::NONE: {
      return true;
    }
    case JoinKind::CanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case JoinKind::NonCanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyJoinKind(
        verifier,  values->Get(i), types->GetEnum<JoinKind>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySetOpKind(flatbuffers::Verifier &verifier, const void *obj, SetOpKind type) {
  switch (type) {
    case SetOpKind::NONE: {
      return true;
    }
    case SetOpKind::CanonicalSetOpKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SetOpKind::NonCanonicalSetOpKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySetOpKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySetOpKind(
        verifier,  values->Get(i), types->GetEnum<SetOpKind>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type) {
  switch (type) {
    case RelationImpl::NONE: {
      return true;
    }
    case RelationImpl::Aggregate: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Common: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Common *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Custom: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::SetOperation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Filter: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Limit: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::LiteralRelation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::OrderBy: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Project: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Project *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Read: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Read *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Write: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Write *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRelationImpl(
        verifier,  values->Get(i), types->GetEnum<RelationImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::computeir::flatbuf::Plan *GetPlan(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Plan>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Plan *GetSizePrefixedPlan(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Plan>(buf);
}

inline bool VerifyPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Plan>(nullptr);
}

inline bool VerifySizePrefixedPlanBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Plan>(nullptr);
}

inline void FinishPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Plan> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlanBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Plan> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace computeir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_COMPUTEIR_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
