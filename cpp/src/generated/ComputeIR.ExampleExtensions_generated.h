// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPUTEIREXAMPLEEXTENSIONS_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_EXT_H_
#define FLATBUFFERS_GENERATED_COMPUTEIREXAMPLEEXTENSIONS_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_EXT_H_

#include "flatbuffers/flatbuffers.h"

#include "ComputeIR_generated.h"
#include "Message_generated.h"
#include "Schema_generated.h"
#include "SparseTensor_generated.h"
#include "Tensor_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {
namespace computeir {
namespace ext {

struct Uri;
struct UriBuilder;

struct Sql_FromOptions;
struct Sql_FromOptionsBuilder;

struct Partitioning;
struct PartitioningBuilder;

struct FileFormat;
struct FileFormatBuilder;

struct Arrow_FileSystemDatasetScanOptions;
struct Arrow_FileSystemDatasetScanOptionsBuilder;

struct Sql_IntoOptions;
struct Sql_IntoOptionsBuilder;

struct Arrow_StreamOutOptions;
struct Arrow_StreamOutOptionsBuilder;

struct Arrow_FileSystemDatasetWriteOptions;
struct Arrow_FileSystemDatasetWriteOptionsBuilder;

/////////////////////////////////////////////////////////////
struct Uri FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UriBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA = 4,
    VT_USERINFO = 6,
    VT_HOST = 8,
    VT_PORT = 10,
    VT_PATH = 12,
    VT_QUERY = 14,
    VT_FRAGMENT = 16
  };
  const flatbuffers::String *schema() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEMA);
  }
  const flatbuffers::String *userinfo() const {
    return GetPointer<const flatbuffers::String *>(VT_USERINFO);
  }
  const flatbuffers::String *host() const {
    return GetPointer<const flatbuffers::String *>(VT_HOST);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *query() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_QUERY);
  }
  const flatbuffers::String *fragment() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyString(schema()) &&
           VerifyOffset(verifier, VT_USERINFO) &&
           verifier.VerifyString(userinfo()) &&
           VerifyOffsetRequired(verifier, VT_HOST) &&
           verifier.VerifyString(host()) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.VerifyVector(query()) &&
           verifier.VerifyVectorOfTables(query()) &&
           VerifyOffset(verifier, VT_FRAGMENT) &&
           verifier.VerifyString(fragment()) &&
           verifier.EndTable();
  }
};

struct UriBuilder {
  typedef Uri Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema(flatbuffers::Offset<flatbuffers::String> schema) {
    fbb_.AddOffset(Uri::VT_SCHEMA, schema);
  }
  void add_userinfo(flatbuffers::Offset<flatbuffers::String> userinfo) {
    fbb_.AddOffset(Uri::VT_USERINFO, userinfo);
  }
  void add_host(flatbuffers::Offset<flatbuffers::String> host) {
    fbb_.AddOffset(Uri::VT_HOST, host);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(Uri::VT_PORT, port, 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Uri::VT_PATH, path);
  }
  void add_query(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> query) {
    fbb_.AddOffset(Uri::VT_QUERY, query);
  }
  void add_fragment(flatbuffers::Offset<flatbuffers::String> fragment) {
    fbb_.AddOffset(Uri::VT_FRAGMENT, fragment);
  }
  explicit UriBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UriBuilder &operator=(const UriBuilder &);
  flatbuffers::Offset<Uri> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uri>(end);
    fbb_.Required(o, Uri::VT_SCHEMA);
    fbb_.Required(o, Uri::VT_HOST);
    fbb_.Required(o, Uri::VT_PATH);
    return o;
  }
};

inline flatbuffers::Offset<Uri> CreateUri(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> schema = 0,
    flatbuffers::Offset<flatbuffers::String> userinfo = 0,
    flatbuffers::Offset<flatbuffers::String> host = 0,
    uint16_t port = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> query = 0,
    flatbuffers::Offset<flatbuffers::String> fragment = 0) {
  UriBuilder builder_(_fbb);
  builder_.add_fragment(fragment);
  builder_.add_query(query);
  builder_.add_path(path);
  builder_.add_host(host);
  builder_.add_userinfo(userinfo);
  builder_.add_schema(schema);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uri> CreateUriDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *schema = nullptr,
    const char *userinfo = nullptr,
    const char *host = nullptr,
    uint16_t port = 0,
    const char *path = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *query = nullptr,
    const char *fragment = nullptr) {
  auto schema__ = schema ? _fbb.CreateString(schema) : 0;
  auto userinfo__ = userinfo ? _fbb.CreateString(userinfo) : 0;
  auto host__ = host ? _fbb.CreateString(host) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  auto query__ = query ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*query) : 0;
  auto fragment__ = fragment ? _fbb.CreateString(fragment) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreateUri(
      _fbb,
      schema__,
      userinfo__,
      host__,
      port,
      path__,
      query__,
      fragment__);
}

/// The contents of Relation.options will be Sql_FromOptions
/// if Relation.name = "sql::from"
struct Sql_FromOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Sql_FromOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  /// The name of a table referenced as a source relation.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct Sql_FromOptionsBuilder {
  typedef Sql_FromOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Sql_FromOptions::VT_NAME, name);
  }
  explicit Sql_FromOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Sql_FromOptionsBuilder &operator=(const Sql_FromOptionsBuilder &);
  flatbuffers::Offset<Sql_FromOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sql_FromOptions>(end);
    fbb_.Required(o, Sql_FromOptions::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Sql_FromOptions> CreateSql_FromOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  Sql_FromOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sql_FromOptions> CreateSql_FromOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreateSql_FromOptions(
      _fbb,
      name__);
}

struct Partitioning FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartitioningBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAVOR = 4,
    VT_SCHEMA = 6
  };
  /// Currently supported: "hive", "directory"
  const flatbuffers::String *flavor() const {
    return GetPointer<const flatbuffers::String *>(VT_FLAVOR);
  }
  /// Fields on which data is partitioned
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FLAVOR) &&
           verifier.VerifyString(flavor()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct PartitioningBuilder {
  typedef Partitioning Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flavor(flatbuffers::Offset<flatbuffers::String> flavor) {
    fbb_.AddOffset(Partitioning::VT_FLAVOR, flavor);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Partitioning::VT_SCHEMA, schema);
  }
  explicit PartitioningBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartitioningBuilder &operator=(const PartitioningBuilder &);
  flatbuffers::Offset<Partitioning> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Partitioning>(end);
    fbb_.Required(o, Partitioning::VT_FLAVOR);
    fbb_.Required(o, Partitioning::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Partitioning> CreatePartitioning(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> flavor = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  PartitioningBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_flavor(flavor);
  return builder_.Finish();
}

inline flatbuffers::Offset<Partitioning> CreatePartitioningDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *flavor = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto flavor__ = flavor ? _fbb.CreateString(flavor) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreatePartitioning(
      _fbb,
      flavor__,
      schema);
}

struct FileFormat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileFormatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OPTIONS = 6
  };
  /// E.g. "parquet", "csv", ...
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const org::apache::arrow::flatbuf::Buffer *options() const {
    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_OPTIONS) &&
           verifier.EndTable();
  }
};

struct FileFormatBuilder {
  typedef FileFormat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FileFormat::VT_NAME, name);
  }
  void add_options(const org::apache::arrow::flatbuf::Buffer *options) {
    fbb_.AddStruct(FileFormat::VT_OPTIONS, options);
  }
  explicit FileFormatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileFormatBuilder &operator=(const FileFormatBuilder &);
  flatbuffers::Offset<FileFormat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileFormat>(end);
    fbb_.Required(o, FileFormat::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<FileFormat> CreateFileFormat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const org::apache::arrow::flatbuf::Buffer *options = 0) {
  FileFormatBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileFormat> CreateFileFormatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const org::apache::arrow::flatbuf::Buffer *options = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreateFileFormat(
      _fbb,
      name__,
      options);
}

/// The contents of Relation.options will be Arrow_FileSystemDatasetScanOptions
/// if Relation.name = "arrow::filesystem_dataset_scan"
struct Arrow_FileSystemDatasetScanOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Arrow_FileSystemDatasetScanOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_DIR = 4,
    VT_FORMAT = 6,
    VT_PARTITIONING = 8
  };
  /// The base directory of a dataset which should be scanned
  /// as a source relation. A URI is used to accommodate potentially
  /// remote file systems.
  const org::apache::arrow::flatbuf::computeir::ext::Uri *base_dir() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::Uri *>(VT_BASE_DIR);
  }
  /// The format of files in this dataset.
  const org::apache::arrow::flatbuf::computeir::ext::FileFormat *format() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::FileFormat *>(VT_FORMAT);
  }
  /// A partitioning scheme in use in this dataset.
  const org::apache::arrow::flatbuf::computeir::ext::Partitioning *partitioning() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::Partitioning *>(VT_PARTITIONING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE_DIR) &&
           verifier.VerifyTable(base_dir()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyTable(format()) &&
           VerifyOffset(verifier, VT_PARTITIONING) &&
           verifier.VerifyTable(partitioning()) &&
           verifier.EndTable();
  }
};

struct Arrow_FileSystemDatasetScanOptionsBuilder {
  typedef Arrow_FileSystemDatasetScanOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_dir(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> base_dir) {
    fbb_.AddOffset(Arrow_FileSystemDatasetScanOptions::VT_BASE_DIR, base_dir);
  }
  void add_format(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::FileFormat> format) {
    fbb_.AddOffset(Arrow_FileSystemDatasetScanOptions::VT_FORMAT, format);
  }
  void add_partitioning(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Partitioning> partitioning) {
    fbb_.AddOffset(Arrow_FileSystemDatasetScanOptions::VT_PARTITIONING, partitioning);
  }
  explicit Arrow_FileSystemDatasetScanOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Arrow_FileSystemDatasetScanOptionsBuilder &operator=(const Arrow_FileSystemDatasetScanOptionsBuilder &);
  flatbuffers::Offset<Arrow_FileSystemDatasetScanOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Arrow_FileSystemDatasetScanOptions>(end);
    fbb_.Required(o, Arrow_FileSystemDatasetScanOptions::VT_BASE_DIR);
    fbb_.Required(o, Arrow_FileSystemDatasetScanOptions::VT_FORMAT);
    return o;
  }
};

inline flatbuffers::Offset<Arrow_FileSystemDatasetScanOptions> CreateArrow_FileSystemDatasetScanOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> base_dir = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::FileFormat> format = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Partitioning> partitioning = 0) {
  Arrow_FileSystemDatasetScanOptionsBuilder builder_(_fbb);
  builder_.add_partitioning(partitioning);
  builder_.add_format(format);
  builder_.add_base_dir(base_dir);
  return builder_.Finish();
}

/////////////////////////////////////////////////////////////
/// The contents of Relation.options will be Sql_IntoOptions
/// if Relation.name = "sql::into"
struct Sql_IntoOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Sql_IntoOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_APPEND = 6
  };
  /// The name of a table into which rows will be inserted.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Whether rows written into the table should be appended
  /// to the table's current rows (INSERT INTO).
  /// If false, the table will be overwritten (INTO).
  bool append() const {
    return GetField<uint8_t>(VT_APPEND, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_APPEND) &&
           verifier.EndTable();
  }
};

struct Sql_IntoOptionsBuilder {
  typedef Sql_IntoOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Sql_IntoOptions::VT_NAME, name);
  }
  void add_append(bool append) {
    fbb_.AddElement<uint8_t>(Sql_IntoOptions::VT_APPEND, static_cast<uint8_t>(append), 1);
  }
  explicit Sql_IntoOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Sql_IntoOptionsBuilder &operator=(const Sql_IntoOptionsBuilder &);
  flatbuffers::Offset<Sql_IntoOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sql_IntoOptions>(end);
    fbb_.Required(o, Sql_IntoOptions::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Sql_IntoOptions> CreateSql_IntoOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool append = true) {
  Sql_IntoOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_append(append);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sql_IntoOptions> CreateSql_IntoOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool append = true) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreateSql_IntoOptions(
      _fbb,
      name__,
      append);
}

/// The contents of Relation.options will be Arrow_StreamOutOptions
/// if Relation.name = "arrow::stream_out"
struct Arrow_StreamOutOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Arrow_StreamOutOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESTINATION = 4
  };
  /// The URI to which RecordBatches of output should be streamed.
  const org::apache::arrow::flatbuf::computeir::ext::Uri *destination() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::Uri *>(VT_DESTINATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyTable(destination()) &&
           verifier.EndTable();
  }
};

struct Arrow_StreamOutOptionsBuilder {
  typedef Arrow_StreamOutOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_destination(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> destination) {
    fbb_.AddOffset(Arrow_StreamOutOptions::VT_DESTINATION, destination);
  }
  explicit Arrow_StreamOutOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Arrow_StreamOutOptionsBuilder &operator=(const Arrow_StreamOutOptionsBuilder &);
  flatbuffers::Offset<Arrow_StreamOutOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Arrow_StreamOutOptions>(end);
    fbb_.Required(o, Arrow_StreamOutOptions::VT_DESTINATION);
    return o;
  }
};

inline flatbuffers::Offset<Arrow_StreamOutOptions> CreateArrow_StreamOutOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> destination = 0) {
  Arrow_StreamOutOptionsBuilder builder_(_fbb);
  builder_.add_destination(destination);
  return builder_.Finish();
}

/// The contents of Relation.options will be Arrow_FileSystemDatasetWriteOptions
/// if Relation.name = "arrow::filesystem_dataset_write"
struct Arrow_FileSystemDatasetWriteOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Arrow_FileSystemDatasetWriteOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_DIR = 4,
    VT_FORMAT = 6,
    VT_PARTITIONING = 8,
    VT_BASENAME_TEMPLATE = 10
  };
  /// The base directory of a dataset into which output batches should be
  /// written. A URI is used to accommodate potentially remote file systems.
  /// Files present in this directory will not be explicitly deleted, though
  /// they may be overwritten.
  const org::apache::arrow::flatbuf::computeir::ext::Uri *base_dir() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::Uri *>(VT_BASE_DIR);
  }
  /// The format in which to write files.
  const org::apache::arrow::flatbuf::computeir::ext::FileFormat *format() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::FileFormat *>(VT_FORMAT);
  }
  /// A partitioning scheme which should be used when writing this dataset.
  const org::apache::arrow::flatbuf::computeir::ext::Partitioning *partitioning() const {
    return GetPointer<const org::apache::arrow::flatbuf::computeir::ext::Partitioning *>(VT_PARTITIONING);
  }
  /// Template string used to generate written files' basenames.
  /// {i} will be replaced by an auto incremented integer.
  const flatbuffers::String *basename_template() const {
    return GetPointer<const flatbuffers::String *>(VT_BASENAME_TEMPLATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE_DIR) &&
           verifier.VerifyTable(base_dir()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyTable(format()) &&
           VerifyOffset(verifier, VT_PARTITIONING) &&
           verifier.VerifyTable(partitioning()) &&
           VerifyOffsetRequired(verifier, VT_BASENAME_TEMPLATE) &&
           verifier.VerifyString(basename_template()) &&
           verifier.EndTable();
  }
};

struct Arrow_FileSystemDatasetWriteOptionsBuilder {
  typedef Arrow_FileSystemDatasetWriteOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_dir(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> base_dir) {
    fbb_.AddOffset(Arrow_FileSystemDatasetWriteOptions::VT_BASE_DIR, base_dir);
  }
  void add_format(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::FileFormat> format) {
    fbb_.AddOffset(Arrow_FileSystemDatasetWriteOptions::VT_FORMAT, format);
  }
  void add_partitioning(flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Partitioning> partitioning) {
    fbb_.AddOffset(Arrow_FileSystemDatasetWriteOptions::VT_PARTITIONING, partitioning);
  }
  void add_basename_template(flatbuffers::Offset<flatbuffers::String> basename_template) {
    fbb_.AddOffset(Arrow_FileSystemDatasetWriteOptions::VT_BASENAME_TEMPLATE, basename_template);
  }
  explicit Arrow_FileSystemDatasetWriteOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Arrow_FileSystemDatasetWriteOptionsBuilder &operator=(const Arrow_FileSystemDatasetWriteOptionsBuilder &);
  flatbuffers::Offset<Arrow_FileSystemDatasetWriteOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Arrow_FileSystemDatasetWriteOptions>(end);
    fbb_.Required(o, Arrow_FileSystemDatasetWriteOptions::VT_BASE_DIR);
    fbb_.Required(o, Arrow_FileSystemDatasetWriteOptions::VT_FORMAT);
    fbb_.Required(o, Arrow_FileSystemDatasetWriteOptions::VT_BASENAME_TEMPLATE);
    return o;
  }
};

inline flatbuffers::Offset<Arrow_FileSystemDatasetWriteOptions> CreateArrow_FileSystemDatasetWriteOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> base_dir = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::FileFormat> format = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Partitioning> partitioning = 0,
    flatbuffers::Offset<flatbuffers::String> basename_template = 0) {
  Arrow_FileSystemDatasetWriteOptionsBuilder builder_(_fbb);
  builder_.add_basename_template(basename_template);
  builder_.add_partitioning(partitioning);
  builder_.add_format(format);
  builder_.add_base_dir(base_dir);
  return builder_.Finish();
}

inline flatbuffers::Offset<Arrow_FileSystemDatasetWriteOptions> CreateArrow_FileSystemDatasetWriteOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Uri> base_dir = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::FileFormat> format = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::computeir::ext::Partitioning> partitioning = 0,
    const char *basename_template = nullptr) {
  auto basename_template__ = basename_template ? _fbb.CreateString(basename_template) : 0;
  return org::apache::arrow::flatbuf::computeir::ext::CreateArrow_FileSystemDatasetWriteOptions(
      _fbb,
      base_dir,
      format,
      partitioning,
      basename_template__);
}

}  // namespace ext
}  // namespace computeir
}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_COMPUTEIREXAMPLEEXTENSIONS_ORG_APACHE_ARROW_FLATBUF_COMPUTEIR_EXT_H_
