// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"
#include "InlineBuffer_generated.h"
#include "Literal_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct MapKey;
struct MapKeyBuilder;

struct StructField;
struct StructFieldBuilder;

struct ArraySubscript;
struct ArraySubscriptBuilder;

struct ArraySlice;
struct ArraySliceBuilder;

struct FieldName;
struct FieldNameBuilder;

struct FieldRef;
struct FieldRefBuilder;

struct CanonicalFunction;
struct CanonicalFunctionBuilder;

struct NonCanonicalFunction;
struct NonCanonicalFunctionBuilder;

struct Call;
struct CallBuilder;

struct CaseFragment;
struct CaseFragmentBuilder;

struct Case;
struct CaseBuilder;

struct Cast;
struct CastBuilder;

struct Extract;
struct ExtractBuilder;

struct SortKey;
struct SortKeyBuilder;

struct Unbounded;
struct UnboundedBuilder;

struct Preceding;
struct PrecedingBuilder;

struct Following;
struct FollowingBuilder;

struct CurrentRow;
struct CurrentRowBuilder;

struct Bound;
struct BoundBuilder;

struct WindowCall;
struct WindowCallBuilder;

struct CanonicalAggregate;
struct CanonicalAggregateBuilder;

struct NonCanonicalAggregate;
struct NonCanonicalAggregateBuilder;

struct AggregateCall;
struct AggregateCallBuilder;

struct Expression;
struct ExpressionBuilder;

/// A union of possible dereference operations
enum class Deref : uint8_t {
  NONE = 0,
  /// Access a value for a given map key
  MapKey = 1,
  /// Access the value at a struct field
  StructField = 2,
  /// Access the element at a given index in an array
  ArraySubscript = 3,
  /// Access a range of elements in an array
  ArraySlice = 4,
  /// Access a field of a relation
  FieldName = 5,
  MIN = NONE,
  MAX = FieldName
};

inline const Deref (&EnumValuesDeref())[6] {
  static const Deref values[] = {
    Deref::NONE,
    Deref::MapKey,
    Deref::StructField,
    Deref::ArraySubscript,
    Deref::ArraySlice,
    Deref::FieldName
  };
  return values;
}

inline const char * const *EnumNamesDeref() {
  static const char * const names[7] = {
    "NONE",
    "MapKey",
    "StructField",
    "ArraySubscript",
    "ArraySlice",
    "FieldName",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeref(Deref e) {
  if (flatbuffers::IsOutRange(e, Deref::NONE, Deref::FieldName)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeref()[index];
}

template<typename T> struct DerefTraits {
  static const Deref enum_value = Deref::NONE;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::MapKey> {
  static const Deref enum_value = Deref::MapKey;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::StructField> {
  static const Deref enum_value = Deref::StructField;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySubscript> {
  static const Deref enum_value = Deref::ArraySubscript;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySlice> {
  static const Deref enum_value = Deref::ArraySlice;
};

template<> struct DerefTraits<org::apache::arrow::computeir::flatbuf::FieldName> {
  static const Deref enum_value = Deref::FieldName;
};

bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type);
bool VerifyDerefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A canonical (probably SQL equivalent) function
enum class CanonicalFunctionId : uint32_t {
  And = 0,
  Not = 1,
  Or = 2,
  Add = 3,
  Subtract = 4,
  Multiply = 5,
  Divide = 6,
  Power = 7,
  AbsoluteValue = 8,
  Negate = 9,
  Sign = 10,
  DateSub = 11,
  DateAdd = 12,
  DateDiff = 13,
  TimeAdd = 14,
  TimeSub = 15,
  TimeDiff = 16,
  TimestampAdd = 17,
  TimestampSub = 18,
  TimestampDiff = 19,
  Equals = 20,
  NotEquals = 21,
  Greater = 22,
  GreaterEqual = 23,
  Less = 24,
  LessEqual = 25,
  MIN = And,
  MAX = LessEqual
};

inline const CanonicalFunctionId (&EnumValuesCanonicalFunctionId())[26] {
  static const CanonicalFunctionId values[] = {
    CanonicalFunctionId::And,
    CanonicalFunctionId::Not,
    CanonicalFunctionId::Or,
    CanonicalFunctionId::Add,
    CanonicalFunctionId::Subtract,
    CanonicalFunctionId::Multiply,
    CanonicalFunctionId::Divide,
    CanonicalFunctionId::Power,
    CanonicalFunctionId::AbsoluteValue,
    CanonicalFunctionId::Negate,
    CanonicalFunctionId::Sign,
    CanonicalFunctionId::DateSub,
    CanonicalFunctionId::DateAdd,
    CanonicalFunctionId::DateDiff,
    CanonicalFunctionId::TimeAdd,
    CanonicalFunctionId::TimeSub,
    CanonicalFunctionId::TimeDiff,
    CanonicalFunctionId::TimestampAdd,
    CanonicalFunctionId::TimestampSub,
    CanonicalFunctionId::TimestampDiff,
    CanonicalFunctionId::Equals,
    CanonicalFunctionId::NotEquals,
    CanonicalFunctionId::Greater,
    CanonicalFunctionId::GreaterEqual,
    CanonicalFunctionId::Less,
    CanonicalFunctionId::LessEqual
  };
  return values;
}

inline const char * const *EnumNamesCanonicalFunctionId() {
  static const char * const names[27] = {
    "And",
    "Not",
    "Or",
    "Add",
    "Subtract",
    "Multiply",
    "Divide",
    "Power",
    "AbsoluteValue",
    "Negate",
    "Sign",
    "DateSub",
    "DateAdd",
    "DateDiff",
    "TimeAdd",
    "TimeSub",
    "TimeDiff",
    "TimestampAdd",
    "TimestampSub",
    "TimestampDiff",
    "Equals",
    "NotEquals",
    "Greater",
    "GreaterEqual",
    "Less",
    "LessEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalFunctionId(CanonicalFunctionId e) {
  if (flatbuffers::IsOutRange(e, CanonicalFunctionId::And, CanonicalFunctionId::LessEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalFunctionId()[index];
}

enum class FunctionImpl : uint8_t {
  NONE = 0,
  CanonicalFunction = 1,
  NonCanonicalFunction = 2,
  MIN = NONE,
  MAX = NonCanonicalFunction
};

inline const FunctionImpl (&EnumValuesFunctionImpl())[3] {
  static const FunctionImpl values[] = {
    FunctionImpl::NONE,
    FunctionImpl::CanonicalFunction,
    FunctionImpl::NonCanonicalFunction
  };
  return values;
}

inline const char * const *EnumNamesFunctionImpl() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalFunction",
    "NonCanonicalFunction",
    nullptr
  };
  return names;
}

inline const char *EnumNameFunctionImpl(FunctionImpl e) {
  if (flatbuffers::IsOutRange(e, FunctionImpl::NONE, FunctionImpl::NonCanonicalFunction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFunctionImpl()[index];
}

template<typename T> struct FunctionImplTraits {
  static const FunctionImpl enum_value = FunctionImpl::NONE;
};

template<> struct FunctionImplTraits<org::apache::arrow::computeir::flatbuf::CanonicalFunction> {
  static const FunctionImpl enum_value = FunctionImpl::CanonicalFunction;
};

template<> struct FunctionImplTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalFunction> {
  static const FunctionImpl enum_value = FunctionImpl::NonCanonicalFunction;
};

bool VerifyFunctionImpl(flatbuffers::Verifier &verifier, const void *obj, FunctionImpl type);
bool VerifyFunctionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum class Ordering : uint8_t {
  ASCENDING_THEN_NULLS = 0,
  DESCENDING_THEN_NULLS = 1,
  NULLS_THEN_ASCENDING = 2,
  NULLS_THEN_DESCENDING = 3,
  MIN = ASCENDING_THEN_NULLS,
  MAX = NULLS_THEN_DESCENDING
};

inline const Ordering (&EnumValuesOrdering())[4] {
  static const Ordering values[] = {
    Ordering::ASCENDING_THEN_NULLS,
    Ordering::DESCENDING_THEN_NULLS,
    Ordering::NULLS_THEN_ASCENDING,
    Ordering::NULLS_THEN_DESCENDING
  };
  return values;
}

inline const char * const *EnumNamesOrdering() {
  static const char * const names[5] = {
    "ASCENDING_THEN_NULLS",
    "DESCENDING_THEN_NULLS",
    "NULLS_THEN_ASCENDING",
    "NULLS_THEN_DESCENDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrdering(Ordering e) {
  if (flatbuffers::IsOutRange(e, Ordering::ASCENDING_THEN_NULLS, Ordering::NULLS_THEN_DESCENDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrdering()[index];
}

enum class ConcreteBoundImpl : uint8_t {
  NONE = 0,
  Expression = 1,
  Unbounded = 2,
  MIN = NONE,
  MAX = Unbounded
};

inline const ConcreteBoundImpl (&EnumValuesConcreteBoundImpl())[3] {
  static const ConcreteBoundImpl values[] = {
    ConcreteBoundImpl::NONE,
    ConcreteBoundImpl::Expression,
    ConcreteBoundImpl::Unbounded
  };
  return values;
}

inline const char * const *EnumNamesConcreteBoundImpl() {
  static const char * const names[4] = {
    "NONE",
    "Expression",
    "Unbounded",
    nullptr
  };
  return names;
}

inline const char *EnumNameConcreteBoundImpl(ConcreteBoundImpl e) {
  if (flatbuffers::IsOutRange(e, ConcreteBoundImpl::NONE, ConcreteBoundImpl::Unbounded)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConcreteBoundImpl()[index];
}

template<typename T> struct ConcreteBoundImplTraits {
  static const ConcreteBoundImpl enum_value = ConcreteBoundImpl::NONE;
};

template<> struct ConcreteBoundImplTraits<org::apache::arrow::computeir::flatbuf::Expression> {
  static const ConcreteBoundImpl enum_value = ConcreteBoundImpl::Expression;
};

template<> struct ConcreteBoundImplTraits<org::apache::arrow::computeir::flatbuf::Unbounded> {
  static const ConcreteBoundImpl enum_value = ConcreteBoundImpl::Unbounded;
};

bool VerifyConcreteBoundImpl(flatbuffers::Verifier &verifier, const void *obj, ConcreteBoundImpl type);
bool VerifyConcreteBoundImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class BoundImpl : uint8_t {
  NONE = 0,
  Preceding = 1,
  Following = 2,
  CurrentRow = 3,
  MIN = NONE,
  MAX = CurrentRow
};

inline const BoundImpl (&EnumValuesBoundImpl())[4] {
  static const BoundImpl values[] = {
    BoundImpl::NONE,
    BoundImpl::Preceding,
    BoundImpl::Following,
    BoundImpl::CurrentRow
  };
  return values;
}

inline const char * const *EnumNamesBoundImpl() {
  static const char * const names[5] = {
    "NONE",
    "Preceding",
    "Following",
    "CurrentRow",
    nullptr
  };
  return names;
}

inline const char *EnumNameBoundImpl(BoundImpl e) {
  if (flatbuffers::IsOutRange(e, BoundImpl::NONE, BoundImpl::CurrentRow)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBoundImpl()[index];
}

template<typename T> struct BoundImplTraits {
  static const BoundImpl enum_value = BoundImpl::NONE;
};

template<> struct BoundImplTraits<org::apache::arrow::computeir::flatbuf::Preceding> {
  static const BoundImpl enum_value = BoundImpl::Preceding;
};

template<> struct BoundImplTraits<org::apache::arrow::computeir::flatbuf::Following> {
  static const BoundImpl enum_value = BoundImpl::Following;
};

template<> struct BoundImplTraits<org::apache::arrow::computeir::flatbuf::CurrentRow> {
  static const BoundImpl enum_value = BoundImpl::CurrentRow;
};

bool VerifyBoundImpl(flatbuffers::Verifier &verifier, const void *obj, BoundImpl type);
bool VerifyBoundImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// The kind of window function to be executed.
enum class Frame : uint8_t {
  Rows = 0,
  Range = 1,
  MIN = Rows,
  MAX = Range
};

inline const Frame (&EnumValuesFrame())[2] {
  static const Frame values[] = {
    Frame::Rows,
    Frame::Range
  };
  return values;
}

inline const char * const *EnumNamesFrame() {
  static const char * const names[3] = {
    "Rows",
    "Range",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrame(Frame e) {
  if (flatbuffers::IsOutRange(e, Frame::Rows, Frame::Range)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrame()[index];
}

/// A canonical (probably SQL equivalent) function
enum class CanonicalAggregateId : uint32_t {
  All = 0,
  Any = 1,
  Count = 2,
  CountTable = 3,
  Mean = 4,
  Min = 5,
  Max = 6,
  Product = 7,
  Sum = 8,
  Variance = 9,
  StandardDev = 10,
  MIN = All,
  MAX = StandardDev
};

inline const CanonicalAggregateId (&EnumValuesCanonicalAggregateId())[11] {
  static const CanonicalAggregateId values[] = {
    CanonicalAggregateId::All,
    CanonicalAggregateId::Any,
    CanonicalAggregateId::Count,
    CanonicalAggregateId::CountTable,
    CanonicalAggregateId::Mean,
    CanonicalAggregateId::Min,
    CanonicalAggregateId::Max,
    CanonicalAggregateId::Product,
    CanonicalAggregateId::Sum,
    CanonicalAggregateId::Variance,
    CanonicalAggregateId::StandardDev
  };
  return values;
}

inline const char * const *EnumNamesCanonicalAggregateId() {
  static const char * const names[12] = {
    "All",
    "Any",
    "Count",
    "CountTable",
    "Mean",
    "Min",
    "Max",
    "Product",
    "Sum",
    "Variance",
    "StandardDev",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalAggregateId(CanonicalAggregateId e) {
  if (flatbuffers::IsOutRange(e, CanonicalAggregateId::All, CanonicalAggregateId::StandardDev)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalAggregateId()[index];
}

enum class AggregateImpl : uint8_t {
  NONE = 0,
  CanonicalAggregate = 1,
  NonCanonicalAggregate = 2,
  MIN = NONE,
  MAX = NonCanonicalAggregate
};

inline const AggregateImpl (&EnumValuesAggregateImpl())[3] {
  static const AggregateImpl values[] = {
    AggregateImpl::NONE,
    AggregateImpl::CanonicalAggregate,
    AggregateImpl::NonCanonicalAggregate
  };
  return values;
}

inline const char * const *EnumNamesAggregateImpl() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalAggregate",
    "NonCanonicalAggregate",
    nullptr
  };
  return names;
}

inline const char *EnumNameAggregateImpl(AggregateImpl e) {
  if (flatbuffers::IsOutRange(e, AggregateImpl::NONE, AggregateImpl::NonCanonicalAggregate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAggregateImpl()[index];
}

template<typename T> struct AggregateImplTraits {
  static const AggregateImpl enum_value = AggregateImpl::NONE;
};

template<> struct AggregateImplTraits<org::apache::arrow::computeir::flatbuf::CanonicalAggregate> {
  static const AggregateImpl enum_value = AggregateImpl::CanonicalAggregate;
};

template<> struct AggregateImplTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate> {
  static const AggregateImpl enum_value = AggregateImpl::NonCanonicalAggregate;
};

bool VerifyAggregateImpl(flatbuffers::Verifier &verifier, const void *obj, AggregateImpl type);
bool VerifyAggregateImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// An expression is one of
/// - a Literal datum
/// - a reference to a field from a Relation
/// - a call to a named function
/// - a case expression
/// - a cast expression
/// - an extract operation
/// - a window function call
/// - an aggregate function call
///
/// The expressions here that look like function calls such as
/// Cast,Case and Extract are special in that while they might
/// fit into a Call, they don't cleanly do so without having
/// to pass around non-expression arguments as metadata.
///
/// AggregateCall and WindowCall are also separate variants
/// due to special options for each that don't apply to generic
/// function calls. Again this is done to make it easier
/// for consumers to deal with the structure of the operation
enum class ExpressionImpl : uint8_t {
  NONE = 0,
  Literal = 1,
  FieldRef = 2,
  Call = 3,
  Case = 4,
  Cast = 5,
  Extract = 6,
  WindowCall = 7,
  AggregateCall = 8,
  MIN = NONE,
  MAX = AggregateCall
};

inline const ExpressionImpl (&EnumValuesExpressionImpl())[9] {
  static const ExpressionImpl values[] = {
    ExpressionImpl::NONE,
    ExpressionImpl::Literal,
    ExpressionImpl::FieldRef,
    ExpressionImpl::Call,
    ExpressionImpl::Case,
    ExpressionImpl::Cast,
    ExpressionImpl::Extract,
    ExpressionImpl::WindowCall,
    ExpressionImpl::AggregateCall
  };
  return values;
}

inline const char * const *EnumNamesExpressionImpl() {
  static const char * const names[10] = {
    "NONE",
    "Literal",
    "FieldRef",
    "Call",
    "Case",
    "Cast",
    "Extract",
    "WindowCall",
    "AggregateCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpressionImpl(ExpressionImpl e) {
  if (flatbuffers::IsOutRange(e, ExpressionImpl::NONE, ExpressionImpl::AggregateCall)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpressionImpl()[index];
}

template<typename T> struct ExpressionImplTraits {
  static const ExpressionImpl enum_value = ExpressionImpl::NONE;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Literal> {
  static const ExpressionImpl enum_value = ExpressionImpl::Literal;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::FieldRef> {
  static const ExpressionImpl enum_value = ExpressionImpl::FieldRef;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Call> {
  static const ExpressionImpl enum_value = ExpressionImpl::Call;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Case> {
  static const ExpressionImpl enum_value = ExpressionImpl::Case;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Cast> {
  static const ExpressionImpl enum_value = ExpressionImpl::Cast;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Extract> {
  static const ExpressionImpl enum_value = ExpressionImpl::Extract;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::WindowCall> {
  static const ExpressionImpl enum_value = ExpressionImpl::WindowCall;
};

template<> struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::AggregateCall> {
  static const ExpressionImpl enum_value = ExpressionImpl::AggregateCall;
};

bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type);
bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Access a value for a given map key
struct MapKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct MapKeyBuilder {
  typedef MapKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(MapKey::VT_KEY, key);
  }
  explicit MapKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapKeyBuilder &operator=(const MapKeyBuilder &);
  flatbuffers::Offset<MapKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapKey>(end);
    fbb_.Required(o, MapKey::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<MapKey> CreateMapKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  MapKeyBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapKey> CreateMapKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateMapKey(
      _fbb,
      key__);
}

/// Struct field access
struct StructField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  /// The position of the field in the struct schema
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct StructFieldBuilder {
  typedef StructField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(StructField::VT_POSITION, position, 0);
  }
  explicit StructFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructFieldBuilder &operator=(const StructFieldBuilder &);
  flatbuffers::Offset<StructField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructField>(end);
    return o;
  }
};

inline flatbuffers::Offset<StructField> CreateStructField(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t position = 0) {
  StructFieldBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

/// Zero-based array index
struct ArraySubscript FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArraySubscriptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct ArraySubscriptBuilder {
  typedef ArraySubscript Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(ArraySubscript::VT_POSITION, position, 0);
  }
  explicit ArraySubscriptBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArraySubscriptBuilder &operator=(const ArraySubscriptBuilder &);
  flatbuffers::Offset<ArraySubscript> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArraySubscript>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArraySubscript> CreateArraySubscript(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t position = 0) {
  ArraySubscriptBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

/// Zero-based range of elements in an array
struct ArraySlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArraySliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_INCLUSIVE = 4,
    VT_END_EXCLUSIVE = 6
  };
  /// The start of an array slice, inclusive
  uint32_t start_inclusive() const {
    return GetField<uint32_t>(VT_START_INCLUSIVE, 0);
  }
  /// The end of an array slice, exclusive
  uint32_t end_exclusive() const {
    return GetField<uint32_t>(VT_END_EXCLUSIVE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_START_INCLUSIVE) &&
           VerifyField<uint32_t>(verifier, VT_END_EXCLUSIVE) &&
           verifier.EndTable();
  }
};

struct ArraySliceBuilder {
  typedef ArraySlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_inclusive(uint32_t start_inclusive) {
    fbb_.AddElement<uint32_t>(ArraySlice::VT_START_INCLUSIVE, start_inclusive, 0);
  }
  void add_end_exclusive(uint32_t end_exclusive) {
    fbb_.AddElement<uint32_t>(ArraySlice::VT_END_EXCLUSIVE, end_exclusive, 0);
  }
  explicit ArraySliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArraySliceBuilder &operator=(const ArraySliceBuilder &);
  flatbuffers::Offset<ArraySlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArraySlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArraySlice> CreateArraySlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t start_inclusive = 0,
    uint32_t end_exclusive = 0) {
  ArraySliceBuilder builder_(_fbb);
  builder_.add_end_exclusive(end_exclusive);
  builder_.add_start_inclusive(start_inclusive);
  return builder_.Finish();
}

/// Field name in a relation
struct FieldName FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct FieldNameBuilder {
  typedef FieldName Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(FieldName::VT_POSITION, position, 0);
  }
  explicit FieldNameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldNameBuilder &operator=(const FieldNameBuilder &);
  flatbuffers::Offset<FieldName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldName>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldName> CreateFieldName(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t position = 0) {
  FieldNameBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

/// Access the data of a field
struct FieldRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REF_TYPE = 4,
    VT_REF = 6,
    VT_RELATION_INDEX = 8
  };
  org::apache::arrow::computeir::flatbuf::Deref ref_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Deref>(GetField<uint8_t>(VT_REF_TYPE, 0));
  }
  /// A sequence of field names to allow referencing potentially nested fields
  const void *ref() const {
    return GetPointer<const void *>(VT_REF);
  }
  template<typename T> const T *ref_as() const;
  const org::apache::arrow::computeir::flatbuf::MapKey *ref_as_MapKey() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::MapKey ? static_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::StructField *ref_as_StructField() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::StructField ? static_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::ArraySubscript *ref_as_ArraySubscript() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::ArraySubscript ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::ArraySlice *ref_as_ArraySlice() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::ArraySlice ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(ref()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::FieldName *ref_as_FieldName() const {
    return ref_type() == org::apache::arrow::computeir::flatbuf::Deref::FieldName ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldName *>(ref()) : nullptr;
  }
  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  int32_t relation_index() const {
    return GetField<int32_t>(VT_RELATION_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REF_TYPE) &&
           VerifyOffsetRequired(verifier, VT_REF) &&
           VerifyDeref(verifier, ref(), ref_type()) &&
           VerifyField<int32_t>(verifier, VT_RELATION_INDEX) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::MapKey *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::MapKey>() const {
  return ref_as_MapKey();
}

template<> inline const org::apache::arrow::computeir::flatbuf::StructField *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::StructField>() const {
  return ref_as_StructField();
}

template<> inline const org::apache::arrow::computeir::flatbuf::ArraySubscript *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySubscript>() const {
  return ref_as_ArraySubscript();
}

template<> inline const org::apache::arrow::computeir::flatbuf::ArraySlice *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySlice>() const {
  return ref_as_ArraySlice();
}

template<> inline const org::apache::arrow::computeir::flatbuf::FieldName *FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::FieldName>() const {
  return ref_as_FieldName();
}

struct FieldRefBuilder {
  typedef FieldRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ref_type(org::apache::arrow::computeir::flatbuf::Deref ref_type) {
    fbb_.AddElement<uint8_t>(FieldRef::VT_REF_TYPE, static_cast<uint8_t>(ref_type), 0);
  }
  void add_ref(flatbuffers::Offset<void> ref) {
    fbb_.AddOffset(FieldRef::VT_REF, ref);
  }
  void add_relation_index(int32_t relation_index) {
    fbb_.AddElement<int32_t>(FieldRef::VT_RELATION_INDEX, relation_index, 0);
  }
  explicit FieldRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldRefBuilder &operator=(const FieldRefBuilder &);
  flatbuffers::Offset<FieldRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldRef>(end);
    fbb_.Required(o, FieldRef::VT_REF);
    return o;
  }
};

inline flatbuffers::Offset<FieldRef> CreateFieldRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Deref ref_type = org::apache::arrow::computeir::flatbuf::Deref::NONE,
    flatbuffers::Offset<void> ref = 0,
    int32_t relation_index = 0) {
  FieldRefBuilder builder_(_fbb);
  builder_.add_relation_index(relation_index);
  builder_.add_ref(ref);
  builder_.add_ref_type(ref_type);
  return builder_.Finish();
}

struct CanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalFunctionId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalFunctionBuilder {
  typedef CanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id) {
    fbb_.AddElement<uint32_t>(CanonicalFunction::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalFunctionBuilder &operator=(const CanonicalFunctionBuilder &);
  flatbuffers::Offset<CanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalFunction> CreateCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalFunctionId id = org::apache::arrow::computeir::flatbuf::CanonicalFunctionId::And) {
  CanonicalFunctionBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalFunctionBuilder {
  typedef NonCanonicalFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalFunction::VT_NAME, name);
  }
  explicit NonCanonicalFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalFunctionBuilder &operator=(const NonCanonicalFunctionBuilder &);
  flatbuffers::Offset<NonCanonicalFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalFunction>(end);
    fbb_.Required(o, NonCanonicalFunction::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalFunctionBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalFunction> CreateNonCanonicalFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalFunction(
      _fbb,
      name_space__,
      name__);
}

/// A function call expression
struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND_TYPE = 4,
    VT_KIND = 6,
    VT_ARGUMENTS = 8,
    VT_METADATA = 10
  };
  org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::FunctionImpl>(GetField<uint8_t>(VT_KIND_TYPE, 0));
  }
  /// The kind of function call this is.
  const void *kind() const {
    return GetPointer<const void *>(VT_KIND);
  }
  template<typename T> const T *kind_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalFunction *kind_as_CanonicalFunction() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::FunctionImpl::CanonicalFunction ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalFunction *>(kind()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *kind_as_NonCanonicalFunction() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::FunctionImpl::NonCanonicalFunction ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *>(kind()) : nullptr;
  }
  /// The arguments passed to `function_name`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_ARGUMENTS);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *metadata() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           VerifyFunctionImpl(verifier, kind(), kind_type()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalFunction *Call::kind_as<org::apache::arrow::computeir::flatbuf::CanonicalFunction>() const {
  return kind_as_CanonicalFunction();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *Call::kind_as<org::apache::arrow::computeir::flatbuf::NonCanonicalFunction>() const {
  return kind_as_NonCanonicalFunction();
}

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind_type(org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type) {
    fbb_.AddElement<uint8_t>(Call::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
  }
  void add_kind(flatbuffers::Offset<void> kind) {
    fbb_.AddOffset(Call::VT_KIND, kind);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments) {
    fbb_.AddOffset(Call::VT_ARGUMENTS, arguments);
  }
  void add_metadata(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata) {
    fbb_.AddOffset(Call::VT_METADATA, metadata);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    fbb_.Required(o, Call::VT_KIND);
    fbb_.Required(o, Call::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type = org::apache::arrow::computeir::flatbuf::FunctionImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_arguments(arguments);
  builder_.add_kind(kind);
  builder_.add_kind_type(kind_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Call> CreateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::FunctionImpl kind_type = org::apache::arrow::computeir::flatbuf::FunctionImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*arguments) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateCall(
      _fbb,
      kind_type,
      kind,
      arguments__,
      metadata);
}

/// A single WHEN x THEN y fragment.
struct CaseFragment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CaseFragmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHEN = 4,
    VT_THEN = 6
  };
  const org::apache::arrow::computeir::flatbuf::Expression *when() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_WHEN);
  }
  const org::apache::arrow::computeir::flatbuf::Expression *then() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_THEN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WHEN) &&
           verifier.VerifyTable(when()) &&
           VerifyOffsetRequired(verifier, VT_THEN) &&
           verifier.VerifyTable(then()) &&
           verifier.EndTable();
  }
};

struct CaseFragmentBuilder {
  typedef CaseFragment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_when(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> when) {
    fbb_.AddOffset(CaseFragment::VT_WHEN, when);
  }
  void add_then(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> then) {
    fbb_.AddOffset(CaseFragment::VT_THEN, then);
  }
  explicit CaseFragmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaseFragmentBuilder &operator=(const CaseFragmentBuilder &);
  flatbuffers::Offset<CaseFragment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CaseFragment>(end);
    fbb_.Required(o, CaseFragment::VT_WHEN);
    fbb_.Required(o, CaseFragment::VT_THEN);
    return o;
  }
};

inline flatbuffers::Offset<CaseFragment> CreateCaseFragment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> when = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> then = 0) {
  CaseFragmentBuilder builder_(_fbb);
  builder_.add_then(then);
  builder_.add_when(when);
  return builder_.Finish();
}

/// Case statement-style expression.
struct Case FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CASES = 4,
    VT_DEFAULT_ = 6,
    VT_METADATA = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *cases() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *>(VT_CASES);
  }
  /// The default value if no cases match. This is typically NULL in SQL
  ///
  /// Defaulting to NULL is a frontend choice, so producers must specify NULL
  /// if that's their desired behavior.
  const org::apache::arrow::computeir::flatbuf::Expression *default_() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_DEFAULT_);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *metadata() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CASES) &&
           verifier.VerifyVector(cases()) &&
           verifier.VerifyVectorOfTables(cases()) &&
           VerifyOffsetRequired(verifier, VT_DEFAULT_) &&
           verifier.VerifyTable(default_()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct CaseBuilder {
  typedef Case Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cases(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>> cases) {
    fbb_.AddOffset(Case::VT_CASES, cases);
  }
  void add_default_(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> default_) {
    fbb_.AddOffset(Case::VT_DEFAULT_, default_);
  }
  void add_metadata(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata) {
    fbb_.AddOffset(Case::VT_METADATA, metadata);
  }
  explicit CaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaseBuilder &operator=(const CaseBuilder &);
  flatbuffers::Offset<Case> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Case>(end);
    fbb_.Required(o, Case::VT_CASES);
    fbb_.Required(o, Case::VT_DEFAULT_);
    return o;
  }
};

inline flatbuffers::Offset<Case> CreateCase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>> cases = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> default_ = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  CaseBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_default_(default_);
  builder_.add_cases(cases);
  return builder_.Finish();
}

inline flatbuffers::Offset<Case> CreateCaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *cases = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> default_ = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  auto cases__ = cases ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>(*cases) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateCase(
      _fbb,
      cases__,
      default_,
      metadata);
}

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSION = 4,
    VT_TYPE = 6,
    VT_METADATA = 8
  };
  /// The expression to cast
  const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
  }
  /// The type to cast `argument` to.
  const org::apache::arrow::flatbuf::Field *type() const {
    return GetPointer<const org::apache::arrow::flatbuf::Field *>(VT_TYPE);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *metadata() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyTable(expression()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct CastBuilder {
  typedef Cast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
    fbb_.AddOffset(Cast::VT_EXPRESSION, expression);
  }
  void add_type(flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type) {
    fbb_.AddOffset(Cast::VT_TYPE, type);
  }
  void add_metadata(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata) {
    fbb_.AddOffset(Cast::VT_METADATA, metadata);
  }
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastBuilder &operator=(const CastBuilder &);
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    fbb_.Required(o, Cast::VT_EXPRESSION);
    fbb_.Required(o, Cast::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  CastBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_type(type);
  builder_.add_expression(expression);
  return builder_.Finish();
}

struct Extract FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtractBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSION = 4,
    VT_FIELD = 6,
    VT_METADATA = 8
  };
  /// Expression from which to extract components.
  const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
  }
  /// Field to extract from `expression`.
  const flatbuffers::String *field() const {
    return GetPointer<const flatbuffers::String *>(VT_FIELD);
  }
  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *metadata() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyTable(expression()) &&
           VerifyOffsetRequired(verifier, VT_FIELD) &&
           verifier.VerifyString(field()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct ExtractBuilder {
  typedef Extract Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
    fbb_.AddOffset(Extract::VT_EXPRESSION, expression);
  }
  void add_field(flatbuffers::Offset<flatbuffers::String> field) {
    fbb_.AddOffset(Extract::VT_FIELD, field);
  }
  void add_metadata(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata) {
    fbb_.AddOffset(Extract::VT_METADATA, metadata);
  }
  explicit ExtractBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtractBuilder &operator=(const ExtractBuilder &);
  flatbuffers::Offset<Extract> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Extract>(end);
    fbb_.Required(o, Extract::VT_EXPRESSION);
    fbb_.Required(o, Extract::VT_FIELD);
    return o;
  }
};

inline flatbuffers::Offset<Extract> CreateExtract(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    flatbuffers::Offset<flatbuffers::String> field = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  ExtractBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_field(field);
  builder_.add_expression(expression);
  return builder_.Finish();
}

inline flatbuffers::Offset<Extract> CreateExtractDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    const char *field = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> metadata = 0) {
  auto field__ = field ? _fbb.CreateString(field) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateExtract(
      _fbb,
      expression,
      field__,
      metadata);
}

/// An expression with an order
struct SortKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSION = 4,
    VT_ORDERING = 6
  };
  const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
  }
  org::apache::arrow::computeir::flatbuf::Ordering ordering() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Ordering>(GetField<uint8_t>(VT_ORDERING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyTable(expression()) &&
           VerifyField<uint8_t>(verifier, VT_ORDERING) &&
           verifier.EndTable();
  }
};

struct SortKeyBuilder {
  typedef SortKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
    fbb_.AddOffset(SortKey::VT_EXPRESSION, expression);
  }
  void add_ordering(org::apache::arrow::computeir::flatbuf::Ordering ordering) {
    fbb_.AddElement<uint8_t>(SortKey::VT_ORDERING, static_cast<uint8_t>(ordering), 0);
  }
  explicit SortKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortKeyBuilder &operator=(const SortKeyBuilder &);
  flatbuffers::Offset<SortKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortKey>(end);
    fbb_.Required(o, SortKey::VT_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<SortKey> CreateSortKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    org::apache::arrow::computeir::flatbuf::Ordering ordering = org::apache::arrow::computeir::flatbuf::Ordering::ASCENDING_THEN_NULLS) {
  SortKeyBuilder builder_(_fbb);
  builder_.add_expression(expression);
  builder_.add_ordering(ordering);
  return builder_.Finish();
}

/// Boundary is unbounded
struct Unbounded FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnboundedBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnboundedBuilder {
  typedef Unbounded Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnboundedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnboundedBuilder &operator=(const UnboundedBuilder &);
  flatbuffers::Offset<Unbounded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unbounded>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unbounded> CreateUnbounded(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnboundedBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Boundary is preceding rows, determined by the contained expression
struct Preceding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrecedingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IPML_TYPE = 4,
    VT_IPML = 6
  };
  org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl ipml_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl>(GetField<uint8_t>(VT_IPML_TYPE, 0));
  }
  const void *ipml() const {
    return GetPointer<const void *>(VT_IPML);
  }
  template<typename T> const T *ipml_as() const;
  const org::apache::arrow::computeir::flatbuf::Expression *ipml_as_Expression() const {
    return ipml_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::Expression ? static_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(ipml()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Unbounded *ipml_as_Unbounded() const {
    return ipml_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::Unbounded ? static_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(ipml()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IPML_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IPML) &&
           VerifyConcreteBoundImpl(verifier, ipml(), ipml_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Expression *Preceding::ipml_as<org::apache::arrow::computeir::flatbuf::Expression>() const {
  return ipml_as_Expression();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Unbounded *Preceding::ipml_as<org::apache::arrow::computeir::flatbuf::Unbounded>() const {
  return ipml_as_Unbounded();
}

struct PrecedingBuilder {
  typedef Preceding Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ipml_type(org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl ipml_type) {
    fbb_.AddElement<uint8_t>(Preceding::VT_IPML_TYPE, static_cast<uint8_t>(ipml_type), 0);
  }
  void add_ipml(flatbuffers::Offset<void> ipml) {
    fbb_.AddOffset(Preceding::VT_IPML, ipml);
  }
  explicit PrecedingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrecedingBuilder &operator=(const PrecedingBuilder &);
  flatbuffers::Offset<Preceding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Preceding>(end);
    fbb_.Required(o, Preceding::VT_IPML);
    return o;
  }
};

inline flatbuffers::Offset<Preceding> CreatePreceding(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl ipml_type = org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::NONE,
    flatbuffers::Offset<void> ipml = 0) {
  PrecedingBuilder builder_(_fbb);
  builder_.add_ipml(ipml);
  builder_.add_ipml_type(ipml_type);
  return builder_.Finish();
}

/// Boundary is following rows, determined by the contained expression
struct Following FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FollowingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Expression *impl_as_Expression() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::Expression ? static_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Unbounded *impl_as_Unbounded() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::Unbounded ? static_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyConcreteBoundImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Expression *Following::impl_as<org::apache::arrow::computeir::flatbuf::Expression>() const {
  return impl_as_Expression();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Unbounded *Following::impl_as<org::apache::arrow::computeir::flatbuf::Unbounded>() const {
  return impl_as_Unbounded();
}

struct FollowingBuilder {
  typedef Following Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type) {
    fbb_.AddElement<uint8_t>(Following::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Following::VT_IMPL, impl);
  }
  explicit FollowingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowingBuilder &operator=(const FollowingBuilder &);
  flatbuffers::Offset<Following> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Following>(end);
    fbb_.Required(o, Following::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Following> CreateFollowing(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type = org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  FollowingBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

/// Boundary is the current row
struct CurrentRow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurrentRowBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CurrentRowBuilder {
  typedef CurrentRow Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CurrentRowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurrentRowBuilder &operator=(const CurrentRowBuilder &);
  flatbuffers::Offset<CurrentRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurrentRow>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurrentRow> CreateCurrentRow(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CurrentRowBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Boundary of a window
struct Bound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::BoundImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::BoundImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Preceding *impl_as_Preceding() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::BoundImpl::Preceding ? static_cast<const org::apache::arrow::computeir::flatbuf::Preceding *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Following *impl_as_Following() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::BoundImpl::Following ? static_cast<const org::apache::arrow::computeir::flatbuf::Following *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::CurrentRow *impl_as_CurrentRow() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::BoundImpl::CurrentRow ? static_cast<const org::apache::arrow::computeir::flatbuf::CurrentRow *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyBoundImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Preceding *Bound::impl_as<org::apache::arrow::computeir::flatbuf::Preceding>() const {
  return impl_as_Preceding();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Following *Bound::impl_as<org::apache::arrow::computeir::flatbuf::Following>() const {
  return impl_as_Following();
}

template<> inline const org::apache::arrow::computeir::flatbuf::CurrentRow *Bound::impl_as<org::apache::arrow::computeir::flatbuf::CurrentRow>() const {
  return impl_as_CurrentRow();
}

struct BoundBuilder {
  typedef Bound Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::BoundImpl impl_type) {
    fbb_.AddElement<uint8_t>(Bound::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Bound::VT_IMPL, impl);
  }
  explicit BoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoundBuilder &operator=(const BoundBuilder &);
  flatbuffers::Offset<Bound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bound>(end);
    fbb_.Required(o, Bound::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Bound> CreateBound(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::BoundImpl impl_type = org::apache::arrow::computeir::flatbuf::BoundImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  BoundBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

/// An expression representing a window function call.
struct WindowCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WindowCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_EXPRESSION = 6,
    VT_PARTITIONS = 8,
    VT_ORDERINGS = 10,
    VT_LOWER_BOUND = 12,
    VT_UPPER_BOUND = 14
  };
  /// The kind of window frame
  org::apache::arrow::computeir::flatbuf::Frame kind() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Frame>(GetField<uint8_t>(VT_KIND, 0));
  }
  /// The expression to operate over
  const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
  }
  /// Partition keys
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *partitions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_PARTITIONS);
  }
  /// Sort keys
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(VT_ORDERINGS);
  }
  /// Lower window bound
  const org::apache::arrow::computeir::flatbuf::Bound *lower_bound() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Bound *>(VT_LOWER_BOUND);
  }
  /// Upper window bound
  const org::apache::arrow::computeir::flatbuf::Bound *upper_bound() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Bound *>(VT_UPPER_BOUND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KIND) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyTable(expression()) &&
           VerifyOffsetRequired(verifier, VT_PARTITIONS) &&
           verifier.VerifyVector(partitions()) &&
           verifier.VerifyVectorOfTables(partitions()) &&
           VerifyOffsetRequired(verifier, VT_ORDERINGS) &&
           verifier.VerifyVector(orderings()) &&
           verifier.VerifyVectorOfTables(orderings()) &&
           VerifyOffsetRequired(verifier, VT_LOWER_BOUND) &&
           verifier.VerifyTable(lower_bound()) &&
           VerifyOffsetRequired(verifier, VT_UPPER_BOUND) &&
           verifier.VerifyTable(upper_bound()) &&
           verifier.EndTable();
  }
};

struct WindowCallBuilder {
  typedef WindowCall Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(org::apache::arrow::computeir::flatbuf::Frame kind) {
    fbb_.AddElement<uint8_t>(WindowCall::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
    fbb_.AddOffset(WindowCall::VT_EXPRESSION, expression);
  }
  void add_partitions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> partitions) {
    fbb_.AddOffset(WindowCall::VT_PARTITIONS, partitions);
  }
  void add_orderings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> orderings) {
    fbb_.AddOffset(WindowCall::VT_ORDERINGS, orderings);
  }
  void add_lower_bound(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> lower_bound) {
    fbb_.AddOffset(WindowCall::VT_LOWER_BOUND, lower_bound);
  }
  void add_upper_bound(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> upper_bound) {
    fbb_.AddOffset(WindowCall::VT_UPPER_BOUND, upper_bound);
  }
  explicit WindowCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WindowCallBuilder &operator=(const WindowCallBuilder &);
  flatbuffers::Offset<WindowCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WindowCall>(end);
    fbb_.Required(o, WindowCall::VT_EXPRESSION);
    fbb_.Required(o, WindowCall::VT_PARTITIONS);
    fbb_.Required(o, WindowCall::VT_ORDERINGS);
    fbb_.Required(o, WindowCall::VT_LOWER_BOUND);
    fbb_.Required(o, WindowCall::VT_UPPER_BOUND);
    return o;
  }
};

inline flatbuffers::Offset<WindowCall> CreateWindowCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Frame kind = org::apache::arrow::computeir::flatbuf::Frame::Rows,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> partitions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> orderings = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> lower_bound = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> upper_bound = 0) {
  WindowCallBuilder builder_(_fbb);
  builder_.add_upper_bound(upper_bound);
  builder_.add_lower_bound(lower_bound);
  builder_.add_orderings(orderings);
  builder_.add_partitions(partitions);
  builder_.add_expression(expression);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<WindowCall> CreateWindowCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Frame kind = org::apache::arrow::computeir::flatbuf::Frame::Rows,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *partitions = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> lower_bound = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Bound> upper_bound = 0) {
  auto partitions__ = partitions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*partitions) : 0;
  auto orderings__ = orderings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*orderings) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateWindowCall(
      _fbb,
      kind,
      expression,
      partitions__,
      orderings__,
      lower_bound,
      upper_bound);
}

struct CanonicalAggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalAggregateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalAggregateId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalAggregateId>(GetField<uint32_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalAggregateBuilder {
  typedef CanonicalAggregate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalAggregateId id) {
    fbb_.AddElement<uint32_t>(CanonicalAggregate::VT_ID, static_cast<uint32_t>(id), 0);
  }
  explicit CanonicalAggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalAggregateBuilder &operator=(const CanonicalAggregateBuilder &);
  flatbuffers::Offset<CanonicalAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalAggregate>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalAggregate> CreateCanonicalAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalAggregateId id = org::apache::arrow::computeir::flatbuf::CanonicalAggregateId::All) {
  CanonicalAggregateBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalAggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalAggregateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalAggregateBuilder {
  typedef NonCanonicalAggregate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalAggregate::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalAggregate::VT_NAME, name);
  }
  explicit NonCanonicalAggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalAggregateBuilder &operator=(const NonCanonicalAggregateBuilder &);
  flatbuffers::Offset<NonCanonicalAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalAggregate>(end);
    fbb_.Required(o, NonCanonicalAggregate::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalAggregate> CreateNonCanonicalAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalAggregateBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalAggregate> CreateNonCanonicalAggregateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalAggregate(
      _fbb,
      name_space__,
      name__);
}

struct AggregateCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND_TYPE = 4,
    VT_KIND = 6,
    VT_ARGUMENTS = 8,
    VT_ORDERINGS = 10,
    VT_PREDICATE = 12
  };
  org::apache::arrow::computeir::flatbuf::AggregateImpl kind_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::AggregateImpl>(GetField<uint8_t>(VT_KIND_TYPE, 0));
  }
  /// The kind of aggregate function being executed
  const void *kind() const {
    return GetPointer<const void *>(VT_KIND);
  }
  template<typename T> const T *kind_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalAggregate *kind_as_CanonicalAggregate() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::AggregateImpl::CanonicalAggregate ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalAggregate *>(kind()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate *kind_as_NonCanonicalAggregate() const {
    return kind_type() == org::apache::arrow::computeir::flatbuf::AggregateImpl::NonCanonicalAggregate ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate *>(kind()) : nullptr;
  }
  /// Aggregate expression arguments
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_ARGUMENTS);
  }
  /// Possible ordering.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(VT_ORDERINGS);
  }
  /// optional per-aggregate filtering
  const org::apache::arrow::computeir::flatbuf::Expression *predicate() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_PREDICATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           VerifyAggregateImpl(verifier, kind(), kind_type()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_ORDERINGS) &&
           verifier.VerifyVector(orderings()) &&
           verifier.VerifyVectorOfTables(orderings()) &&
           VerifyOffset(verifier, VT_PREDICATE) &&
           verifier.VerifyTable(predicate()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalAggregate *AggregateCall::kind_as<org::apache::arrow::computeir::flatbuf::CanonicalAggregate>() const {
  return kind_as_CanonicalAggregate();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate *AggregateCall::kind_as<org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate>() const {
  return kind_as_NonCanonicalAggregate();
}

struct AggregateCallBuilder {
  typedef AggregateCall Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind_type(org::apache::arrow::computeir::flatbuf::AggregateImpl kind_type) {
    fbb_.AddElement<uint8_t>(AggregateCall::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
  }
  void add_kind(flatbuffers::Offset<void> kind) {
    fbb_.AddOffset(AggregateCall::VT_KIND, kind);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments) {
    fbb_.AddOffset(AggregateCall::VT_ARGUMENTS, arguments);
  }
  void add_orderings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> orderings) {
    fbb_.AddOffset(AggregateCall::VT_ORDERINGS, orderings);
  }
  void add_predicate(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate) {
    fbb_.AddOffset(AggregateCall::VT_PREDICATE, predicate);
  }
  explicit AggregateCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateCallBuilder &operator=(const AggregateCallBuilder &);
  flatbuffers::Offset<AggregateCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggregateCall>(end);
    fbb_.Required(o, AggregateCall::VT_KIND);
    fbb_.Required(o, AggregateCall::VT_ARGUMENTS);
    return o;
  }
};

inline flatbuffers::Offset<AggregateCall> CreateAggregateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::AggregateImpl kind_type = org::apache::arrow::computeir::flatbuf::AggregateImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> orderings = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate = 0) {
  AggregateCallBuilder builder_(_fbb);
  builder_.add_predicate(predicate);
  builder_.add_orderings(orderings);
  builder_.add_arguments(arguments);
  builder_.add_kind(kind);
  builder_.add_kind_type(kind_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AggregateCall> CreateAggregateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::AggregateImpl kind_type = org::apache::arrow::computeir::flatbuf::AggregateImpl::NONE,
    flatbuffers::Offset<void> kind = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*arguments) : 0;
  auto orderings__ = orderings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*orderings) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateAggregateCall(
      _fbb,
      kind_type,
      kind,
      arguments__,
      orderings__,
      predicate);
}

/// Expression types
///
/// Expressions have a concrete `impl` value, which is a specific operation
/// They also have a `type` field, which is the output type of the expression,
/// regardless of operation type.
///
/// The only exception so far is Cast, which has a type as input argument, which
/// is equal to output type.
struct Expression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6,
    VT_TYPE = 8
  };
  org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::ExpressionImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Literal *impl_as_Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::FieldRef *impl_as_FieldRef() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::FieldRef ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Call *impl_as_Call() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Call ? static_cast<const org::apache::arrow::computeir::flatbuf::Call *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Case *impl_as_Case() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Case ? static_cast<const org::apache::arrow::computeir::flatbuf::Case *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Cast *impl_as_Cast() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Cast ? static_cast<const org::apache::arrow::computeir::flatbuf::Cast *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Extract *impl_as_Extract() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::Extract ? static_cast<const org::apache::arrow::computeir::flatbuf::Extract *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::WindowCall *impl_as_WindowCall() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::WindowCall ? static_cast<const org::apache::arrow::computeir::flatbuf::WindowCall *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::AggregateCall *impl_as_AggregateCall() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl::AggregateCall ? static_cast<const org::apache::arrow::computeir::flatbuf::AggregateCall *>(impl()) : nullptr;
  }
  /// The type of the expression.
  ///
  /// This is a field, because the Type union in Schema.fbs
  /// isn't self-contained: Fields are necessary to describe complex types
  /// and there's currently no reason to optimize the storage of this.
  const org::apache::arrow::flatbuf::Field *type() const {
    return GetPointer<const org::apache::arrow::flatbuf::Field *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyExpressionImpl(verifier, impl(), impl_type()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Literal *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Literal>() const {
  return impl_as_Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::FieldRef *Expression::impl_as<org::apache::arrow::computeir::flatbuf::FieldRef>() const {
  return impl_as_FieldRef();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Call *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Call>() const {
  return impl_as_Call();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Case *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Case>() const {
  return impl_as_Case();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Cast *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Cast>() const {
  return impl_as_Cast();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Extract *Expression::impl_as<org::apache::arrow::computeir::flatbuf::Extract>() const {
  return impl_as_Extract();
}

template<> inline const org::apache::arrow::computeir::flatbuf::WindowCall *Expression::impl_as<org::apache::arrow::computeir::flatbuf::WindowCall>() const {
  return impl_as_WindowCall();
}

template<> inline const org::apache::arrow::computeir::flatbuf::AggregateCall *Expression::impl_as<org::apache::arrow::computeir::flatbuf::AggregateCall>() const {
  return impl_as_AggregateCall();
}

struct ExpressionBuilder {
  typedef Expression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type) {
    fbb_.AddElement<uint8_t>(Expression::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Expression::VT_IMPL, impl);
  }
  void add_type(flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type) {
    fbb_.AddOffset(Expression::VT_TYPE, type);
  }
  explicit ExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionBuilder &operator=(const ExpressionBuilder &);
  flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expression>(end);
    fbb_.Required(o, Expression::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Expression> CreateExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type = org::apache::arrow::computeir::flatbuf::ExpressionImpl::NONE,
    flatbuffers::Offset<void> impl = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type = 0) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

inline bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type) {
  switch (type) {
    case Deref::NONE: {
      return true;
    }
    case Deref::MapKey: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::StructField: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::ArraySubscript: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::ArraySlice: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Deref::FieldName: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldName *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDerefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDeref(
        verifier,  values->Get(i), types->GetEnum<Deref>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFunctionImpl(flatbuffers::Verifier &verifier, const void *obj, FunctionImpl type) {
  switch (type) {
    case FunctionImpl::NONE: {
      return true;
    }
    case FunctionImpl::CanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FunctionImpl::NonCanonicalFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFunctionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFunctionImpl(
        verifier,  values->Get(i), types->GetEnum<FunctionImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyConcreteBoundImpl(flatbuffers::Verifier &verifier, const void *obj, ConcreteBoundImpl type) {
  switch (type) {
    case ConcreteBoundImpl::NONE: {
      return true;
    }
    case ConcreteBoundImpl::Expression: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConcreteBoundImpl::Unbounded: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyConcreteBoundImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyConcreteBoundImpl(
        verifier,  values->Get(i), types->GetEnum<ConcreteBoundImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBoundImpl(flatbuffers::Verifier &verifier, const void *obj, BoundImpl type) {
  switch (type) {
    case BoundImpl::NONE: {
      return true;
    }
    case BoundImpl::Preceding: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Preceding *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BoundImpl::Following: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Following *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BoundImpl::CurrentRow: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CurrentRow *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBoundImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBoundImpl(
        verifier,  values->Get(i), types->GetEnum<BoundImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAggregateImpl(flatbuffers::Verifier &verifier, const void *obj, AggregateImpl type) {
  switch (type) {
    case AggregateImpl::NONE: {
      return true;
    }
    case AggregateImpl::CanonicalAggregate: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalAggregate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AggregateImpl::NonCanonicalAggregate: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalAggregate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAggregateImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAggregateImpl(
        verifier,  values->Get(i), types->GetEnum<AggregateImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type) {
  switch (type) {
    case ExpressionImpl::NONE: {
      return true;
    }
    case ExpressionImpl::Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::FieldRef: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Call: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Case: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Case *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Cast: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::Extract: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Extract *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::WindowCall: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::WindowCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExpressionImpl::AggregateCall: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::AggregateCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExpressionImpl(
        verifier,  values->Get(i), types->GetEnum<ExpressionImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::computeir::flatbuf::Expression *GetExpression(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Expression>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Expression *GetSizePrefixedExpression(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Expression>(buf);
}

inline bool VerifyExpressionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Expression>(nullptr);
}

inline bool VerifySizePrefixedExpressionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Expression>(nullptr);
}

inline void FinishExpressionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedExpressionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace computeir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
