// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"
#include "Expression_generated.h"
#include "InlineBuffer_generated.h"
#include "Literal_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct Remap;
struct RemapBuilder;

struct PassThrough;
struct PassThroughBuilder;

struct RelBase;
struct RelBaseBuilder;

struct Filter;
struct FilterBuilder;

struct Project;
struct ProjectBuilder;

struct Aggregate;
struct AggregateBuilder;

struct CanonicalJoinKind;
struct CanonicalJoinKindBuilder;

struct NonCanonicalJoinKind;
struct NonCanonicalJoinKindBuilder;

struct Join;
struct JoinBuilder;

struct OrderBy;
struct OrderByBuilder;

struct Limit;
struct LimitBuilder;

struct Common;
struct CommonBuilder;

struct CanonicalSetOpKind;
struct CanonicalSetOpKindBuilder;

struct NonCanonicalSetOpKind;
struct NonCanonicalSetOpKindBuilder;

struct SetOperation;
struct SetOperationBuilder;

struct LiteralRelation;
struct LiteralRelationBuilder;

struct Custom;
struct CustomBuilder;

struct Read;
struct ReadBuilder;

struct Write;
struct WriteBuilder;

struct Relation;
struct RelationBuilder;

/// A union for the different colum remapping variants
enum class Emit : uint8_t {
  NONE = 0,
  Remap = 1,
  PassThrough = 2,
  MIN = NONE,
  MAX = PassThrough
};

inline const Emit (&EnumValuesEmit())[3] {
  static const Emit values[] = {
    Emit::NONE,
    Emit::Remap,
    Emit::PassThrough
  };
  return values;
}

inline const char * const *EnumNamesEmit() {
  static const char * const names[4] = {
    "NONE",
    "Remap",
    "PassThrough",
    nullptr
  };
  return names;
}

inline const char *EnumNameEmit(Emit e) {
  if (flatbuffers::IsOutRange(e, Emit::NONE, Emit::PassThrough)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmit()[index];
}

template<typename T> struct EmitTraits {
  static const Emit enum_value = Emit::NONE;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::Remap> {
  static const Emit enum_value = Emit::Remap;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::PassThrough> {
  static const Emit enum_value = Emit::PassThrough;
};

bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type);
bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class CanonicalJoinKindId : uint8_t {
  Anti = 0,
  Cross = 1,
  FullOuter = 2,
  Inner = 3,
  LeftOuter = 4,
  LeftSemi = 5,
  RightOuter = 6,
  MIN = Anti,
  MAX = RightOuter
};

inline const CanonicalJoinKindId (&EnumValuesCanonicalJoinKindId())[7] {
  static const CanonicalJoinKindId values[] = {
    CanonicalJoinKindId::Anti,
    CanonicalJoinKindId::Cross,
    CanonicalJoinKindId::FullOuter,
    CanonicalJoinKindId::Inner,
    CanonicalJoinKindId::LeftOuter,
    CanonicalJoinKindId::LeftSemi,
    CanonicalJoinKindId::RightOuter
  };
  return values;
}

inline const char * const *EnumNamesCanonicalJoinKindId() {
  static const char * const names[8] = {
    "Anti",
    "Cross",
    "FullOuter",
    "Inner",
    "LeftOuter",
    "LeftSemi",
    "RightOuter",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalJoinKindId(CanonicalJoinKindId e) {
  if (flatbuffers::IsOutRange(e, CanonicalJoinKindId::Anti, CanonicalJoinKindId::RightOuter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalJoinKindId()[index];
}

enum class JoinKind : uint8_t {
  NONE = 0,
  CanonicalJoinKind = 1,
  NonCanonicalJoinKind = 2,
  MIN = NONE,
  MAX = NonCanonicalJoinKind
};

inline const JoinKind (&EnumValuesJoinKind())[3] {
  static const JoinKind values[] = {
    JoinKind::NONE,
    JoinKind::CanonicalJoinKind,
    JoinKind::NonCanonicalJoinKind
  };
  return values;
}

inline const char * const *EnumNamesJoinKind() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalJoinKind",
    "NonCanonicalJoinKind",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinKind(JoinKind e) {
  if (flatbuffers::IsOutRange(e, JoinKind::NONE, JoinKind::NonCanonicalJoinKind)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinKind()[index];
}

template<typename T> struct JoinKindTraits {
  static const JoinKind enum_value = JoinKind::NONE;
};

template<> struct JoinKindTraits<org::apache::arrow::computeir::flatbuf::CanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::CanonicalJoinKind;
};

template<> struct JoinKindTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind> {
  static const JoinKind enum_value = JoinKind::NonCanonicalJoinKind;
};

bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type);
bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// The kind of set operation being performed.
enum class CanonicalSetOpKindId : uint8_t {
  Union = 0,
  Intersection = 1,
  Difference = 2,
  MIN = Union,
  MAX = Difference
};

inline const CanonicalSetOpKindId (&EnumValuesCanonicalSetOpKindId())[3] {
  static const CanonicalSetOpKindId values[] = {
    CanonicalSetOpKindId::Union,
    CanonicalSetOpKindId::Intersection,
    CanonicalSetOpKindId::Difference
  };
  return values;
}

inline const char * const *EnumNamesCanonicalSetOpKindId() {
  static const char * const names[4] = {
    "Union",
    "Intersection",
    "Difference",
    nullptr
  };
  return names;
}

inline const char *EnumNameCanonicalSetOpKindId(CanonicalSetOpKindId e) {
  if (flatbuffers::IsOutRange(e, CanonicalSetOpKindId::Union, CanonicalSetOpKindId::Difference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCanonicalSetOpKindId()[index];
}

/// The kind of set operation
enum class SetOpKind : uint8_t {
  NONE = 0,
  CanonicalSetOpKind = 1,
  NonCanonicalSetOpKind = 2,
  MIN = NONE,
  MAX = NonCanonicalSetOpKind
};

inline const SetOpKind (&EnumValuesSetOpKind())[3] {
  static const SetOpKind values[] = {
    SetOpKind::NONE,
    SetOpKind::CanonicalSetOpKind,
    SetOpKind::NonCanonicalSetOpKind
  };
  return values;
}

inline const char * const *EnumNamesSetOpKind() {
  static const char * const names[4] = {
    "NONE",
    "CanonicalSetOpKind",
    "NonCanonicalSetOpKind",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetOpKind(SetOpKind e) {
  if (flatbuffers::IsOutRange(e, SetOpKind::NONE, SetOpKind::NonCanonicalSetOpKind)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetOpKind()[index];
}

template<typename T> struct SetOpKindTraits {
  static const SetOpKind enum_value = SetOpKind::NONE;
};

template<> struct SetOpKindTraits<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind> {
  static const SetOpKind enum_value = SetOpKind::CanonicalSetOpKind;
};

template<> struct SetOpKindTraits<org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind> {
  static const SetOpKind enum_value = SetOpKind::NonCanonicalSetOpKind;
};

bool VerifySetOpKind(flatbuffers::Verifier &verifier, const void *obj, SetOpKind type);
bool VerifySetOpKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// The varieties of relations
enum class RelationImpl : uint8_t {
  NONE = 0,
  Aggregate = 1,
  Common = 2,
  Custom = 3,
  SetOperation = 4,
  Filter = 5,
  Limit = 6,
  LiteralRelation = 7,
  OrderBy = 8,
  Project = 9,
  Read = 10,
  Write = 11,
  MIN = NONE,
  MAX = Write
};

inline const RelationImpl (&EnumValuesRelationImpl())[12] {
  static const RelationImpl values[] = {
    RelationImpl::NONE,
    RelationImpl::Aggregate,
    RelationImpl::Common,
    RelationImpl::Custom,
    RelationImpl::SetOperation,
    RelationImpl::Filter,
    RelationImpl::Limit,
    RelationImpl::LiteralRelation,
    RelationImpl::OrderBy,
    RelationImpl::Project,
    RelationImpl::Read,
    RelationImpl::Write
  };
  return values;
}

inline const char * const *EnumNamesRelationImpl() {
  static const char * const names[13] = {
    "NONE",
    "Aggregate",
    "Common",
    "Custom",
    "SetOperation",
    "Filter",
    "Limit",
    "LiteralRelation",
    "OrderBy",
    "Project",
    "Read",
    "Write",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelationImpl(RelationImpl e) {
  if (flatbuffers::IsOutRange(e, RelationImpl::NONE, RelationImpl::Write)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelationImpl()[index];
}

template<typename T> struct RelationImplTraits {
  static const RelationImpl enum_value = RelationImpl::NONE;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Aggregate> {
  static const RelationImpl enum_value = RelationImpl::Aggregate;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Common> {
  static const RelationImpl enum_value = RelationImpl::Common;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Custom> {
  static const RelationImpl enum_value = RelationImpl::Custom;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::SetOperation> {
  static const RelationImpl enum_value = RelationImpl::SetOperation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Filter> {
  static const RelationImpl enum_value = RelationImpl::Filter;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Limit> {
  static const RelationImpl enum_value = RelationImpl::Limit;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::LiteralRelation> {
  static const RelationImpl enum_value = RelationImpl::LiteralRelation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::OrderBy> {
  static const RelationImpl enum_value = RelationImpl::OrderBy;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Project> {
  static const RelationImpl enum_value = RelationImpl::Project;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Read> {
  static const RelationImpl enum_value = RelationImpl::Read;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Write> {
  static const RelationImpl enum_value = RelationImpl::Write;
};

bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type);
bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A data type indicating a different mapping of columns
/// should occur in the output.
///
/// For example:
///
/// Given a query `SELECT a, b FROM t` where `t` has columns a, b, c
/// the mapping value for the projection would equal [0, 1].
struct Remap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPPING = 4
  };
  const flatbuffers::Vector<uint32_t> *mapping() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MAPPING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MAPPING) &&
           verifier.VerifyVector(mapping()) &&
           verifier.EndTable();
  }
};

struct RemapBuilder {
  typedef Remap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mapping(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> mapping) {
    fbb_.AddOffset(Remap::VT_MAPPING, mapping);
  }
  explicit RemapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemapBuilder &operator=(const RemapBuilder &);
  flatbuffers::Offset<Remap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Remap>(end);
    fbb_.Required(o, Remap::VT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<Remap> CreateRemap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> mapping = 0) {
  RemapBuilder builder_(_fbb);
  builder_.add_mapping(mapping);
  return builder_.Finish();
}

inline flatbuffers::Offset<Remap> CreateRemapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *mapping = nullptr) {
  auto mapping__ = mapping ? _fbb.CreateVector<uint32_t>(*mapping) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRemap(
      _fbb,
      mapping__);
}

struct PassThrough FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassThroughBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PassThroughBuilder {
  typedef PassThrough Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PassThroughBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassThroughBuilder &operator=(const PassThroughBuilder &);
  flatbuffers::Offset<PassThrough> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassThrough>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassThrough> CreatePassThrough(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PassThroughBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Fields common to every relational operator
struct RelBase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelBaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENTS = 4,
    VT_OUTPUT_MAPPING_TYPE = 6,
    VT_OUTPUT_MAPPING = 8,
    VT_OPTIONS = 10
  };
  /// The arguments passed to `operation`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *>(VT_ARGUMENTS);
  }
  org::apache::arrow::computeir::flatbuf::Emit output_mapping_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Emit>(GetField<uint8_t>(VT_OUTPUT_MAPPING_TYPE, 0));
  }
  /// Output remapping of ordinals for a given operation
  const void *output_mapping() const {
    return GetPointer<const void *>(VT_OUTPUT_MAPPING);
  }
  template<typename T> const T *output_mapping_as() const;
  const org::apache::arrow::computeir::flatbuf::Remap *output_mapping_as_Remap() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit::Remap ? static_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(output_mapping()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::PassThrough *output_mapping_as_PassThrough() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit::PassThrough ? static_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(output_mapping()) : nullptr;
  }
  /// Arguments for custom operations
  const org::apache::arrow::computeir::flatbuf::InlineBuffer *options() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::InlineBuffer *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_MAPPING_TYPE) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT_MAPPING) &&
           VerifyEmit(verifier, output_mapping(), output_mapping_type()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Remap *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::Remap>() const {
  return output_mapping_as_Remap();
}

template<> inline const org::apache::arrow::computeir::flatbuf::PassThrough *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::PassThrough>() const {
  return output_mapping_as_PassThrough();
}

struct RelBaseBuilder {
  typedef RelBase Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> arguments) {
    fbb_.AddOffset(RelBase::VT_ARGUMENTS, arguments);
  }
  void add_output_mapping_type(org::apache::arrow::computeir::flatbuf::Emit output_mapping_type) {
    fbb_.AddElement<uint8_t>(RelBase::VT_OUTPUT_MAPPING_TYPE, static_cast<uint8_t>(output_mapping_type), 0);
  }
  void add_output_mapping(flatbuffers::Offset<void> output_mapping) {
    fbb_.AddOffset(RelBase::VT_OUTPUT_MAPPING, output_mapping);
  }
  void add_options(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options) {
    fbb_.AddOffset(RelBase::VT_OPTIONS, options);
  }
  explicit RelBaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelBaseBuilder &operator=(const RelBaseBuilder &);
  flatbuffers::Offset<RelBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelBase>(end);
    fbb_.Required(o, RelBase::VT_ARGUMENTS);
    fbb_.Required(o, RelBase::VT_OUTPUT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<RelBase> CreateRelBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> arguments = 0,
    org::apache::arrow::computeir::flatbuf::Emit output_mapping_type = org::apache::arrow::computeir::flatbuf::Emit::NONE,
    flatbuffers::Offset<void> output_mapping = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options = 0) {
  RelBaseBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_output_mapping(output_mapping);
  builder_.add_arguments(arguments);
  builder_.add_output_mapping_type(output_mapping_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelBase> CreateRelBaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *arguments = nullptr,
    org::apache::arrow::computeir::flatbuf::Emit output_mapping_type = org::apache::arrow::computeir::flatbuf::Emit::NONE,
    flatbuffers::Offset<void> output_mapping = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::InlineBuffer> options = 0) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>(*arguments) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRelBase(
      _fbb,
      arguments__,
      output_mapping_type,
      output_mapping,
      options);
}

/// Filter operation
struct Filter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_PREDICATE = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// filter relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *predicate() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_PREDICATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_PREDICATE) &&
           verifier.VerifyTable(predicate()) &&
           verifier.EndTable();
  }
};

struct FilterBuilder {
  typedef Filter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Filter::VT_BASE, base);
  }
  void add_predicate(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate) {
    fbb_.AddOffset(Filter::VT_PREDICATE, predicate);
  }
  explicit FilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FilterBuilder &operator=(const FilterBuilder &);
  flatbuffers::Offset<Filter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Filter>(end);
    fbb_.Required(o, Filter::VT_BASE);
    fbb_.Required(o, Filter::VT_PREDICATE);
    return o;
  }
};

inline flatbuffers::Offset<Filter> CreateFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate = 0) {
  FilterBuilder builder_(_fbb);
  builder_.add_predicate(predicate);
  builder_.add_base(base);
  return builder_.Finish();
}

/// Projection
struct Project FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_EXPRESSIONS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the project relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_EXPRESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(expressions()) &&
           verifier.VerifyVectorOfTables(expressions()) &&
           verifier.EndTable();
  }
};

struct ProjectBuilder {
  typedef Project Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Project::VT_BASE, base);
  }
  void add_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions) {
    fbb_.AddOffset(Project::VT_EXPRESSIONS, expressions);
  }
  explicit ProjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectBuilder &operator=(const ProjectBuilder &);
  flatbuffers::Offset<Project> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Project>(end);
    fbb_.Required(o, Project::VT_BASE);
    fbb_.Required(o, Project::VT_EXPRESSIONS);
    return o;
  }
};

inline flatbuffers::Offset<Project> CreateProject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions = 0) {
  ProjectBuilder builder_(_fbb);
  builder_.add_expressions(expressions);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Project> CreateProjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions = nullptr) {
  auto expressions__ = expressions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*expressions) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateProject(
      _fbb,
      base,
      expressions__);
}

/// Aggregate operation
struct Aggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_AGGREGATIONS = 6,
    VT_KEYS = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the aggregate relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *aggregations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_AGGREGATIONS);
  }
  /// Keys by which `aggregations` will be grouped.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_AGGREGATIONS) &&
           verifier.VerifyVector(aggregations()) &&
           verifier.VerifyVectorOfTables(aggregations()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct AggregateBuilder {
  typedef Aggregate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Aggregate::VT_BASE, base);
  }
  void add_aggregations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> aggregations) {
    fbb_.AddOffset(Aggregate::VT_AGGREGATIONS, aggregations);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys) {
    fbb_.AddOffset(Aggregate::VT_KEYS, keys);
  }
  explicit AggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateBuilder &operator=(const AggregateBuilder &);
  flatbuffers::Offset<Aggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Aggregate>(end);
    fbb_.Required(o, Aggregate::VT_BASE);
    fbb_.Required(o, Aggregate::VT_AGGREGATIONS);
    fbb_.Required(o, Aggregate::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<Aggregate> CreateAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> aggregations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys = 0) {
  AggregateBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_aggregations(aggregations);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Aggregate> CreateAggregateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *aggregations = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys = nullptr) {
  auto aggregations__ = aggregations ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*aggregations) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateAggregate(
      _fbb,
      base,
      aggregations__,
      keys__);
}

struct CanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId>(GetField<uint8_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalJoinKindBuilder {
  typedef CanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id) {
    fbb_.AddElement<uint8_t>(CanonicalJoinKind::VT_ID, static_cast<uint8_t>(id), 0);
  }
  explicit CanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalJoinKindBuilder &operator=(const CanonicalJoinKindBuilder &);
  flatbuffers::Offset<CanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalJoinKind>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalJoinKind> CreateCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId id = org::apache::arrow::computeir::flatbuf::CanonicalJoinKindId::Anti) {
  CanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalJoinKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalJoinKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalJoinKindBuilder {
  typedef NonCanonicalJoinKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalJoinKind::VT_NAME, name);
  }
  explicit NonCanonicalJoinKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalJoinKindBuilder &operator=(const NonCanonicalJoinKindBuilder &);
  flatbuffers::Offset<NonCanonicalJoinKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalJoinKind>(end);
    fbb_.Required(o, NonCanonicalJoinKind::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalJoinKindBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalJoinKind> CreateNonCanonicalJoinKindDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalJoinKind(
      _fbb,
      name_space__,
      name__);
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.operation = CanonicalOperation::Join
struct Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_ON_EXPRESSION = 6,
    VT_JOIN_KIND_TYPE = 8,
    VT_JOIN_KIND = 10
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// join relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *on_expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_ON_EXPRESSION);
  }
  org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::JoinKind>(GetField<uint8_t>(VT_JOIN_KIND_TYPE, 0));
  }
  /// The kind of join to use.
  const void *join_kind() const {
    return GetPointer<const void *>(VT_JOIN_KIND);
  }
  template<typename T> const T *join_kind_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *join_kind_as_CanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::computeir::flatbuf::JoinKind::CanonicalJoinKind ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *>(join_kind()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *join_kind_as_NonCanonicalJoinKind() const {
    return join_kind_type() == org::apache::arrow::computeir::flatbuf::JoinKind::NonCanonicalJoinKind ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *>(join_kind()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_ON_EXPRESSION) &&
           verifier.VerifyTable(on_expression()) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_KIND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_JOIN_KIND) &&
           VerifyJoinKind(verifier, join_kind(), join_kind_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *Join::join_kind_as<org::apache::arrow::computeir::flatbuf::CanonicalJoinKind>() const {
  return join_kind_as_CanonicalJoinKind();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *Join::join_kind_as<org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind>() const {
  return join_kind_as_NonCanonicalJoinKind();
}

struct JoinBuilder {
  typedef Join Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Join::VT_BASE, base);
  }
  void add_on_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression) {
    fbb_.AddOffset(Join::VT_ON_EXPRESSION, on_expression);
  }
  void add_join_kind_type(org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type) {
    fbb_.AddElement<uint8_t>(Join::VT_JOIN_KIND_TYPE, static_cast<uint8_t>(join_kind_type), 0);
  }
  void add_join_kind(flatbuffers::Offset<void> join_kind) {
    fbb_.AddOffset(Join::VT_JOIN_KIND, join_kind);
  }
  explicit JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinBuilder &operator=(const JoinBuilder &);
  flatbuffers::Offset<Join> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Join>(end);
    fbb_.Required(o, Join::VT_BASE);
    fbb_.Required(o, Join::VT_ON_EXPRESSION);
    fbb_.Required(o, Join::VT_JOIN_KIND);
    return o;
  }
};

inline flatbuffers::Offset<Join> CreateJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression = 0,
    org::apache::arrow::computeir::flatbuf::JoinKind join_kind_type = org::apache::arrow::computeir::flatbuf::JoinKind::NONE,
    flatbuffers::Offset<void> join_kind = 0) {
  JoinBuilder builder_(_fbb);
  builder_.add_join_kind(join_kind);
  builder_.add_on_expression(on_expression);
  builder_.add_base(base);
  builder_.add_join_kind_type(join_kind_type);
  return builder_.Finish();
}

/// Order by relation
struct OrderBy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderByBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_KEYS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct OrderByBuilder {
  typedef OrderBy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(OrderBy::VT_BASE, base);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys) {
    fbb_.AddOffset(OrderBy::VT_KEYS, keys);
  }
  explicit OrderByBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderByBuilder &operator=(const OrderByBuilder &);
  flatbuffers::Offset<OrderBy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderBy>(end);
    fbb_.Required(o, OrderBy::VT_BASE);
    fbb_.Required(o, OrderBy::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<OrderBy> CreateOrderBy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys = 0) {
  OrderByBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderBy> CreateOrderByDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateOrderBy(
      _fbb,
      base,
      keys__);
}

/// Limit operation
struct Limit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LimitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_COUNT = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The maximum number of rows of output.
  int64_t count() const {
    return GetField<int64_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<int64_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LimitBuilder {
  typedef Limit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Limit::VT_BASE, base);
  }
  void add_count(int64_t count) {
    fbb_.AddElement<int64_t>(Limit::VT_COUNT, count, 0);
  }
  explicit LimitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LimitBuilder &operator=(const LimitBuilder &);
  flatbuffers::Offset<Limit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Limit>(end);
    fbb_.Required(o, Limit::VT_BASE);
    return o;
  }
};

inline flatbuffers::Offset<Limit> CreateLimit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    int64_t count = 0) {
  LimitBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_base(base);
  return builder_.Finish();
}

/// Common table expresssion
struct Common FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_NAME = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CommonBuilder {
  typedef Common Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Common::VT_BASE, base);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Common::VT_NAME, name);
  }
  explicit CommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommonBuilder &operator=(const CommonBuilder &);
  flatbuffers::Offset<Common> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Common>(end);
    fbb_.Required(o, Common::VT_BASE);
    fbb_.Required(o, Common::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Common> CreateCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CommonBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Common> CreateCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateCommon(
      _fbb,
      base,
      name__);
}

struct CanonicalSetOpKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CanonicalSetOpKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId>(GetField<uint8_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CanonicalSetOpKindBuilder {
  typedef CanonicalSetOpKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id) {
    fbb_.AddElement<uint8_t>(CanonicalSetOpKind::VT_ID, static_cast<uint8_t>(id), 0);
  }
  explicit CanonicalSetOpKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CanonicalSetOpKindBuilder &operator=(const CanonicalSetOpKindBuilder &);
  flatbuffers::Offset<CanonicalSetOpKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CanonicalSetOpKind>(end);
    return o;
  }
};

inline flatbuffers::Offset<CanonicalSetOpKind> CreateCanonicalSetOpKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId id = org::apache::arrow::computeir::flatbuf::CanonicalSetOpKindId::Union) {
  CanonicalSetOpKindBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NonCanonicalSetOpKind FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonCanonicalSetOpKindBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_SPACE = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *name_space() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SPACE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME_SPACE) &&
           verifier.VerifyString(name_space()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NonCanonicalSetOpKindBuilder {
  typedef NonCanonicalSetOpKind Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_space(flatbuffers::Offset<flatbuffers::String> name_space) {
    fbb_.AddOffset(NonCanonicalSetOpKind::VT_NAME_SPACE, name_space);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NonCanonicalSetOpKind::VT_NAME, name);
  }
  explicit NonCanonicalSetOpKindBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonCanonicalSetOpKindBuilder &operator=(const NonCanonicalSetOpKindBuilder &);
  flatbuffers::Offset<NonCanonicalSetOpKind> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonCanonicalSetOpKind>(end);
    fbb_.Required(o, NonCanonicalSetOpKind::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NonCanonicalSetOpKind> CreateNonCanonicalSetOpKind(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name_space = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  NonCanonicalSetOpKindBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_name_space(name_space);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonCanonicalSetOpKind> CreateNonCanonicalSetOpKindDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name_space = nullptr,
    const char *name = nullptr) {
  auto name_space__ = name_space ? _fbb.CreateString(name_space) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateNonCanonicalSetOpKind(
      _fbb,
      name_space__,
      name__);
}

/// A set operation on two or more relations
struct SetOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SET_OP_TYPE = 6,
    VT_SET_OP = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::SetOpKind>(GetField<uint8_t>(VT_SET_OP_TYPE, 0));
  }
  /// The kind of set operation
  const void *set_op() const {
    return GetPointer<const void *>(VT_SET_OP);
  }
  template<typename T> const T *set_op_as() const;
  const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *set_op_as_CanonicalSetOpKind() const {
    return set_op_type() == org::apache::arrow::computeir::flatbuf::SetOpKind::CanonicalSetOpKind ? static_cast<const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *>(set_op()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *set_op_as_NonCanonicalSetOpKind() const {
    return set_op_type() == org::apache::arrow::computeir::flatbuf::SetOpKind::NonCanonicalSetOpKind ? static_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *>(set_op()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint8_t>(verifier, VT_SET_OP_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SET_OP) &&
           VerifySetOpKind(verifier, set_op(), set_op_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *SetOperation::set_op_as<org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind>() const {
  return set_op_as_CanonicalSetOpKind();
}

template<> inline const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *SetOperation::set_op_as<org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind>() const {
  return set_op_as_NonCanonicalSetOpKind();
}

struct SetOperationBuilder {
  typedef SetOperation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(SetOperation::VT_BASE, base);
  }
  void add_set_op_type(org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type) {
    fbb_.AddElement<uint8_t>(SetOperation::VT_SET_OP_TYPE, static_cast<uint8_t>(set_op_type), 0);
  }
  void add_set_op(flatbuffers::Offset<void> set_op) {
    fbb_.AddOffset(SetOperation::VT_SET_OP, set_op);
  }
  explicit SetOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetOperationBuilder &operator=(const SetOperationBuilder &);
  flatbuffers::Offset<SetOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetOperation>(end);
    fbb_.Required(o, SetOperation::VT_BASE);
    fbb_.Required(o, SetOperation::VT_SET_OP);
    return o;
  }
};

inline flatbuffers::Offset<SetOperation> CreateSetOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    org::apache::arrow::computeir::flatbuf::SetOpKind set_op_type = org::apache::arrow::computeir::flatbuf::SetOpKind::NONE,
    flatbuffers::Offset<void> set_op = 0) {
  SetOperationBuilder builder_(_fbb);
  builder_.add_set_op(set_op);
  builder_.add_base(base);
  builder_.add_set_op_type(set_op_type);
  return builder_.Finish();
}

/// Literal relation
struct LiteralRelation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralRelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_COLUMNS = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The columns of this literal relation.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LiteralRelationBuilder {
  typedef LiteralRelation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(LiteralRelation::VT_BASE, base);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> columns) {
    fbb_.AddOffset(LiteralRelation::VT_COLUMNS, columns);
  }
  explicit LiteralRelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralRelationBuilder &operator=(const LiteralRelationBuilder &);
  flatbuffers::Offset<LiteralRelation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralRelation>(end);
    fbb_.Required(o, LiteralRelation::VT_BASE);
    fbb_.Required(o, LiteralRelation::VT_COLUMNS);
    return o;
  }
};

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> columns = 0) {
  LiteralRelationBuilder builder_(_fbb);
  builder_.add_columns(columns);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*columns) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateLiteralRelation(
      _fbb,
      base,
      columns__);
}

/// A user-defined relation.
struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SCHEMA = 6
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// NB: the schema is optional here, since a custom relation
  /// may or may not need it.
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct CustomBuilder {
  typedef Custom Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Custom::VT_BASE, base);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Custom::VT_SCHEMA, schema);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomBuilder &operator=(const CustomBuilder &);
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    fbb_.Required(o, Custom::VT_BASE);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_base(base);
  return builder_.Finish();
}

/// A table read
struct Read FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RESOURCE = 6,
    VT_SCHEMA = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  const flatbuffers::String *resource() const {
    return GetPointer<const flatbuffers::String *>(VT_RESOURCE);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct ReadBuilder {
  typedef Read Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Read::VT_BASE, base);
  }
  void add_resource(flatbuffers::Offset<flatbuffers::String> resource) {
    fbb_.AddOffset(Read::VT_RESOURCE, resource);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Read::VT_SCHEMA, schema);
  }
  explicit ReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadBuilder &operator=(const ReadBuilder &);
  flatbuffers::Offset<Read> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Read>(end);
    fbb_.Required(o, Read::VT_BASE);
    fbb_.Required(o, Read::VT_RESOURCE);
    fbb_.Required(o, Read::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Read> CreateRead(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> resource = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  ReadBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_resource(resource);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Read> CreateReadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *resource = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRead(
      _fbb,
      base,
      resource__,
      schema);
}

/// A table write
struct Write FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RESOURCE = 6,
    VT_SCHEMA = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  const flatbuffers::String *resource() const {
    return GetPointer<const flatbuffers::String *>(VT_RESOURCE);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct WriteBuilder {
  typedef Write Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Write::VT_BASE, base);
  }
  void add_resource(flatbuffers::Offset<flatbuffers::String> resource) {
    fbb_.AddOffset(Write::VT_RESOURCE, resource);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Write::VT_SCHEMA, schema);
  }
  explicit WriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteBuilder &operator=(const WriteBuilder &);
  flatbuffers::Offset<Write> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Write>(end);
    fbb_.Required(o, Write::VT_BASE);
    fbb_.Required(o, Write::VT_RESOURCE);
    fbb_.Required(o, Write::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Write> CreateWrite(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> resource = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  WriteBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_resource(resource);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Write> CreateWriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *resource = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateWrite(
      _fbb,
      base,
      resource__,
      schema);
}

/// A table holding an instance of the possible relation types.
struct Relation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::RelationImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::RelationImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Aggregate *impl_as_Aggregate() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Aggregate ? static_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Common *impl_as_Common() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Common ? static_cast<const org::apache::arrow::computeir::flatbuf::Common *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Custom *impl_as_Custom() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Custom ? static_cast<const org::apache::arrow::computeir::flatbuf::Custom *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::SetOperation *impl_as_SetOperation() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::SetOperation ? static_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Filter *impl_as_Filter() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Filter ? static_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Limit *impl_as_Limit() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Limit ? static_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::LiteralRelation *impl_as_LiteralRelation() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::LiteralRelation ? static_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::OrderBy *impl_as_OrderBy() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::OrderBy ? static_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Project *impl_as_Project() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Project ? static_cast<const org::apache::arrow::computeir::flatbuf::Project *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Read *impl_as_Read() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Read ? static_cast<const org::apache::arrow::computeir::flatbuf::Read *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Write *impl_as_Write() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl::Write ? static_cast<const org::apache::arrow::computeir::flatbuf::Write *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyRelationImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Aggregate *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Aggregate>() const {
  return impl_as_Aggregate();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Common *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Common>() const {
  return impl_as_Common();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Custom *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Custom>() const {
  return impl_as_Custom();
}

template<> inline const org::apache::arrow::computeir::flatbuf::SetOperation *Relation::impl_as<org::apache::arrow::computeir::flatbuf::SetOperation>() const {
  return impl_as_SetOperation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Filter *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Filter>() const {
  return impl_as_Filter();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Limit *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Limit>() const {
  return impl_as_Limit();
}

template<> inline const org::apache::arrow::computeir::flatbuf::LiteralRelation *Relation::impl_as<org::apache::arrow::computeir::flatbuf::LiteralRelation>() const {
  return impl_as_LiteralRelation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::OrderBy *Relation::impl_as<org::apache::arrow::computeir::flatbuf::OrderBy>() const {
  return impl_as_OrderBy();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Project *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Project>() const {
  return impl_as_Project();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Read *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Read>() const {
  return impl_as_Read();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Write *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Write>() const {
  return impl_as_Write();
}

struct RelationBuilder {
  typedef Relation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::RelationImpl impl_type) {
    fbb_.AddElement<uint8_t>(Relation::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Relation::VT_IMPL, impl);
  }
  explicit RelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelationBuilder &operator=(const RelationBuilder &);
  flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Relation> CreateRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::RelationImpl impl_type = org::apache::arrow::computeir::flatbuf::RelationImpl::NONE,
    flatbuffers::Offset<void> impl = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

inline bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type) {
  switch (type) {
    case Emit::NONE: {
      return true;
    }
    case Emit::Remap: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Emit::PassThrough: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEmit(
        verifier,  values->Get(i), types->GetEnum<Emit>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyJoinKind(flatbuffers::Verifier &verifier, const void *obj, JoinKind type) {
  switch (type) {
    case JoinKind::NONE: {
      return true;
    }
    case JoinKind::CanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case JoinKind::NonCanonicalJoinKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalJoinKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyJoinKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyJoinKind(
        verifier,  values->Get(i), types->GetEnum<JoinKind>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySetOpKind(flatbuffers::Verifier &verifier, const void *obj, SetOpKind type) {
  switch (type) {
    case SetOpKind::NONE: {
      return true;
    }
    case SetOpKind::CanonicalSetOpKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CanonicalSetOpKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SetOpKind::NonCanonicalSetOpKind: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NonCanonicalSetOpKind *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySetOpKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySetOpKind(
        verifier,  values->Get(i), types->GetEnum<SetOpKind>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type) {
  switch (type) {
    case RelationImpl::NONE: {
      return true;
    }
    case RelationImpl::Aggregate: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Common: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Common *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Custom: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::SetOperation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Filter: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Limit: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::LiteralRelation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::OrderBy: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Project: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Project *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Read: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Read *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl::Write: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Write *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRelationImpl(
        verifier,  values->Get(i), types->GetEnum<RelationImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::computeir::flatbuf::Relation *GetRelation(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Relation>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Relation *GetSizePrefixedRelation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Relation>(buf);
}

inline bool VerifyRelationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Relation>(nullptr);
}

inline bool VerifySizePrefixedRelationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Relation>(nullptr);
}

inline void FinishRelationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRelationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace computeir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
