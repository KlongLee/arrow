// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//! Utils to make testing easier

use rand::{rngs::StdRng, Rng, SeedableRng};
use std::{env, error::Error, fs, io::Write, path::PathBuf, process::Command};

/// Returns a vector of size `n`, filled with randomly generated bytes.
pub fn random_bytes(n: usize) -> Vec<u8> {
    let mut result = vec![];
    let mut rng = seedable_rng();
    for _ in 0..n {
        result.push(rng.gen_range(0, 255));
    }
    result
}

/// Returns fixed seedable RNG
pub fn seedable_rng() -> StdRng {
    StdRng::seed_from_u64(42)
}

/// Returns file handle for a temp file in 'target' directory with a provided content
///
/// TODO: Originates from `parquet` utils, can be merged in [ARROW-4064]
pub fn get_temp_file(file_name: &str, content: &[u8]) -> fs::File {
    // build tmp path to a file in "target/debug/testdata"
    let mut path_buf = env::current_dir().unwrap();
    path_buf.push("target");
    path_buf.push("debug");
    path_buf.push("testdata");
    fs::create_dir_all(&path_buf).unwrap();
    path_buf.push(file_name);

    // write file content
    let mut tmp_file = fs::File::create(path_buf.as_path()).unwrap();
    tmp_file.write_all(content).unwrap();
    tmp_file.sync_all().unwrap();

    // return file handle for both read and write
    let file = fs::OpenOptions::new()
        .read(true)
        .write(true)
        .open(path_buf.as_path());
    assert!(file.is_ok());
    file.unwrap()
}

/// Gets arrow test data dir, by optional env `ARROW_TEST_DATA` or the default
/// `<apache-arrow-git-toplevel-dir>/testing/data`.
/// It panics when dir not exists or failed to get git top-level dir.
///
/// Example:
///
/// ```
/// let testdata = arrow::util::test_util::arrow_test_data();
/// let csvdata = format!("{}/csv/aggregate_test_100.csv", testdata);
/// assert!(std::path::PathBuf::from(csvdata).exists());
/// ```
pub fn arrow_test_data() -> String {
    let getter = TestDataGetter {
        env_key: ARROW_ENV,
        submodule: ARROW_SUBMODULE,
        submodule_data: ARROW_SUBMODULE_DATA,
    };
    let res = getter.by_env_or_submodule();
    match res {
        Ok(pb) => pb.display().to_string(),
        Err(err) => panic!(format!("failed to get arrow data dir: {}", err)),
    }
}

/// Gets parquet test data dir, by optional env `PARQUET_TEST_DATA` or the default
/// `<apache-arrow-git-toplevel-dir>/cpp/submodules/parquet-testing/data`.
/// It panics when dir not exists or failed to get git top-level dir.
///
/// Example:
///
/// ```
/// let testdata = arrow::util::test_util::parquet_test_data();
/// let filename = format!("{}/binary.parquet", testdata);
/// assert!(std::path::PathBuf::from(filename).exists());
/// ```
pub fn parquet_test_data() -> String {
    let getter = TestDataGetter {
        env_key: PARQUET_ENV,
        submodule: PARQUET_SUBMODULE,
        submodule_data: PARQUET_SUBMODULE_DATA,
    };
    let res = getter.by_env_or_submodule();
    match res {
        Ok(pb) => pb.display().to_string(),
        Err(err) => panic!(format!("failed to get parquet data dir: {}", err)),
    }
}

const ARROW_ENV: &str = "ARROW_TEST_DATA";
const ARROW_SUBMODULE: &str = "testing";
const ARROW_SUBMODULE_DATA: &str = "data";

const PARQUET_ENV: &str = "PARQUET_TEST_DATA";
const PARQUET_SUBMODULE: &str = "cpp/submodules/parquet-testing";
const PARQUET_SUBMODULE_DATA: &str = "data";

/// TestDataGetter is used to get data dir for arrow or parquet.
struct TestDataGetter<'a> {
    env_key: &'a str,
    submodule: &'a str,
    submodule_data: &'a str,
}

impl TestDataGetter<'_> {
    // NOTE: `std::fs::canonicalize` returns UNC paths on Windows, so don't use `canonicalize`.
    // Ref: https://github.com/rust-lang/rust/issues/42869

    /// Gets data dir defined by `env_key`.
    /// Return `None` if `env_key` is undefined or it's value is trimmed to empty string.
    fn by_env(&self) -> Option<Result<PathBuf, Box<dyn Error>>> {
        let data_dir = get_env_value(self.env_key)?;
        if data_dir.is_dir() {
            Some(Ok(data_dir))
        } else {
            Some(Err(format!(
                "`{}` defined by env `{}` not exists or is not directory",
                data_dir.display().to_string(),
                self.env_key
            )
            .into()))
        }
    }

    /// Gets data dir from `git top-level dir`, `submodule` and `data_dir`.
    /// The git top-level dir will be get by `git rev-parse --show-toplevel`.
    fn by_submodule(&self) -> Result<PathBuf, Box<dyn Error>> {
        let top = get_git_toplevel_dir()?;
        let sub = top.join(self.submodule);
        if sub.exists() {
            let data = sub.join(self.submodule_data);
            if data.exists() {
                return Ok(data);
            } else {
                return Err(format!(
                    "submodule data dir `{}` not exists, did you run `git submodule update --init`?",
                    data.to_string_lossy().to_string()
                )
                .into());
            }
        }
        return Err(format!(
            "submodule dir `{}` not exists, did you run `git submodule update --init`?",
            sub.to_string_lossy()
        )
        .into());
    }

    /// Gets data dir by env or submodule.
    /// If `by_env()` returns `None`, then call `by_submodule`.
    fn by_env_or_submodule(&self) -> Result<PathBuf, Box<dyn Error>> {
        match self.by_env() {
            Some(dir_or_error) => dir_or_error,
            None => self.by_submodule(),
        }
    }
}

impl Default for TestDataGetter<'_> {
    fn default() -> Self {
        TestDataGetter {
            env_key: "",
            submodule: "",
            submodule_data: "",
        }
    }
}

/// Get dir path from the env `key`.
/// Return `None` when failed to get env or trimmed to empty string.
fn get_env_value(key: &str) -> Option<PathBuf> {
    let val = env::var(key);
    if val.is_err() {
        return None;
    }

    let val = val.unwrap().trim().to_string();
    if val.is_empty() {
        return None;
    }

    Some(PathBuf::from(val))
}

/// Get git toplevel dir path.
/// Return `None` when failed to run `git rev-parse --show-toplevel`.
fn get_git_toplevel_dir() -> Result<PathBuf, Box<dyn Error>> {
    let args = vec!["rev-parse", "--show-toplevel"];
    if let Ok(out) = Command::new("git").args(&args).output() {
        if out.status.success() {
            return Ok(PathBuf::from(String::from_utf8_lossy(&out.stdout).trim()));
        }
    }
    Err(format!(
        "failed to get git top-level dir with `git {}`",
        args.join(" ")
    )
    .into())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    // NOTE: DON'T update env vars `ARROW_TEST_DATA` and `PARQUET_TEST_DATA`, because that
    // MAY break other tests.

    #[test]
    fn test_by_env() {
        let env_key = "test_by_env";
        let mut getter = TestDataGetter::default();
        getter.env_key = env_key;

        env::remove_var(env_key);
        let res = getter.by_env();
        debug_assert!(res.is_none());

        env::set_var(env_key, "");
        let res = getter.by_env();
        debug_assert!(res.is_none());

        env::set_var(env_key, " ");
        let res = getter.by_env();
        debug_assert!(res.is_none());

        env::set_var(env_key, "non-existing-env-dir");
        let res = getter.by_env();
        debug_assert!(res.is_some());
        debug_assert!(res.unwrap().is_err());

        env::set_var(env_key, ".");
        let res = getter.by_env();
        debug_assert!(res.is_some());
        debug_assert!(res.unwrap().is_ok());

        env::set_var(env_key, "\t. ");
        let res = getter.by_env();
        debug_assert!(res.is_some());
        debug_assert!(res.unwrap().is_ok());
    }

    #[test]
    fn test_by_submodule() {
        use super::*;

        let mut getter = TestDataGetter::default();
        getter.submodule = "non-existing-submodule";
        getter.submodule_data = "any";

        let res = getter.by_submodule();
        debug_assert!(res.is_err());

        getter.submodule = ARROW_SUBMODULE;
        getter.submodule_data = "non-existing-data-dir";
        let res = getter.by_submodule();
        debug_assert!(res.is_err());

        getter.submodule_data = ARROW_SUBMODULE_DATA;
        let res = getter.by_submodule();
        debug_assert!(res.is_ok());
    }

    #[test]
    fn test_by_env_or_submodule() {
        let env_key = "test_by_env_or_submodule";
        let mut getter = TestDataGetter::default();
        getter.env_key = env_key;

        let args = vec!["rev-parse", "--show-toplevel"];
        let out = Command::new("git").args(args).output().unwrap();

        let expected = PathBuf::from(String::from_utf8_lossy(&out.stdout).trim())
            .join(ARROW_SUBMODULE)
            .join(ARROW_SUBMODULE_DATA);

        env::set_var(env_key, &expected);
        let res = getter.by_env_or_submodule();
        debug_assert!(res.is_ok());
        assert_eq!(res.unwrap(), expected);

        env::set_var(env_key, "non-existing-env-dir");
        let res = getter.by_env_or_submodule();
        debug_assert!(res.is_err());

        env::remove_var(env_key);

        getter.submodule = "non-existing-submodule";
        let res = getter.by_env_or_submodule();
        debug_assert!(res.is_err());

        getter.submodule = ARROW_SUBMODULE;

        getter.submodule_data = "non-existing-data-dir";
        let res = getter.by_env_or_submodule();
        debug_assert!(res.is_err());

        getter.submodule_data = ARROW_SUBMODULE_DATA;
        let res = getter.by_env_or_submodule();
        debug_assert!(res.is_ok());
        assert_eq!(res.unwrap(), expected);
    }

    #[test]
    fn happy() {
        let arrow = PathBuf::from(arrow_test_data());
        assert!(arrow.is_dir());
        if get_env_value(ARROW_ENV).is_none() {
            let top = get_git_toplevel_dir().unwrap();
            let expected = top.join(ARROW_SUBMODULE).join(ARROW_SUBMODULE_DATA);
            assert_eq!(expected, arrow);
        }

        let parquet = PathBuf::from(parquet_test_data());
        assert!(parquet.is_dir());
        if get_env_value(PARQUET_ENV).is_none() {
            let top = get_git_toplevel_dir().unwrap();
            let expected = top.join(PARQUET_SUBMODULE).join(PARQUET_SUBMODULE_DATA);
            assert_eq!(expected, parquet);
        }
    }
}
