// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

include "../../Schema.fbs";
include "Literal.fbs";

namespace org.apache.arrow.computeir.flatbuf;

/// Access a value for a given map key
table MapKey {
  key: string (required);
}

/// Struct field access
table StructField {
  /// The position of the field in the struct schema
  position: uint32;
}

/// Zero-based array index
table ArraySubscript {
  position: uint32;
}

/// Zero-based range of elements in an array
table ArraySlice {
  /// The start of an array slice, inclusive
  start_inclusive: uint32;
  /// The end of an array slice, exclusive
  end_exclusive: uint32;
}

/// Field name in a relation
table FieldName {
  position: uint32;
}

/// A union of possible dereference operations
union Deref {
  /// Access a value for a given map key
  MapKey,
  /// Access the value at a struct field
  StructField,
  /// Access the element at a given index in an array
  ArraySubscript,
  /// Access a range of elements in an array
  ArraySlice,
  /// Access a field of a relation
  FieldName,
}

/// Access the data of a field
table FieldRef {
  /// A sequence of field names to allow referencing potentially nested fields
  ref: Deref (required);
  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  relation_index: int = 0;
}

/// A canonical (probably SQL equivalent) function
//
// TODO: variadics
enum CanonicalFunctionId : uint32 {
  // logical
  And,
  Not,
  Or,

  // arithmetic
  Add,
  Subtract,
  Multiply,
  Divide,
  Power,
  AbsoluteValue,
  Negate,
  Sign,

  // date/time/timestamp operations
  DateSub,
  DateAdd,
  DateDiff,
  TimeAdd,
  TimeSub,
  TimeDiff,
  TimestampAdd,
  TimestampSub,
  TimestampDiff,

  // comparison
  Equals,
  NotEquals,
  Greater,
  GreaterEqual,
  Less,
  LessEqual,
}

table CanonicalFunction {
  id: CanonicalFunctionId;
}

table NonCanonicalFunction {
  name_space: string;
  name: string (required);
}

union FunctionImpl {
  CanonicalFunction,
  NonCanonicalFunction,
}

/// A function call expression
table Call {
  /// The kind of function call this is.
  kind: FunctionImpl (required);

  /// The arguments passed to `function_name`.
  arguments: [Expression] (required);

  /// Possible ordering of input. These are useful
  /// in some aggregates where ordering may be meaninful,
  /// such as string concatenation
  orderings: [SortKey];
}

/// A single WHEN x THEN y fragment.
table CaseFragment {
  match: Expression (required);
  result: Expression (required);
}

/// Conditional case statement expression
table ConditionalCase {
  /// List of conditions to evaluate
  conditions: [CaseFragment] (required);
  /// The default value if no cases match. This is typically NULL in SQL
  /// implementations.
  ///
  /// Defaulting to NULL is a frontend choice, so producers must specify NULL
  /// if that's their desired behavior.
  else: Expression (required);
}

/// Switch-style case expression
table SimpleCase {
  /// The expression whose value will be matched
  expression: Expression (required);
  /// Matches for `expression`
  matches: [CaseFragment] (required);
  /// The default value if no cases match
  else: Expression (required);
}

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values
enum Collation : uint8 {
  ASCENDING_THEN_NULLS,
  DESCENDING_THEN_NULLS,
  NULLS_THEN_ASCENDING,
  NULLS_THEN_DESCENDING,
  /// Equal values are grouped together, but not guaranteed to be
  /// in any particular order
  CLUSTERED,
}

/// An expression with an order
table SortKey {
  expression: Expression (required);
  ordering: Collation = ASCENDING_THEN_NULLS;
}

/// Boundary is unbounded
table Unbounded {}

union ConcreteBoundImpl {
  Expression,
  Unbounded,
}

/// Boundary is preceding rows, determined by the contained expression
table Preceding {
  ipml: ConcreteBoundImpl (required);
}

/// Boundary is following rows, determined by the contained expression
table Following {
  impl: ConcreteBoundImpl (required);
}

/// Boundary is the current row
table CurrentRow {}

union BoundImpl {
  Preceding,
  Following,
  CurrentRow,
}

/// Boundary of a window
table Bound {
  impl: BoundImpl (required);
}

/// The kind of window function to be executed.
enum Frame : uint8 {
  Rows,
  Range,
}

/// An expression representing a window function call.
table WindowCall {
  /// The kind of window frame
  kind: Frame;
  /// The expression to operate over
  expression: Expression (required);
  /// Partition keys
  partitions: [Expression] (required);
  /// Sort keys
  orderings: [SortKey] (required);
  /// Lower window bound
  lower_bound: Bound (required);
  /// Upper window bound
  upper_bound: Bound (required);
}

/// An expression is one of
/// - a Literal datum
/// - a reference to a field from a Relation
/// - a call to a named function
/// - a case expression
/// - a window function call
///
/// The expressions here that look like function calls such as
/// Cast,Case and Extract are special in that while they might
/// fit into a Call, they don't cleanly do so without having
/// to pass around non-expression arguments as metadata.
///
/// WindowCall is a separate variant
/// due to special options for each that don't apply to generic
/// function calls. Again this is done to make it easier
/// for consumers to deal with the structure of the operation
union ExpressionImpl {
  Literal,
  FieldRef,
  Call,
  ConditionalCase,
  SimpleCase,
  WindowCall,
}

/// Expression types
///
/// Expressions have a concrete `impl` value, which is a specific operation.
/// They also have a `type` field, which is the output type of the expression,
/// regardless of operation type.
///
/// Type is optional to support use cases where types are added at a later
/// phase of processing.
///
/// The optionality of types does not imply anything about the semantics of
/// those types.
///
/// For example, if a producer puts an int64 into this field, the consumer must
/// return an expression with type int64.
table Expression {
  impl: ExpressionImpl (required);

  /// The type of the expression.
  ///
  /// This is a field, because the Type union in Schema.fbs
  /// isn't self-contained: Fields are necessary to describe complex types
  /// and there's currently no reason to optimize the storage of this.
  ///
  /// NB: The `name` in this `Field` is **not** meaningful, consumers must
  /// never depend on that field being populated by a producer.
  type: org.apache.arrow.flatbuf.Field;
}

root_type Expression;
