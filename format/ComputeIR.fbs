// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

include "Schema.fbs";

namespace org.apache.arrow.flatbuf.computeir;

table Int8Buffer { items: [uint8] (required); }
table Int16Buffer { items: [uint16] (required); }
table Int32Buffer { items: [uint32] (required); }
table Int64Buffer { items: [uint64] (required); }
table UInt8Buffer { items: [uint8] (required); }
table UInt16Buffer { items: [uint16] (required); }
table UInt32Buffer { items: [uint32] (required); }
table UInt64Buffer { items: [uint64] (required); }
table Float32Buffer { items: [float32] (required); }
table Float64Buffer { items: [float64] (required); }
table TableBuffer { items: [ubyte] (required, nested_flatbuffer: "InlineBuffer"); }
union InlineBufferImpl {
  Int8Buffer,
  Int16Buffer,
  Int32Buffer,
  Int64Buffer,
  UInt8Buffer,
  UInt16Buffer,
  UInt32Buffer,
  UInt64Buffer,
  Float32Buffer,
  Float64Buffer,
  TableBuffer,
}

/// An inline replacement for org.apache.arrow.Buffer because that
/// requires a sidecar block of bytes into which offsets can point.
/// A union of buffers of each primitive type is provided to avoid
/// the need for reinterpret_cast, std::mem::transmute, ...
/// The final member of the union is a bytes buffer aligned suitably
/// to hold any flatbuffer Table.
table InlineBuffer {
  // Ideally we'd simply have `union InlineBuffer { ... }`
  // but not all generators support vectors of unions so we provide minimal
  // indirection to support them.
  impl: InlineBufferImpl (required);
}

/// An expression is one of
/// - a Literal datum
/// - a reference to a Field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
union ExpressionImpl {
  Literal, FieldRef, Call
}

table Expression {
  /// The type of this literal. Field is used instead of Type to pick
  /// up child fields, dictionary encoding, etc.
  /// Field.name should always be absent since it is not meaningful
  /// for Expressions.
  field: Field (required);

  impl: ExpressionImpl (required);
}

union Shape {
  Array, Scalar
}

table Scalar {}

table Array {
  /// Number of slots.
  length: long;
}

table Literal {
  /// Shape of this literal.
  ///
  /// Note that this is orthogonal to type and refers to the number
  /// of rows spanned by this Literal - a Literal may be Scalar shaped
  /// with multiple "columns" if the type happens to be Struct.
  shape: Shape (required);

  /// Buffers containing N elements of arrow-formatted data, where N
  /// is Array.length if shape is Array or 1 if shape is Scalar.
  /// XXX this can be optimized for trivial scalars later
  buffers: [InlineBuffer];

  /// If (and only if) this Literal has dictionary type, this field dictionary
  /// into which the literal's indices refer.
  dictionary: Literal;
}

table FieldRef {
  /// A sequence of field names to allow referencing potentially nested fields
  path: [string];

  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  relation_index: int;
}

/// A canonical (probably SQL equivalent) function
enum CanonicalFunctionId : uint32 {
  // logical
  And,
  Not,
  Or,

  // arithmetic
  Add,
  Subtract,
  Multiply,
  Divide,
  Power,
  AbsoluteValue,
  Negate,
  Sign,

  // comparison
  Equal,
  NotEqual,
  Greater,
  GreaterOrEqual,
  Less,
  LessOrEqual,

  // aggregations
  All,
  Any,
  Count,
  Mean,
  Min,
  Max,
  Mode,
  Product,
  Sum,
  Tdigest,
  Quantile,
  Variance,
  StandardDeviation,
}

table CanonicalFunction {
  id: CanonicalFunctionId;
}

table NonCanonicalFunction {
  name_space: string (required);
  name: string (required);
}

union Function {
  CanonicalFunction, NonCanonicalFunction
}

table Call {
  /// The function whose invocation this Call represents.
  function: Function (required);

  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  options: InlineBuffer;

  /// The arguments passed to `function_name`.
  arguments: [Expression] (required);
}

enum CanonicalOperationId : uint32 {
  Literal,
  Filter,
  Project,
  Aggregate,
  Join,
  OrderBy,
  Limit,
  Common,
  Union,
  InteractiveOutput,
}

table CanonicalOperation {
  id: CanonicalOperationId;
}

table NonCanonicalOperation {
  name_space: string (required);
  name: string (required);
}

union Operation {
  CanonicalOperation, NonCanonicalOperation
}

/// A relation is a set of rows with consistent schema.
table Relation {
  /// The operation which this Relation wraps.
  operation: Operation (required);

  /// Parameters for `operation`; content/format may be unique to each
  /// value of `operation`.
  options: InlineBuffer;

  /// The arguments passed to `operation`.
  arguments: [Relation] (required);

  /// The schema of rows in this Relation
  schema: Schema;
}

/// The contents of Relation.options will be FilterOptions
/// if Relation.operation = CanonicalOperation::Filter
table FilterOptions {
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// filter relation's output.
  filter_expression: Expression (required);
}

/// The contents of Relation.options will be ProjectOptions
/// if Relation.operation = CanonicalOperation::Project
table ProjectOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the project relation's output.
  expressions: [Expression] (required);
}

/// The contents of Relation.options will be AggregateOptions
/// if Relation.operation = CanonicalOperation::Aggregate
table AggregateOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the aggregate relation's output.
  aggregations: [Expression] (required);
  /// Keys by which `aggregations` will be grouped.
  keys: [Expression] (required);
}

enum CanonicalJoinKindId : uint32 {
  Inner,
  LeftOuter,
  RightOuter,
  FullOuter,
  Cross,
}

table CanonicalJoinKind {
  id: CanonicalJoinKindId;
}

table NonCanonicalJoinKind {
  name_space: string (required);
  name: string (required);
}

union JoinKind {
  CanonicalJoinKind, NonCanonicalJoinKind
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.operation = CanonicalOperation::Join
table JoinOptions {
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// join relation's output.
  on_expression: Expression (required);
  /// The kind of join to use.
  join_kind: JoinKind (required);
}

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum Ordering : uint8 {
  ASCENDING_THEN_NULLS,
  DESCENDING_THEN_NULLS,
  NULLS_THEN_ASCENDING,
  NULLS_THEN_DESCENDING
}

table SortKey {
  value: Expression (required);
  ordering: Ordering = ASCENDING_THEN_NULLS;
}

/// The contents of Relation.options will be OrderByOptions
/// if Relation.operation = CanonicalOperation::OrderBy
table OrderByOptions {
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  keys: [SortKey] (required);
}

/// The contents of Relation.options will be LimitOptions
/// if Relation.operation = CanonicalOperation::Limit
table LimitOptions {
  /// Set the maximum number of rows of output.
  count: long;
}

/// The contents of Relation.options will be CommonOptions
/// if Relation.operation = CanonicalOperation::Common
table CommonOptions {
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  name: string (required);
}

/// The contents of Relation.options will be UnionOptions
/// if Relation.operation = CanonicalOperation::Union
table UnionOptions {
  /// For simplicity, all rows from any input to a union relation
  /// will always be concatenated into a single output- establishing
  /// uniqueness of output rows is deferred to other relations.
}

/// The contents of Relation.options will be LiteralOptions
/// if Relation.operation = CanonicalOperation::Literal
table LiteralOptions {
  /// The columns of this literal relation.
  columns: [Literal] (required);
}

/// A specification of a query.
table Plan {
  /// One or more output relations.
  sinks: [Relation] (required);

  /// If this Plan was derived from another (for example by running
  /// an optimization pass), that plan may be included here to
  /// provide a backtrace of derivations.
  derived_from: Plan;
}

/// Frequently there is an open direct channel between producers
/// of queries (client) and their consumers (server).
/// `Interactive` is provided to reify this case:
rpc_service Interactive {
  /// Restructure the provided Plan into one which contains only
  /// Relations that are directly executable by the server.
  /// These relations will usually be opaque to the client, but should
  /// be descriptively named and validly structured to provide a client
  /// with information on how the query will be executed.
  explain(Plan): Plan (streaming: "none");

  /// Execute a Plan.
  /// The Plan may contain a single Relation with
  /// operation=InteractiveOutput, in which case data which
  /// is received by that sink will be streamed back to the client.
  execute(Plan): Literal (streaming: "server");
}

root_type Plan;
