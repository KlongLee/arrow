/// Licensed to the Apache Software Foundation (ASF) under one
/// or more contributor license agreements.  See the NOTICE file
/// distributed with this work for additional information
/// regarding copyright ownership.  The ASF licenses this file
/// to you under the Apache License, Version 2.0 (the
/// "License"); you may not use this file except in compliance
/// with the License.  You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing,
/// software distributed under the License is distributed on an
/// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
/// KIND, either express or implied.  See the License for the
/// specific language governing permissions and limitations
/// under the License.

/// Arrow Compute IR (Intermediate Representation)
///
/// The purpose of these data structures is to provide a language- and compute
/// engine-agnostic representation of common analytical operations on Arrow
/// data. This may include so-called "logical query plans" generated by SQL
/// systems, but it can be used to serialize different types of expression or
/// query fragments for various purposes. For example, a system could use this
/// to serialize array expressions for transmitting filters/predicates.
///
/// The three main types of data objects dealt with in this IR are:
///
/// * Table: a data source having an Arrow schema, resolvable algebraically to
///   a collection of Arrow record batches
/// * Array: logically, a field in a Table
/// * Scalar: a single value, which is broadcastable to Array as needed
///
/// This IR deliberately does not provide for query planning or physical
/// execution details. It also aims to be as comprehensive as possible in
/// capturing compute operations expressible in different query engines or data
/// frame libraries. Engines are not expected to implement everything here.
///
/// One of the most common areas of divergence in query engines are the names
/// and semantics of functions that operation on scalar or array
/// inputs. Efforts to standardize function names and their expected semantics
/// will happen outside of the serialized IR format defined here.

// We use the IPC Schema types to represent data typesa
include "Schema.fbs";

namespace org.apache.arrow.flatbuf.computeir;

/// ----------------------------------------------------------------------
/// Data serialization for literal (constant / scalar) values

/// Serialized data which, given a data type, can be unpacked into a scalar
/// value data structure.
///
/// NB(wesm): This is simpler from an IDL perspective than having a separate
/// data type for each Arrow type.
union LiteralData {
  NullLiteralData,
  PrimitiveLiteralData,
  ListLiteralData,
  StructLiteralData,
  UnionLiteralData
}

/// Placeholder for any null value, whether with Null type or a different
/// non-Null type.
table NullLiteralData {}

/// For all data types represented as fixed-size-binary value. Boolean values
/// are to be represented as a single byte with value 1 (true) or 0 (false).
table PrimitiveLiteralData {
  data:[ubyte] (required);
}

/// For List, LargeList, and FixedSizeList.
table ListLiteralData {
  data:[LiteralData] (required);
}

/// For Struct.
table StructLiteralData {
  data:[LiteralData] (required);
}

/// For Union.
table UnionLiteralData {
  /// The type code (referencing the Union type) needed to reconstruct the
  /// correct literal value.
  type_code:int;  // required

  value:LiteralData (required);
}

/// Literal serializes a scalar (constant) value in an array expression.
table Literal {
  type:Type (required);

  /// The data needed to reconstruct the literal value.
  data:LiteralData (required);
}

/// A sequence of literal values all having the same type.
table LiteralVector {
  type:Type (required);
  data:[LiteralData] (required);
}

/// A name (key) and literal value, to use for map-like options fields.
table NamedLiteral {
  name:string;
  value:Literal;
}

/// ----------------------------------------------------------------------
/// One-dimensional operations (array/scalar input and output) and ArrayExpr

///
table TableReference {
  ///
  name:string (required);
}

///
table ColumnReference {
  name:string (required);

  ///
  table:TableReference;
}

/// Operation checks if values are null
table IsNull {
  expr: ArrayExpr (required);
}

/// Operation checks if values are not null
table IsNotNull {
  expr: ArrayExpr (required);
}

table Not {}

/// Expected built-in binary operations
enum UnaryOpType : int {
  /// Not flips true/false in a boolean expression
  NOT = 0,

  /// Unary negation flips sign of numeric input
  NEGATE = 1,
}

/// Expected built-in binary operations
enum BinaryOpType : int {
  ADD = 0,
  SUBTRACT = 1,
  MULTIPLY = 2,
  DIVIDE = 3,
  EQUAL = 4,
  NOT_EQUAL = 5,
  LESS = 6,
  LESS_EQUAL = 7,
  GREATER = 8,
  GREATER_EQUAL = 9,
  AND = 10,
  OR = 11,
  XOR = 12
}

/// Built-in binary operation
table BinaryOp {
  type:BinaryOpType;
  left:ArrayExpr (required);
  right:ArrayExpr (required);
}

enum FunctionType : int {
  SCALAR = 0,
  AGGREGATE = 1,
  WINDOW = 2,
  TABLE = 3
}

/// A general-purpose descriptor for a built-in or user-defined
/// function. Producers of the IR are encouraged to reuse Function objects (by
/// reusing the Flatbuffers offset) when a particular function appears multiple
/// times in an expression.
table FunctionDescr {
  /// Function name from list of available function names. Built-in functions
  /// are expected to be chosen from a list of "canonical" or "unambiguous"
  /// function names to provide a measure of normalization across backends that
  /// implement this Compute IR.
  ///
  /// The name may refer to a user-defined function which has been registered
  /// with the target engine. User-defined function data can also be passed
  /// with the "data" member.
  name:string (required);

  type:FunctionType = SCALAR;

  /// Optional arbitrary sidecar data (such as a serialized user-defined
  /// function)..
  data:[ubyte];
}

table WindowFrame {
  order_by:[SortKey];

  partition_by:[ArrayExpr];
}

/// A general array function call, which may be built-in or user-defined.
///
/// It is recommended to put the function output type when using in an
/// ArrayExpr. It is acceptable to omit the type if it is the same as all the
/// inputs (for example, in the case of math functions when double input yields
/// double output).
table ArrayFunction {
  descr:FunctionDescr (required);
  inputs:[ArrayExpr] (required);

  /// Optional non-data inputs for function invocation.
  ///
  /// It is recommended to limit use of options for functions that are expected
  /// to be built-in in a generic IR consumer.
  options:[NamedLiteral];

  /// Optional window expression for window functions only
  window:WindowFrame;
}

/// Conditional if-then-else operation, selecting values from the then- or
/// else-branch based on the provided boolean condition.
///
/// If the "then" and "else" expressions have different output types, it's
/// recommended to indicate the promoted output type in an ArrayExpr when using
/// this operator.
table IfElse {
  /// Boolean output type
  condition:ArrayExpr (required);

  /// Values to use when the condition is true
  then:ArrayExpr (required);

  /// Values to use when the condition is false
  else:ArrayExpr (required);
}

/// Operation for expressing multiple equality checks with an expression.
///
/// IsIn(input, [value0, value1, ...])
/// is the same as Or(Or(Eq(input, value0), Eq(input, value1)), ...)
table IsIn {
  input:ArrayExpr (required);
  in_exprs:[ArrayExpr] (required);

  /// If true, the checks are inequality rather than equality
  negated:bool = false;
}

/// Boolean operation checking whether input is bounded by the left and right
/// expressions.
///
/// input BETWEEN left_bound AND right_bound
/// is the same as
/// input >= left_bound AND input <= right_bound
table Between {
  input:ArrayExpr (required);
  left_bound:ArrayExpr (required);
  right_bound:ArrayExpr (required);
}

union ArrayOperation {
  ColumnReference,
  Literal,
  BinaryOp,
  ArrayFunction,
  IfElse,
  IsIn,
  Between
}

///
///
/// An expression yielding a scalar value can be broadcasted to array shape as
/// needed depending on use.
table ArrayExpr {
  op:ArrayOperation (required);

  /// Optional name for array operation
  name:string;

  /// Expected output type of the array operation. While optional, IR producers
  /// are encouraged to populate this field for the benefit of IR consumers.
  out_type:Type;
}

/// ----------------------------------------------------------------------
/// Table operations and TableExpr

/// A named table which the IR producers expects the IR consumer to be able to
/// access. A "table" in this context is anything that can produce
/// Arrow-formatted data with the given schema.
table ExternalTable {
  ///
  name:string (required);

  ///
  schema:Schema (required);

  /// Optional opaque table serialization data, for passing engine-specific
  /// instructions to enable the data to be accessed.
  serde_type:string;
  serde_data:[ubyte];
}

/// An instruction to "include all columns" in the projection, sparing the IR
/// producer
table StarSelection {
  ref:TableReference;
}

/// A helper union to permit the "SELECT *, $expr0, ..." concept from SQL.
union ProjectionExpr {
  ArrayExpr,
  StarSelection
}

/// Computes a new table given a set of column selections or array expressions.
table Projection {
  input:TableExpr (required);
  exprs:[ProjectionExpr] (required);
}

/// Select rows from table for
table Filter {
  input:TableExpr (required);
  condition:ArrayExpr (required);
}

/// A "group by" table aggregation: data is grouped using the group
/// expressions, and the aggregate expressions are evaluated within each group.
table Aggregate {
  input:TableExpr;
  aggregate_exprs:[ArrayExpr] (required);

  /// Expressions to use as group keys. If not provided, then the aggregate
  /// operation yields a table with a single row.
  group_exprs:[ArrayExpr];

  having:[ArrayExpr];
}

table Limit {
  input:TableExpr;
  limit:long;
}

enum RelationalJoinType : int {
  INNER = 0,
  LEFT = 1,
  RIGHT = 2,
  OUTER = 3,
  SEMI = 4,
  ANTI = 5,
}

/// A standard relational / SQL-style equijoin.
table EqualityJoin {
  // TODO: complete and document
  type:RelationalJoinType = INNER;
  left:TableExpr;
  right:TableExpr;
  left_columns:[ColumnReference];
  right_columns:[ColumnReference];
}

/// A relational non-equijoin containing expressions which may include
/// inequality or range conditions.
table NonEqualityJoin {
  // TODO: complete and document
  type:RelationalJoinType = INNER;
  left:TableExpr;
  right:TableExpr;
  left_exprs:[ArrayExpr];
  right_exprs:[ArrayExpr];
}

/// A temporal join type
table AsOfJoin {
  // TODO: complete and document
  left:TableExpr;
  right:TableExpr;

  left_asof:ColumnReference (required);

  /// If the column name is the same as left_asof, may be omitted.
  right_asof:ColumnReference;

  ///
  tolerance:Literal;

  /// If true, the
  allow_equal:bool = true;
}

/// An extension of as-of join which allows applying an aggregate function to
/// the data falling within the indicated time interval
///
/// TODO: Define semantics of "identity" window where all elements of window
/// become a List<T> element in the result.
table WindowJoin {
  // TODO
}

table SortKey {
  key:ColumnReference (required);
  ascending:bool = true;
}

table Sort {
  // TODO
}

table TableFunction {
  descr:FunctionDescr (required);
}

union TableOperation {
  ExternalTable,
  Projection,
  Filter,
  Aggregate,
  Limit,
  Sort,
  EqualityJoin,
  NonEqualityJoin,
  TableFunction
}

table TableExpr {
  /// The operation that yields
  op:TableOperation (required);

  /// An optional explicit name for this table expression, to enable
  /// unambiguous column references.
  name:string;

  /// Optional output schema. A schema can be serialized here for informational
  /// purposes, or to provide a checkpoint/assertion to the IR consumer about
  /// what you expect the schema to be at this point. Always requiring it would
  /// increase the on-wire size of a Table
  out_schema:Schema;
}

root_type TableExpr;
