// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

include "Schema.fbs";
include "Message.fbs";

namespace org.apache.arrow.flatbuf.computeir;

/// Wrapper for blobs of arbitrary bytes
table Blob {
  bytes: [ubyte];
}

/// An expression is one of
/// - a Literal datum
/// - a reference to a Field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
union Expression {
  Literal, FieldRef, Call
}

table Literal {
  /// Number of slots. If this is absent, the literal should be
  /// considered scalar.
  length: long;

  /// The type of this literal.
  type: Type (required);

  /// Buffers containing `length` elements of arrow-formatted data.
  /// If `length` is absent (this Literal is scalar), these buffers
  /// are sized to accommodate a single element of arrow-formatted data.
  /// XXX this can be optimized for trivial scalars later
  buffers: [Buffer];
}

table FieldRef {
  /// A sequence of field names to allow referencing potentially nested fields
  path: [string];

  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  relation_index: int;

  /// The type of data in the referenced Field.
  type: Type;
}

table Call {
  /// The name of the function whose invocation this Call represents.
  function_name: string (required);

  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  options: Blob;

  /// The arguments passed to `function_name`.
  arguments: [Expression] (required);

  /// The type of data which invoking `function_name` will return.
  type: Type;
}

/// A relation is a set of rows with consitent schema.
table Relation {
  /// The namespaced name of this Relation.
  ///
  /// Names with no namespace are reserved for pure relational
  /// algebraic operations, which currently include:
  ///   "filter"
  ///   "project"
  ///   "aggregate"
  ///   "join"
  ///   "order_by"
  ///   "limit"
  ///   "literal"
  ///   "interactive_output"
  relation_name: string (required);

  /// Parameters for `relation_name`; content/format may be unique to each
  /// value of `relation_name`.
  options: Blob;

  /// The arguments passed to `relation_name`.
  arguments: [Relation] (required);

  /// The schema of rows in this Relation
  schema: Schema;
}

/// The contents of Relation.options will be FilterOptions
/// if Relation.name = "filter"
table FilterOptions {
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// "filter" relation's output.
  filter_expression: Expression (required);
}

/// The contents of Relation.options will be ProjectOptions
/// if Relation.name = "project"
table ProjectOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the "project" relation's output.
  expressions: [Expression] (required);
}

/// The contents of Relation.options will be AggregateOptions
/// if Relation.name = "aggregate"
table AggregateOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the "aggregate" relation's output.
  aggregations: [Expression] (required);
  /// Keys by which `aggregations` will be grouped.
  keys: [Expression];
}

enum JoinKind : int {
  INNER,
  LEFT,
  RIGHT,
  FULL,
  SEMI,
  ANTI,
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.name = "join"
table JoinOptions {
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// "join" relation's output.
  on_expression: Expression (required);
  join_kind: JoinKind;
}

/// Whether lesser values should precede greater or vice versa.
enum Ordering : uint8 {
  ASCENDING,
  DESCENDING,
}

/// Whether nulls should precede or follow other values.
enum NullOrdering : uint8 {
  FIRST,
  LAST
}

table SortKey {
  value: Expression (required);
  ordering: Ordering = ASCENDING;
  null_ordering: NullOrdering = LAST;
}

/// The contents of Relation.options will be OrderByOptions
/// if Relation.name = "order_by"
table OrderByOptions {
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  keys: [SortKey] (required);
}

/// The contents of Relation.options will be LimitOptions
/// if Relation.name = "limit"
table LimitOptions {
  /// Set the maximum number of rows of output.
  count: long;
}

/// The contents of Relation.options will be LiteralOptions
/// if Relation.name = "literal"
table LiteralOptions {
  /// Batches of rows in this literal.
  batches: [RecordBatch] (required);
  /// A dictionary batch for this literal.
  dictionary_batch: DictionaryBatch;
}

/// The contents of Relation.options will be InteractiveOutputOptions
/// if Relation.name = "interactive_output"
table InteractiveOutputOptions {
  /// In an interactive context there is an implicit pipe open between
  /// the producer and the consumer along which output may be sent.
  /// `id` is an opaque identifier for such outputs; for example it could be used to
  /// identify which Jupyter output cell should receive the output.
  id: long;
}

table Plan {
  /// One or more output relations.
  sinks: [Relation] (required);
}

root_type Plan;
