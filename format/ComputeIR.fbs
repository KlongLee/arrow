// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

include "Schema.fbs";
include "Message.fbs";

namespace org.apache.arrow.flatbuf.computeir;

/// An expression is one of
/// - a Literal datum
/// - a reference to a Field from a Relation
/// - a call to a named function
/// On evaluation, an Expression will have either array or scalar shape.
union ExpressionImpl {
  Literal, FieldRef, Call
}

table Expression {
  impl: ExpressionImpl (required);
}

union Shape {
  Array, Scalar
}

table Scalar {}

table Array {
  /// Number of slots.
  length: long;
}

table Literal {
  /// Shape of this literal.
  shape: Shape (required);

  /// The type of this literal.
  type: Type (required);

  /// Buffers containing `length` elements of arrow-formatted data.
  /// If `length` is absent (this Literal is scalar), these buffers
  /// are sized to accommodate a single element of arrow-formatted data.
  /// XXX this can be optimized for trivial scalars later
  buffers: [Buffer];
}

table FieldRef {
  /// A sequence of field names to allow referencing potentially nested fields
  path: [string];

  /// For Expressions which might reference fields in multiple Relations,
  /// this index may be provided to indicate which Relation's fields
  /// `path` points into. For example in the case of a join,
  /// 0 refers to the left relation and 1 to the right relation.
  relation_index: int;

  /// The type of data in the referenced Field.
  type: Type;
}

table Call {
  /// The namespaced name of the function whose invocation this Call represents.
  /// For example: "arrow::add" or "gandiva::jit_3432".
  ///
  /// Names with no namespace are reserved for canonicalization.
  function_name: string (required);

  /// Parameters for `function_name`; content/format may be unique to each
  /// value of `function_name`.
  options: Buffer;

  /// The arguments passed to `function_name`.
  arguments: [Expression] (required);

  /// The type of data which invoking `function_name` will return.
  type: Type;
}

/// A relation is a set of rows with consistent schema.
table Relation {
  /// The namespaced name of this Relation.
  /// For example: "arrow::hash_join" or "gandiva::filter_and_project".
  ///
  /// Names with no namespace are reserved for canonical, "pure" relational
  /// algebraic operations, which currently include:
  ///   "filter"
  ///   "project"
  ///   "aggregate"
  ///   "join"
  ///   "order_by"
  ///   "limit"
  ///   "common"
  ///   "union"
  ///   "literal"
  ///   "interactive_output"
  relation_name: string (required);

  /// Parameters for `relation_name`; content/format may be unique to each
  /// value of `relation_name`.
  options: Buffer;

  /// The arguments passed to `relation_name`.
  arguments: [Relation] (required);

  /// The schema of rows in this Relation
  schema: Schema;
}

/// The contents of Relation.options will be FilterOptions
/// if Relation.relation_name = "filter"
table FilterOptions {
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// "filter" relation's output.
  filter_expression: Expression (required);
}

/// The contents of Relation.options will be ProjectOptions
/// if Relation.relation_name = "project"
table ProjectOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the "project" relation's output.
  expressions: [Expression] (required);
}

/// The contents of Relation.options will be AggregateOptions
/// if Relation.relation_name = "aggregate"
table AggregateOptions {
  /// Expressions which will be evaluated to produce to
  /// the rows of the "aggregate" relation's output.
  aggregations: [Expression] (required);
  /// Keys by which `aggregations` will be grouped.
  keys: [Expression] (required);
}

/// The contents of Relation.options will be JoinOptions
/// if Relation.relation_name = "join"
table JoinOptions {
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// "join" relation's output.
  on_expression: Expression (required);
  join_kind: string;
}

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values.
enum Ordering : uint8 {
  ASCENDING_THEN_NULLS,
  DESCENDING_THEN_NULLS,
  NULLS_THEN_ASCENDING,
  NULLS_THEN_DESCENDING
}

table SortKey {
  value: Expression (required);
  ordering: Ordering = ASCENDING_THEN_NULLS;
}

/// The contents of Relation.options will be OrderByOptions
/// if Relation.relation_name = "order_by"
table OrderByOptions {
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  keys: [SortKey] (required);
}

/// The contents of Relation.options will be LimitOptions
/// if Relation.relation_name = "limit"
table LimitOptions {
  /// Set the maximum number of rows of output.
  count: long;
}

/// The contents of Relation.options will be CommonOptions
/// if Relation.relation_name = "common"
table CommonOptions {
  /// Commons (CTEs in SQL) allow assigning a name to a stream
  /// of data and reusing it, potentially multiple times and
  /// potentially recursively.
  name: string (required);
}

/// The contents of Relation.options will be UnionOptions
/// if Relation.relation_name = "union"
table UnionOptions {
  /// For simplicity, all rows from any input to a "union" relation
  /// will always be concatenated into a single output- establishing
  /// uniqueness of output rows is deferred to other relations.
}

/// The contents of Relation.options will be LiteralOptions
/// if Relation.relation_name = "literal"
table LiteralOptions {
  /// Batches of rows in this literal.
  batches: [RecordBatch] (required);
}

/// A specification of a query.
table Plan {
  /// One or more output relations.
  sinks: [Relation] (required);

  /// Dictionary batches which may be referenced by Literals.
  dictionary_batch: [DictionaryBatch];

  /// If this Plan was derived from another (for example by running
  /// an optimization pass), that plan may be included here to
  /// provide a backtrace of derivations.
  derived_from: Plan;
}

/// Frequently there is an open direct channel between producers
/// of queries (client) and their consumers (server).
/// `Interactive` is provided to reify this case:
rpc_service Interactive {
  /// Restructure the provided Plan into one which contains only
  /// Relations that are directly executable by the server.
  /// These relations will usually be opaque to the client, but should
  /// be descriptively named and validly structured to provide a client
  /// with information on how the query will be executed.
  explain(Plan): Plan (streaming: "none");

  /// Execute a Plan.
  /// The Plan may contain a single Relation with
  /// relation_name="interactive_output", in which case data which
  /// is received by that sink will be streamed back to the client.
  execute(Plan): Message (streaming: "server");
}

root_type Plan;
