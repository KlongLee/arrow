/// Licensed to the Apache Software Foundation (ASF) under one
/// or more contributor license agreements.  See the NOTICE file
/// distributed with this work for additional information
/// regarding copyright ownership.  The ASF licenses this file
/// to you under the Apache License, Version 2.0 (the
/// "License"); you may not use this file except in compliance
/// with the License.  You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing,
/// software distributed under the License is distributed on an
/// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
/// KIND, either express or implied.  See the License for the
/// specific language governing permissions and limitations
/// under the License.

/// Arrow Compute IR (Intermediate Representation)
///
/// The purpose of these data structures is to provide a language- and compute
/// engine-agnostic representation of common analytical operations on Arrow
/// data. This may include so-called "logical query plans" generated by SQL
/// systems, but it can also be used to serialize
///
/// This IR deliberately does not provide for query planning or physical
/// execution details.

include "Schema.fbs";

namespace org.apache.arrow.flatbuf.computeir;

/// ----------------------------------------------------------------------
/// Scalar value serialization for literal data

/// Placeholder for any null value, whether with Null type or a different
/// non-Null type.
table NullLiteralData {}

/// For all data types represented as fixed-size-binary value. Boolean values
/// are to be represented as a single byte with value 1 (true) or 0 (false).
table PrimitiveLiteralData {
  data:[ubyte] (required);
}

/// For List, LargeList, and FixedSizeList.
table ListLiteralData {
  data:[LiteralData] (required);
}

/// For Struct.
table StructLiteralData {
  data:[LiteralData] (required);
}

/// For Union.
table UnionLiteralData {
  /// The type code (referencing the Union type) needed to reconstruct the
  /// correct literal value.
  type_code:int;  // required

  value:LiteralData (required);
}

/// Serialized data which, given a data type, can be unpacked into a scalar
/// value data structure.
///
/// NB(wesm): This is simpler from an IDL perspective than having a separate
/// data type for each Arrow type.
union LiteralData {
  NullLiteralData,
  PrimitiveLiteralData,
  ListLiteralData,
  StructLiteralData,
  UnionLiteralData
}

/// Literal serializes a scalar (constant) value in an array expression.
table Literal {
  type:Type (required);

  /// The data needed to reconstruct the literal value.
  data:LiteralData (required);
}

/// A sequence of literal values all having the same type.
table LiteralVector {
  type: Type (required);
  data:[LiteralData] (required);
}

/// ----------------------------------------------------------------------
/// One-dimensional operations (array/scalar input and output) and ArrayExpr

///
table TableRef {
  ///
  name:string (required);
}

///
table Column {
  name:string (required);

  ///
  table:TableRef;
}

/// Operation checks if values are null
table IsNull {
  expr: ArrayExpr (required);
}

/// Operation checks if values are not null
table IsNotNull {
  expr: ArrayExpr (required);
}

/// Not flips true/false in a boolean expression
table Not {}

enum BinaryOpType : int {
  ADD = 0,
  SUBTRACT = 1,
  MULTIPLY = 2,
  DIVIDE = 3,
  EQUAL = 4,
  NOT_EQUAL = 5,
  LESS = 6,
  LESS_EQUAL = 7,
  GREATER = 8,
  GREATER_EQUAL = 9,
  AND = 10,
  OR = 11,
  XOR = 12
}

/// Built-in binary operation
table BinaryOp {
  type:BinaryOpType;
  left:ArrayExpr (required);
  right:ArrayExpr (required);
}

enum FunctionType : int {
  SCALAR = 0,
  AGGREGATE = 1,
  WINDOW = 2
}

/// A descriptor for a built-in or user-defined function. Producers of the IR
/// are encouraged to reuse FunctionDescr objects (by reusing the Flatbuffers
/// offset) when a particular function appears multiple times in an expression.
table Function {
  /// Function name from list of available function names. Built-in functions
  /// are expected to be chosen from a list of "canonical" or "unambiguous"
  /// function names to provide a measure of normalization across backends that
  /// implement this Compute IR.
  ///
  /// The name may refer to a user-defined function which has been registered
  /// with the target engine. User-defined function data can also be passed
  /// with the "data" member.
  name:string (required);

  type:FunctionType = SCALAR;

  /// Optional arbitrary sidecar data (such as a serialized user-defined
  /// function).
  data:[ubyte];
}

/// A general function call
table FunctionCall {
  descr:Function (required);
  inputs:[ArrayExpr] (required);

  /// Optional non-data inputs for function invocation.
  options:[FunctionOption];
}

table IfElse {
  condition:ArrayExpr (required);
  then:ArrayExpr (required);

  ///
  else:ArrayExpr (required);
}

/// Scalar operation which returns
table IsIn {
  input:ArrayExpr (required);
  values:LiteralVector (required);
}

union ArrayOperation {
  Column,
  Literal,
  FunctionCall,
  IfElse,
  IsIn
}

///
///
/// An expression yielding a scalar value can be broadcasted to array shape as
/// needed depending on use.
table ArrayExpr {
  op:ArrayOperation (required);

  /// Optional name for array operation
  name:string;

  /// Optional indicative output type of the array operation. IR producers are
  /// encouraged to populate this field for the benefit of IR consumers.
  out_type:Type;
}

/// ----------------------------------------------------------------------
/// Operators that can apply either in an Array or Table context

///
table Filter {

}

/// ----------------------------------------------------------------------
/// Table operations and TableExpr

///
table ExternalTable {
  ///
  name: string (required);

  ///
  schema: Schema (required);
}

///
table Projection {

}

///
table Join {

}

union TableOperation {
  ExternalTable,
  Join
}

table TableExpr {
  op: TableOperation (required);

}

/// ----------------------------------------------------------------------

table LogicalPlan {
  ///
  tables: [Table];
}

root_type Schema;
